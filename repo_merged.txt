- ./.svelte-kit/ambient.d.ts
- ./.svelte-kit/generated/client/app.js
- ./.svelte-kit/generated/client/matchers.js
- ./.svelte-kit/generated/client/nodes/0.js
- ./.svelte-kit/generated/client/nodes/1.js
- ./.svelte-kit/generated/client/nodes/10.js
- ./.svelte-kit/generated/client/nodes/11.js
- ./.svelte-kit/generated/client/nodes/12.js
- ./.svelte-kit/generated/client/nodes/13.js
- ./.svelte-kit/generated/client/nodes/14.js
- ./.svelte-kit/generated/client/nodes/15.js
- ./.svelte-kit/generated/client/nodes/17.js
- ./.svelte-kit/generated/client/nodes/2.js
- ./.svelte-kit/generated/client/nodes/3.js
- ./.svelte-kit/generated/client/nodes/4.js
- ./.svelte-kit/generated/client/nodes/5.js
- ./.svelte-kit/generated/client/nodes/6.js
- ./.svelte-kit/generated/client/nodes/7.js
- ./.svelte-kit/generated/client/nodes/8.js
- ./.svelte-kit/generated/client/nodes/9.js
- ./.svelte-kit/generated/root.svelte
- ./.svelte-kit/generated/server/internal.js
- ./.svelte-kit/tsconfig.json
- ./.svelte-kit/types/route_meta_data.json
- ./.svelte-kit/types/src/routes/$types.d.ts
- ./.svelte-kit/types/src/routes/(authed)/$types.d.ts
- ./.svelte-kit/types/src/routes/(authed)/admin/$types.d.ts
- ./.svelte-kit/types/src/routes/(authed)/edit/[category=category]/[postID]/$types.d.ts
- ./.svelte-kit/types/src/routes/(authed)/edit/[category=category]/[postID]/proxy+page.server.js
- ./.svelte-kit/types/src/routes/(content)/$types.d.ts
- ./.svelte-kit/types/src/routes/(content)/amigues/$types.d.ts
- ./.svelte-kit/types/src/routes/(content)/amigues/[profile]/$types.d.ts
- ./.svelte-kit/types/src/routes/(content)/amigues/[profile]/proxy+page.js
- ./.svelte-kit/types/src/routes/(content)/calendario.ics/$types.d.ts
- ./.svelte-kit/types/src/routes/(content)/calendario/$types.d.ts
- ./.svelte-kit/types/src/routes/(content)/calendario/[event]/$types.d.ts
- ./.svelte-kit/types/src/routes/(content)/calendario/[event]/proxy+page.js
- ./.svelte-kit/types/src/routes/(content)/material/$types.d.ts
- ./.svelte-kit/types/src/routes/(content)/material/[post]/$types.d.ts
- ./.svelte-kit/types/src/routes/(content)/material/[post]/proxy+page.js
- ./.svelte-kit/types/src/routes/(content)/sitemap.xml/$types.d.ts
- ./.svelte-kit/types/src/routes/(content)/todo/$types.d.ts
- ./.svelte-kit/types/src/routes/(content)/wiki/$types.d.ts
- ./.svelte-kit/types/src/routes/(content)/wiki/[term]/$types.d.ts
- ./.svelte-kit/types/src/routes/(content)/wiki/[term]/proxy+page.js
- ./.svelte-kit/types/src/routes/.well-known/[param]/$types.d.ts
- ./.svelte-kit/types/src/routes/api/$types.d.ts
- ./.svelte-kit/types/src/routes/api/posts/$types.d.ts
- ./.svelte-kit/types/src/routes/api/wiki/$types.d.ts
- ./.svelte-kit/types/src/routes/auch/$types.d.ts
- ./.svelte-kit/types/src/routes/callback/$types.d.ts
- ./.svelte-kit/types/src/routes/login/$types.d.ts
- ./.svelte-kit/types/src/routes/login/proxy+page.server.js
- ./.svelte-kit/types/src/routes/logout/$types.d.ts
- ./.svelte-kit/types/src/routes/proxy+layout.server.js
- ./.svelte-kit/types/src/routes/rss/$types.d.ts
- ./LICENSE
- ./README.md
- ./jsconfig.json
- ./merge-repo.sh
- ./package.json
- ./playwright.config.js
- ./repo_merged.txt
- ./src/app.d.ts
- ./src/app.html
- ./src/hooks.server.js
- ./src/index.test.js
- ./src/lib/components/AgeModal.svelte
- ./src/lib/components/Calendar.svelte
- ./src/lib/components/CalendarHeader.svelte
- ./src/lib/components/Card.svelte
- ./src/lib/components/CardRow.svelte
- ./src/lib/components/Carrousel.svelte
- ./src/lib/components/FilterBar.svelte
- ./src/lib/components/Footer.svelte
- ./src/lib/components/GlosarioItem.svelte
- ./src/lib/components/GlosarioTree.svelte
- ./src/lib/components/HumanBody.svelte
- ./src/lib/components/InlineTag.svelte
- ./src/lib/components/LDTag.svelte
- ./src/lib/components/MiniMarkup.svelte
- ./src/lib/components/Navbar.svelte
- ./src/lib/components/PostList.svelte
- ./src/lib/components/PostListItem.svelte
- ./src/lib/components/SimpleIcon.svelte
- ./src/lib/components/Tag.svelte
- ./src/lib/components/TagGroup.svelte
- ./src/lib/components/Tags.svelte
- ./src/lib/components/TagsInput.svelte
- ./src/lib/components/UserMenu.svelte
- ./src/lib/components/body-parts.js
- ./src/lib/external/github.js
- ./src/lib/styles/style.scss
- ./src/lib/types.d.js
- ./src/lib/utils/customRehype.js
- ./src/lib/utils/hardcodedTags.js
- ./src/lib/utils/index.js
- ./src/lib/utils/stores.js
- ./src/lib/utils/tags.js
- ./src/params/category.js
- ./src/routes/(authed)/+layout.server.js
- ./src/routes/(authed)/+layout.svelte
- ./src/routes/(authed)/admin/+page.server.js
- ./src/routes/(authed)/admin/+page.svelte
- ./src/routes/(authed)/edit/[category=category]/[postID]/+page.server.js
- ./src/routes/(authed)/edit/[category=category]/[postID]/+page.svelte
- ./src/routes/(content)/+layout.svelte
- ./src/routes/(content)/+page.svelte
- ./src/routes/(content)/amigues/+page.svelte
- ./src/routes/(content)/amigues/[profile]/+page.js
- ./src/routes/(content)/amigues/[profile]/+page.svelte
- ./src/routes/(content)/calendario.ics/+server.js
- ./src/routes/(content)/calendario/+page.svelte
- ./src/routes/(content)/calendario/[event]/+page.js
- ./src/routes/(content)/calendario/[event]/+page.svelte
- ./src/routes/(content)/material/+page.svelte
- ./src/routes/(content)/material/[post]/+page.js
- ./src/routes/(content)/material/[post]/+page.svelte
- ./src/routes/(content)/sitemap.xml/+server.js
- ./src/routes/(content)/todo/+page.svelte
- ./src/routes/(content)/wiki/+page.svelte
- ./src/routes/(content)/wiki/[term]/+page.js
- ./src/routes/(content)/wiki/[term]/+page.svelte
- ./src/routes/+layout.server.js
- ./src/routes/+layout.svelte
- ./src/routes/.well-known/[param]/+server.js
- ./src/routes/api/+server.js
- ./src/routes/api/posts/+server.js
- ./src/routes/api/wiki/+server.js
- ./src/routes/auch/+page.server.js
- ./src/routes/callback/+server.js
- ./src/routes/login/+page.server.js
- ./src/routes/login/+page.svelte
- ./src/routes/logout/+server.js
- ./src/routes/rss/+server.js
- ./static/robots.txt
- ./static/site.webmanifest
- ./svelte.config.js
- ./tests/test.js
- ./vite.config.js
- ./wrangler.toml

# Repositorio fusionado
# Generado el Wed Mar 19 01:24:31 UTC 2025
# Archivos incluidos:

# =============================================
# ARCHIVO: ./.svelte-kit/ambient.d.ts
# =============================================


// this file is generated — do not edit it


/// <reference types="@sveltejs/kit" />

/**
 * Environment variables [loaded by Vite](https://vitejs.dev/guide/env-and-mode.html#env-files) from `.env` files and `process.env`. Like [`$env/dynamic/private`](https://kit.svelte.dev/docs/modules#$env-dynamic-private), this module cannot be imported into client-side code. This module only includes variables that _do not_ begin with [`config.kit.env.publicPrefix`](https://kit.svelte.dev/docs/configuration#env) _and do_ start with [`config.kit.env.privatePrefix`](https://kit.svelte.dev/docs/configuration#env) (if configured).
 * 
 * _Unlike_ [`$env/dynamic/private`](https://kit.svelte.dev/docs/modules#$env-dynamic-private), the values exported from this module are statically injected into your bundle at build time, enabling optimisations like dead code elimination.
 * 
 * ```ts
 * import { API_KEY } from '$env/static/private';
 * ```
 * 
 * Note that all environment variables referenced in your code should be declared (for example in an `.env` file), even if they don't have a value until the app is deployed:
 * 
 * ```
 * MY_FEATURE_FLAG=""
 * ```
 * 
 * You can override `.env` values from the command line like so:
 * 
 * ```bash
 * MY_FEATURE_FLAG="enabled" npm run dev
 * ```
 */
declare module '$env/static/private' {
	export const LESSOPEN: string;
	export const LESS_TERMCAP_se: string;
	export const GITHUB_TOKEN: string;
	export const USER: string;
	export const LESS_TERMCAP_ue: string;
	export const npm_config_user_agent: string;
	export const npm_node_execpath: string;
	export const WT_PROFILE_ID: string;
	export const SHLVL: string;
	export const GREP_COLOR: string;
	export const npm_config_noproxy: string;
	export const HOME: string;
	export const OLDPWD: string;
	export const LESS: string;
	export const NVM_BIN: string;
	export const npm_package_json: string;
	export const NVM_INC: string;
	export const PAGER: string;
	export const LESS_TERMCAP_so: string;
	export const GREP_COLORS: string;
	export const npm_config_userconfig: string;
	export const npm_config_local_prefix: string;
	export const DBUS_SESSION_BUS_ADDRESS: string;
	export const VISUAL: string;
	export const npm_config_engine_strict: string;
	export const WSL_DISTRO_NAME: string;
	export const COLOR: string;
	export const NPM_TOKEN: string;
	export const NVM_DIR: string;
	export const WAYLAND_DISPLAY: string;
	export const LOGNAME: string;
	export const PULSE_SERVER: string;
	export const WSL_INTEROP: string;
	export const NAME: string;
	export const LESS_TERMCAP_us: string;
	export const _: string;
	export const npm_config_prefix: string;
	export const npm_config_npm_version: string;
	export const TERM: string;
	export const npm_config_cache: string;
	export const npm_config_node_gyp: string;
	export const PATH: string;
	export const NODE: string;
	export const npm_package_name: string;
	export const XDG_RUNTIME_DIR: string;
	export const WT_SESSION: string;
	export const DISPLAY: string;
	export const LANG: string;
	export const LS_COLORS: string;
	export const npm_lifecycle_script: string;
	export const SHELL: string;
	export const npm_package_version: string;
	export const npm_lifecycle_event: string;
	export const LESS_TERMCAP_mb: string;
	export const LESS_TERMCAP_md: string;
	export const npm_config_globalconfig: string;
	export const npm_config_init_module: string;
	export const PWD: string;
	export const LESS_TERMCAP_me: string;
	export const npm_execpath: string;
	export const NVM_CD_FLAGS: string;
	export const npm_config_global_prefix: string;
	export const npm_command: string;
	export const HOSTTYPE: string;
	export const WSL2_GUI_APPS_ENABLED: string;
	export const WSLENV: string;
	export const EDITOR: string;
	export const INIT_CWD: string;
	export const NODE_ENV: string;
}

/**
 * Similar to [`$env/static/private`](https://kit.svelte.dev/docs/modules#$env-static-private), except that it only includes environment variables that begin with [`config.kit.env.publicPrefix`](https://kit.svelte.dev/docs/configuration#env) (which defaults to `PUBLIC_`), and can therefore safely be exposed to client-side code.
 * 
 * Values are replaced statically at build time.
 * 
 * ```ts
 * import { PUBLIC_BASE_URL } from '$env/static/public';
 * ```
 */
declare module '$env/static/public' {
	
}

/**
 * This module provides access to runtime environment variables, as defined by the platform you're running on. For example if you're using [`adapter-node`](https://github.com/sveltejs/kit/tree/master/packages/adapter-node) (or running [`vite preview`](https://kit.svelte.dev/docs/cli)), this is equivalent to `process.env`. This module only includes variables that _do not_ begin with [`config.kit.env.publicPrefix`](https://kit.svelte.dev/docs/configuration#env) _and do_ start with [`config.kit.env.privatePrefix`](https://kit.svelte.dev/docs/configuration#env) (if configured).
 * 
 * This module cannot be imported into client-side code.
 * 
 * ```ts
 * import { env } from '$env/dynamic/private';
 * console.log(env.DEPLOYMENT_SPECIFIC_VARIABLE);
 * ```
 * 
 * > In `dev`, `$env/dynamic` always includes environment variables from `.env`. In `prod`, this behavior will depend on your adapter.
 */
declare module '$env/dynamic/private' {
	export const env: {
		LESSOPEN: string;
		LESS_TERMCAP_se: string;
		GITHUB_TOKEN: string;
		USER: string;
		LESS_TERMCAP_ue: string;
		npm_config_user_agent: string;
		npm_node_execpath: string;
		WT_PROFILE_ID: string;
		SHLVL: string;
		GREP_COLOR: string;
		npm_config_noproxy: string;
		HOME: string;
		OLDPWD: string;
		LESS: string;
		NVM_BIN: string;
		npm_package_json: string;
		NVM_INC: string;
		PAGER: string;
		LESS_TERMCAP_so: string;
		GREP_COLORS: string;
		npm_config_userconfig: string;
		npm_config_local_prefix: string;
		DBUS_SESSION_BUS_ADDRESS: string;
		VISUAL: string;
		npm_config_engine_strict: string;
		WSL_DISTRO_NAME: string;
		COLOR: string;
		NPM_TOKEN: string;
		NVM_DIR: string;
		WAYLAND_DISPLAY: string;
		LOGNAME: string;
		PULSE_SERVER: string;
		WSL_INTEROP: string;
		NAME: string;
		LESS_TERMCAP_us: string;
		_: string;
		npm_config_prefix: string;
		npm_config_npm_version: string;
		TERM: string;
		npm_config_cache: string;
		npm_config_node_gyp: string;
		PATH: string;
		NODE: string;
		npm_package_name: string;
		XDG_RUNTIME_DIR: string;
		WT_SESSION: string;
		DISPLAY: string;
		LANG: string;
		LS_COLORS: string;
		npm_lifecycle_script: string;
		SHELL: string;
		npm_package_version: string;
		npm_lifecycle_event: string;
		LESS_TERMCAP_mb: string;
		LESS_TERMCAP_md: string;
		npm_config_globalconfig: string;
		npm_config_init_module: string;
		PWD: string;
		LESS_TERMCAP_me: string;
		npm_execpath: string;
		NVM_CD_FLAGS: string;
		npm_config_global_prefix: string;
		npm_command: string;
		HOSTTYPE: string;
		WSL2_GUI_APPS_ENABLED: string;
		WSLENV: string;
		EDITOR: string;
		INIT_CWD: string;
		NODE_ENV: string;
		[key: `PUBLIC_${string}`]: undefined;
		[key: `${string}`]: string | undefined;
	}
}

/**
 * Similar to [`$env/dynamic/private`](https://kit.svelte.dev/docs/modules#$env-dynamic-private), but only includes variables that begin with [`config.kit.env.publicPrefix`](https://kit.svelte.dev/docs/configuration#env) (which defaults to `PUBLIC_`), and can therefore safely be exposed to client-side code.
 * 
 * Note that public dynamic environment variables must all be sent from the server to the client, causing larger network requests — when possible, use `$env/static/public` instead.
 * 
 * ```ts
 * import { env } from '$env/dynamic/public';
 * console.log(env.PUBLIC_DEPLOYMENT_SPECIFIC_VARIABLE);
 * ```
 */
declare module '$env/dynamic/public' {
	export const env: {
		[key: `PUBLIC_${string}`]: string | undefined;
	}
}

# =============================================
# ARCHIVO: ./.svelte-kit/generated/client/app.js
# =============================================

export { matchers } from './matchers.js';

export const nodes = [
	() => import('./nodes/0'),
	() => import('./nodes/1'),
	() => import('./nodes/2'),
	() => import('./nodes/3'),
	() => import('./nodes/4'),
	() => import('./nodes/5'),
	() => import('./nodes/6'),
	() => import('./nodes/7'),
	() => import('./nodes/8'),
	() => import('./nodes/9'),
	() => import('./nodes/10'),
	() => import('./nodes/11'),
	() => import('./nodes/12'),
	() => import('./nodes/13'),
	() => import('./nodes/14'),
	() => import('./nodes/15'),
	() => import('./nodes/16'),
	() => import('./nodes/17')
];

export const server_loads = [0,2];

export const dictionary = {
		"/(content)": [6,[3]],
		"/(authed)/admin": [~4,[2]],
		"/(content)/amigues": [7,[3]],
		"/(content)/amigues/[profile]": [8,[3]],
		"/auch": [~16],
		"/(content)/calendario": [9,[3]],
		"/(content)/calendario/[event]": [10,[3]],
		"/(authed)/edit/[category=category]/[postID]": [~5,[2]],
		"/login": [~17],
		"/(content)/material": [11,[3]],
		"/(content)/material/[post]": [12,[3]],
		"/(content)/todo": [13,[3]],
		"/(content)/wiki": [14,[3]],
		"/(content)/wiki/[term]": [15,[3]]
	};

export const hooks = {
	handleError: (({ error }) => { console.error(error) }),
};

export { default as root } from '../root.svelte';
# =============================================
# ARCHIVO: ./.svelte-kit/generated/client/matchers.js
# =============================================

import { match as category } from "../../../src/params/category.js";

export const matchers = { category };
# =============================================
# ARCHIVO: ./.svelte-kit/generated/client/nodes/0.js
# =============================================

export { default as component } from "../../../../src/routes/+layout.svelte";
# =============================================
# ARCHIVO: ./.svelte-kit/generated/client/nodes/1.js
# =============================================

export { default as component } from "../../../../node_modules/@sveltejs/kit/src/runtime/components/error.svelte";
# =============================================
# ARCHIVO: ./.svelte-kit/generated/client/nodes/10.js
# =============================================

import * as universal from "../../../../src/routes/(content)/calendario/[event]/+page.js";
export { universal };
export { default as component } from "../../../../src/routes/(content)/calendario/[event]/+page.svelte";
# =============================================
# ARCHIVO: ./.svelte-kit/generated/client/nodes/11.js
# =============================================

export { default as component } from "../../../../src/routes/(content)/material/+page.svelte";
# =============================================
# ARCHIVO: ./.svelte-kit/generated/client/nodes/12.js
# =============================================

import * as universal from "../../../../src/routes/(content)/material/[post]/+page.js";
export { universal };
export { default as component } from "../../../../src/routes/(content)/material/[post]/+page.svelte";
# =============================================
# ARCHIVO: ./.svelte-kit/generated/client/nodes/13.js
# =============================================

export { default as component } from "../../../../src/routes/(content)/todo/+page.svelte";
# =============================================
# ARCHIVO: ./.svelte-kit/generated/client/nodes/14.js
# =============================================

export { default as component } from "../../../../src/routes/(content)/wiki/+page.svelte";
# =============================================
# ARCHIVO: ./.svelte-kit/generated/client/nodes/15.js
# =============================================

import * as universal from "../../../../src/routes/(content)/wiki/[term]/+page.js";
export { universal };
export { default as component } from "../../../../src/routes/(content)/wiki/[term]/+page.svelte";
# =============================================
# ARCHIVO: ./.svelte-kit/generated/client/nodes/17.js
# =============================================

export { default as component } from "../../../../src/routes/login/+page.svelte";
# =============================================
# ARCHIVO: ./.svelte-kit/generated/client/nodes/2.js
# =============================================

export { default as component } from "../../../../src/routes/(authed)/+layout.svelte";
# =============================================
# ARCHIVO: ./.svelte-kit/generated/client/nodes/3.js
# =============================================

export { default as component } from "../../../../src/routes/(content)/+layout.svelte";
# =============================================
# ARCHIVO: ./.svelte-kit/generated/client/nodes/4.js
# =============================================

export { default as component } from "../../../../src/routes/(authed)/admin/+page.svelte";
# =============================================
# ARCHIVO: ./.svelte-kit/generated/client/nodes/5.js
# =============================================

export { default as component } from "../../../../src/routes/(authed)/edit/[category=category]/[postID]/+page.svelte";
# =============================================
# ARCHIVO: ./.svelte-kit/generated/client/nodes/6.js
# =============================================

export { default as component } from "../../../../src/routes/(content)/+page.svelte";
# =============================================
# ARCHIVO: ./.svelte-kit/generated/client/nodes/7.js
# =============================================

export { default as component } from "../../../../src/routes/(content)/amigues/+page.svelte";
# =============================================
# ARCHIVO: ./.svelte-kit/generated/client/nodes/8.js
# =============================================

import * as universal from "../../../../src/routes/(content)/amigues/[profile]/+page.js";
export { universal };
export { default as component } from "../../../../src/routes/(content)/amigues/[profile]/+page.svelte";
# =============================================
# ARCHIVO: ./.svelte-kit/generated/client/nodes/9.js
# =============================================

export { default as component } from "../../../../src/routes/(content)/calendario/+page.svelte";
# =============================================
# ARCHIVO: ./.svelte-kit/generated/root.svelte
# =============================================

<!-- This file is generated by @sveltejs/kit — do not edit it! -->

<script>
	import { setContext, afterUpdate, onMount, tick } from 'svelte';
	import { browser } from '$app/environment';

	// stores
	export let stores;
	export let page;
	
	export let constructors;
	export let components = [];
	export let form;
	export let data_0 = null;
	export let data_1 = null;
	export let data_2 = null;

	if (!browser) {
		setContext('__svelte__', stores);
	}

	$: stores.page.set(page);
	afterUpdate(stores.page.notify);

	let mounted = false;
	let navigated = false;
	let title = null;

	onMount(() => {
		const unsubscribe = stores.page.subscribe(() => {
			if (mounted) {
				navigated = true;
				tick().then(() => {
					title = document.title || 'untitled page';
				});
			}
		});

		mounted = true;
		return unsubscribe;
	});
</script>

{#if constructors[1]}
	<svelte:component this={constructors[0]} bind:this={components[0]} data={data_0}>
		{#if constructors[2]}
			<svelte:component this={constructors[1]} bind:this={components[1]} data={data_1}>
				<svelte:component this={constructors[2]} bind:this={components[2]} data={data_2} {form} />
			</svelte:component>
		{:else}
			<svelte:component this={constructors[1]} bind:this={components[1]} data={data_1} {form} />
		{/if}
	</svelte:component>
{:else}
	<svelte:component this={constructors[0]} bind:this={components[0]} data={data_0} {form} />
{/if}

{#if mounted}
	<div id="svelte-announcer" aria-live="assertive" aria-atomic="true" style="position: absolute; left: 0; top: 0; clip: rect(0 0 0 0); clip-path: inset(50%); overflow: hidden; white-space: nowrap; width: 1px; height: 1px">
		{#if navigated}
			{title}
		{/if}
	</div>
{/if}
# =============================================
# ARCHIVO: ./.svelte-kit/generated/server/internal.js
# =============================================


import root from '../root.svelte';
import { set_building } from '__sveltekit/environment';
import { set_assets } from '__sveltekit/paths';
import { set_private_env, set_public_env } from '../../../node_modules/@sveltejs/kit/src/runtime/shared-server.js';

export const options = {
	app_template_contains_nonce: false,
	csp: {"mode":"auto","directives":{"upgrade-insecure-requests":false,"block-all-mixed-content":false},"reportOnly":{"upgrade-insecure-requests":false,"block-all-mixed-content":false}},
	csrf_check_origin: true,
	track_server_fetches: false,
	embedded: false,
	env_public_prefix: 'PUBLIC_',
	env_private_prefix: '',
	hooks: null, // added lazily, via `get_hooks`
	preload_strategy: "modulepreload",
	root,
	service_worker: false,
	templates: {
		app: ({ head, body, assets, nonce, env }) => "<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n\t<meta charset=\"utf-8\" />\n\t<link rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"" + assets + "/apple-touch-icon.png\" />\n\t<link rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=\"" + assets + "/favicon-32x32.png\" />\n\t<link rel=\"icon\" type=\"image/png\" sizes=\"16x16\" href=\"" + assets + "/favicon-16x16.png\" />\n\t<link rel=\"manifest\" href=\"" + assets + "/site.webmanifest\" />\n\t<link rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS Feed for KinkyVibe.ar\" href=\"/rss\" />\n\t<link rel=\"preconnect\" href=\"https://fonts.googleapis.com\" />\n\t<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin />\n\t<link href=\"https://fonts.googleapis.com/css2?family=Lato&display=swap\" rel=\"stylesheet\" />\n\t<meta name=\"viewport\" content=\"width=device-width\" />\n\t" + head + "\n</head>\n\n<body data-sveltekit-preload-data=\"hover\">\n\t<div style=\"display: contents\">" + body + "</div>\n\n\t<!-- Cloudflare Web Analytics -->\n\t<script defer src=\"https://static.cloudflareinsights.com/beacon.min.js\"\n\t\tdata-cf-beacon='{\"token\": \"eb67d1991a6e47079e98bc624a13020d\"}'></script>\n\t<!-- End Cloudflare Web Analytics -->\n</body>\n\n</html>",
		error: ({ status, message }) => "<!doctype html>\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"utf-8\" />\n\t\t<title>" + message + "</title>\n\n\t\t<style>\n\t\t\tbody {\n\t\t\t\t--bg: white;\n\t\t\t\t--fg: #222;\n\t\t\t\t--divider: #ccc;\n\t\t\t\tbackground: var(--bg);\n\t\t\t\tcolor: var(--fg);\n\t\t\t\tfont-family:\n\t\t\t\t\tsystem-ui,\n\t\t\t\t\t-apple-system,\n\t\t\t\t\tBlinkMacSystemFont,\n\t\t\t\t\t'Segoe UI',\n\t\t\t\t\tRoboto,\n\t\t\t\t\tOxygen,\n\t\t\t\t\tUbuntu,\n\t\t\t\t\tCantarell,\n\t\t\t\t\t'Open Sans',\n\t\t\t\t\t'Helvetica Neue',\n\t\t\t\t\tsans-serif;\n\t\t\t\tdisplay: flex;\n\t\t\t\talign-items: center;\n\t\t\t\tjustify-content: center;\n\t\t\t\theight: 100vh;\n\t\t\t\tmargin: 0;\n\t\t\t}\n\n\t\t\t.error {\n\t\t\t\tdisplay: flex;\n\t\t\t\talign-items: center;\n\t\t\t\tmax-width: 32rem;\n\t\t\t\tmargin: 0 1rem;\n\t\t\t}\n\n\t\t\t.status {\n\t\t\t\tfont-weight: 200;\n\t\t\t\tfont-size: 3rem;\n\t\t\t\tline-height: 1;\n\t\t\t\tposition: relative;\n\t\t\t\ttop: -0.05rem;\n\t\t\t}\n\n\t\t\t.message {\n\t\t\t\tborder-left: 1px solid var(--divider);\n\t\t\t\tpadding: 0 0 0 1rem;\n\t\t\t\tmargin: 0 0 0 1rem;\n\t\t\t\tmin-height: 2.5rem;\n\t\t\t\tdisplay: flex;\n\t\t\t\talign-items: center;\n\t\t\t}\n\n\t\t\t.message h1 {\n\t\t\t\tfont-weight: 400;\n\t\t\t\tfont-size: 1em;\n\t\t\t\tmargin: 0;\n\t\t\t}\n\n\t\t\t@media (prefers-color-scheme: dark) {\n\t\t\t\tbody {\n\t\t\t\t\t--bg: #222;\n\t\t\t\t\t--fg: #ddd;\n\t\t\t\t\t--divider: #666;\n\t\t\t\t}\n\t\t\t}\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<div class=\"error\">\n\t\t\t<span class=\"status\">" + status + "</span>\n\t\t\t<div class=\"message\">\n\t\t\t\t<h1>" + message + "</h1>\n\t\t\t</div>\n\t\t</div>\n\t</body>\n</html>\n"
	},
	version_hash: "aqev5q"
};

export function get_hooks() {
	return import("../../../src/hooks.server.js");
}

export { set_assets, set_building, set_private_env, set_public_env };

# =============================================
# ARCHIVO: ./.svelte-kit/tsconfig.json
# =============================================

{
	"compilerOptions": {
		"paths": {
			"$lib": [
				"../src/lib"
			],
			"$lib/*": [
				"../src/lib/*"
			]
		},
		"rootDirs": [
			"..",
			"./types"
		],
		"importsNotUsedAsValues": "error",
		"isolatedModules": true,
		"preserveValueImports": true,
		"lib": [
			"esnext",
			"DOM",
			"DOM.Iterable"
		],
		"moduleResolution": "node",
		"module": "esnext",
		"noEmit": true,
		"target": "esnext",
		"ignoreDeprecations": "5.0"
	},
	"include": [
		"ambient.d.ts",
		"./types/**/$types.d.ts",
		"../vite.config.js",
		"../vite.config.ts",
		"../src/**/*.js",
		"../src/**/*.ts",
		"../src/**/*.svelte",
		"../tests/**/*.js",
		"../tests/**/*.ts",
		"../tests/**/*.svelte"
	],
	"exclude": [
		"../node_modules/**",
		"./[!ambient.d.ts]**",
		"../src/service-worker.js",
		"../src/service-worker.ts",
		"../src/service-worker.d.ts"
	]
}
# =============================================
# ARCHIVO: ./.svelte-kit/types/route_meta_data.json
# =============================================

{
	"/(content)": [
		"src/routes/+layout.server.js",
		"src/routes/+layout.server.js"
	],
	"/(authed)": [
		"src/routes/(authed)/+layout.server.js",
		"src/routes/+layout.server.js"
	],
	"/": [
		"src/routes/+layout.server.js"
	],
	"/.well-known/[param]": [
		"src/routes/.well-known/[param]/+server.js"
	],
	"/(authed)/admin": [
		"src/routes/(authed)/admin/+page.server.js",
		"src/routes/(authed)/+layout.server.js",
		"src/routes/+layout.server.js"
	],
	"/(content)/amigues": [
		"src/routes/+layout.server.js"
	],
	"/(content)/amigues/[profile]": [
		"src/routes/(content)/amigues/[profile]/+page.js",
		"src/routes/+layout.server.js"
	],
	"/api": [
		"src/routes/api/+server.js"
	],
	"/api/posts": [
		"src/routes/api/posts/+server.js"
	],
	"/api/wiki": [
		"src/routes/api/wiki/+server.js"
	],
	"/auch": [
		"src/routes/auch/+page.server.js",
		"src/routes/+layout.server.js"
	],
	"/(content)/calendario.ics": [
		"src/routes/(content)/calendario.ics/+server.js"
	],
	"/(content)/calendario": [
		"src/routes/+layout.server.js"
	],
	"/(content)/calendario/[event]": [
		"src/routes/(content)/calendario/[event]/+page.js",
		"src/routes/+layout.server.js"
	],
	"/callback": [
		"src/routes/callback/+server.js"
	],
	"/(authed)/edit/[category=category]/[postID]": [
		"src/routes/(authed)/edit/[category=category]/[postID]/+page.server.js",
		"src/routes/(authed)/+layout.server.js",
		"src/routes/+layout.server.js"
	],
	"/login": [
		"src/routes/login/+page.server.js",
		"src/routes/+layout.server.js"
	],
	"/logout": [
		"src/routes/logout/+server.js"
	],
	"/(content)/material": [
		"src/routes/+layout.server.js"
	],
	"/(content)/material/[post]": [
		"src/routes/(content)/material/[post]/+page.js",
		"src/routes/+layout.server.js"
	],
	"/rss": [
		"src/routes/rss/+server.js"
	],
	"/(content)/sitemap.xml": [
		"src/routes/(content)/sitemap.xml/+server.js"
	],
	"/(content)/todo": [
		"src/routes/+layout.server.js"
	],
	"/(content)/wiki": [
		"src/routes/+layout.server.js"
	],
	"/(content)/wiki/[term]": [
		"src/routes/(content)/wiki/[term]/+page.js",
		"src/routes/+layout.server.js"
	]
}
# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/$types.d.ts
# =============================================

import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = {  };
type RouteId = '/';
type MaybeWithVoid<T> = {} extends T ? T | void : T;
export type RequiredKeys<T> = { [K in keyof T]-?: {} extends { [P in K]: T[K] } ? never : K; }[keyof T];
type OutputDataShape<T> = MaybeWithVoid<Omit<App.PageData, RequiredKeys<T>> & Partial<Pick<App.PageData, keyof T & keyof App.PageData>> & Record<string, any>>
type EnsureDefined<T> = T extends null | undefined ? {} : T;
type OptionalUnion<U extends Record<string, any>, A extends keyof U = U extends U ? keyof U : never> = U extends unknown ? { [P in Exclude<A, keyof U>]?: never } & U : never;
export type Snapshot<T = any> = Kit.Snapshot<T>;
type LayoutRouteId = RouteId | "/(authed)/admin" | "/(authed)/edit/[category=category]/[postID]" | "/(content)" | "/(content)/amigues" | "/(content)/amigues/[profile]" | "/(content)/calendario" | "/(content)/calendario/[event]" | "/(content)/material" | "/(content)/material/[post]" | "/(content)/todo" | "/(content)/wiki" | "/(content)/wiki/[term]" | "/auch" | "/login" | null
type LayoutParams = RouteParams & { category?: MatcherParam<typeof import('../../../../src/params/category').match>; postID?: string; profile?: string; event?: string; post?: string; term?: string }
type LayoutServerParentData = EnsureDefined<{}>;
type LayoutParentData = EnsureDefined<{}>;

export type LayoutServerLoad<OutputData extends OutputDataShape<LayoutServerParentData> = OutputDataShape<LayoutServerParentData>> = Kit.ServerLoad<LayoutParams, LayoutServerParentData, OutputData, LayoutRouteId>;
export type LayoutServerLoadEvent = Parameters<LayoutServerLoad>[0];
export type LayoutServerData = Expand<OptionalUnion<EnsureDefined<Kit.AwaitedProperties<Awaited<ReturnType<typeof import('./proxy+layout.server.js').load>>>>>>;
export type LayoutData = Expand<Omit<LayoutParentData, keyof LayoutServerData> & EnsureDefined<LayoutServerData>>;
export type RequestEvent = Kit.RequestEvent<RouteParams, RouteId>;
# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/(authed)/$types.d.ts
# =============================================

import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = {  };
type RouteId = '/(authed)';
type MaybeWithVoid<T> = {} extends T ? T | void : T;
export type RequiredKeys<T> = { [K in keyof T]-?: {} extends { [P in K]: T[K] } ? never : K; }[keyof T];
type OutputDataShape<T> = MaybeWithVoid<Omit<App.PageData, RequiredKeys<T>> & Partial<Pick<App.PageData, keyof T & keyof App.PageData>> & Record<string, any>>
type EnsureDefined<T> = T extends null | undefined ? {} : T;
type OptionalUnion<U extends Record<string, any>, A extends keyof U = U extends U ? keyof U : never> = U extends unknown ? { [P in Exclude<A, keyof U>]?: never } & U : never;
export type Snapshot<T = any> = Kit.Snapshot<T>;
type LayoutRouteId = RouteId | "/(authed)/admin" | "/(authed)/edit/[category=category]/[postID]"
type LayoutParams = RouteParams & { category?: MatcherParam<typeof import('../../../../../src/params/category').match>; postID?: string }
type LayoutServerParentData = EnsureDefined<import('../$types.js').LayoutServerData>;
type LayoutParentData = EnsureDefined<import('../$types.js').LayoutData>;

export type LayoutServerLoad<OutputData extends Partial<App.PageData> & Record<string, any> | void = Partial<App.PageData> & Record<string, any> | void> = Kit.ServerLoad<LayoutParams, LayoutServerParentData, OutputData, LayoutRouteId>;
export type LayoutServerLoadEvent = Parameters<LayoutServerLoad>[0];
export type LayoutServerData = Expand<OptionalUnion<EnsureDefined<Kit.AwaitedProperties<Awaited<ReturnType<typeof import('../../../../../src/routes/(authed)/+layout.server.js').load>>>>>>;
export type LayoutData = Expand<Omit<LayoutParentData, keyof LayoutServerData> & EnsureDefined<LayoutServerData>>;
export type RequestEvent = Kit.RequestEvent<RouteParams, RouteId>;
# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/(authed)/admin/$types.d.ts
# =============================================

import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = {  };
type RouteId = '/(authed)/admin';
type MaybeWithVoid<T> = {} extends T ? T | void : T;
export type RequiredKeys<T> = { [K in keyof T]-?: {} extends { [P in K]: T[K] } ? never : K; }[keyof T];
type OutputDataShape<T> = MaybeWithVoid<Omit<App.PageData, RequiredKeys<T>> & Partial<Pick<App.PageData, keyof T & keyof App.PageData>> & Record<string, any>>
type EnsureDefined<T> = T extends null | undefined ? {} : T;
type OptionalUnion<U extends Record<string, any>, A extends keyof U = U extends U ? keyof U : never> = U extends unknown ? { [P in Exclude<A, keyof U>]?: never } & U : never;
export type Snapshot<T = any> = Kit.Snapshot<T>;
type PageServerParentData = Omit<EnsureDefined<import('../../$types.js').LayoutServerData>, keyof import('../$types.js').LayoutServerData> & EnsureDefined<import('../$types.js').LayoutServerData>;
type PageParentData = Omit<EnsureDefined<import('../../$types.js').LayoutData>, keyof import('../$types.js').LayoutData> & EnsureDefined<import('../$types.js').LayoutData>;

export type PageServerLoad<OutputData extends OutputDataShape<PageServerParentData> = OutputDataShape<PageServerParentData>> = Kit.ServerLoad<RouteParams, PageServerParentData, OutputData, RouteId>;
export type PageServerLoadEvent = Parameters<PageServerLoad>[0];
export type ActionData = unknown;
export type PageServerData = Expand<OptionalUnion<EnsureDefined<Kit.AwaitedProperties<Awaited<ReturnType<typeof import('../../../../../../src/routes/(authed)/admin/+page.server.js').load>>>>>>;
export type PageData = Expand<Omit<PageParentData, keyof PageServerData> & EnsureDefined<PageServerData>>;
export type Action<OutputData extends Record<string, any> | void = Record<string, any> | void> = Kit.Action<RouteParams, OutputData, RouteId>
export type Actions<OutputData extends Record<string, any> | void = Record<string, any> | void> = Kit.Actions<RouteParams, OutputData, RouteId>
export type RequestEvent = Kit.RequestEvent<RouteParams, RouteId>;
# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/(authed)/edit/[category=category]/[postID]/$types.d.ts
# =============================================

import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = { category: MatcherParam<typeof import('../../../../../../../../src/params/category').match>; postID: string };
type RouteId = '/(authed)/edit/[category=category]/[postID]';
type MaybeWithVoid<T> = {} extends T ? T | void : T;
export type RequiredKeys<T> = { [K in keyof T]-?: {} extends { [P in K]: T[K] } ? never : K; }[keyof T];
type OutputDataShape<T> = MaybeWithVoid<Omit<App.PageData, RequiredKeys<T>> & Partial<Pick<App.PageData, keyof T & keyof App.PageData>> & Record<string, any>>
type EnsureDefined<T> = T extends null | undefined ? {} : T;
type OptionalUnion<U extends Record<string, any>, A extends keyof U = U extends U ? keyof U : never> = U extends unknown ? { [P in Exclude<A, keyof U>]?: never } & U : never;
export type Snapshot<T = any> = Kit.Snapshot<T>;
type PageServerParentData = Omit<EnsureDefined<import('../../../../$types.js').LayoutServerData>, keyof import('../../../$types.js').LayoutServerData> & EnsureDefined<import('../../../$types.js').LayoutServerData>;
type PageParentData = Omit<EnsureDefined<import('../../../../$types.js').LayoutData>, keyof import('../../../$types.js').LayoutData> & EnsureDefined<import('../../../$types.js').LayoutData>;

export type EntryGenerator = () => Promise<Array<RouteParams>> | Array<RouteParams>;
export type PageServerLoad<OutputData extends OutputDataShape<PageServerParentData> = OutputDataShape<PageServerParentData>> = Kit.ServerLoad<RouteParams, PageServerParentData, OutputData, RouteId>;
export type PageServerLoadEvent = Parameters<PageServerLoad>[0];
type ExcludeActionFailure<T> = T extends Kit.ActionFailure<any> ? never : T extends void ? never : T;
type ActionsSuccess<T extends Record<string, (...args: any) => any>> = { [Key in keyof T]: ExcludeActionFailure<Awaited<ReturnType<T[Key]>>>; }[keyof T];
type ExtractActionFailure<T> = T extends Kit.ActionFailure<infer X>	? X extends void ? never : X : never;
type ActionsFailure<T extends Record<string, (...args: any) => any>> = { [Key in keyof T]: Exclude<ExtractActionFailure<Awaited<ReturnType<T[Key]>>>, void>; }[keyof T];
type ActionsExport = typeof import('./proxy+page.server.js').actions
export type SubmitFunction = Kit.SubmitFunction<Expand<ActionsSuccess<ActionsExport>>, Expand<ActionsFailure<ActionsExport>>>
export type ActionData = Expand<Kit.AwaitedActions<ActionsExport>> | null;
export type PageServerData = Expand<OptionalUnion<EnsureDefined<Kit.AwaitedProperties<Awaited<ReturnType<typeof import('./proxy+page.server.js').load>>>>>>;
export type PageData = Expand<Omit<PageParentData, keyof PageServerData> & EnsureDefined<PageServerData>>;
export type Action<OutputData extends Record<string, any> | void = Record<string, any> | void> = Kit.Action<RouteParams, OutputData, RouteId>
export type Actions<OutputData extends Record<string, any> | void = Record<string, any> | void> = Kit.Actions<RouteParams, OutputData, RouteId>
export type RequestEvent = Kit.RequestEvent<RouteParams, RouteId>;
# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/(authed)/edit/[category=category]/[postID]/proxy+page.server.js
# =============================================

// @ts-nocheck
import { Buffer } from 'buffer';
import { ghGet, ghPut } from '$lib/external/github.js';

/** @param {Parameters<import("./$types").PageServerLoad>[0]} event */
export async function load({ locals, params }) {
	return {
		post: await getFileContent(
			locals.user_token,
			`src/lib/posts/${params.category}/${params.postID}.md`
		)
	};
}

/** */
export const actions = {
	save:/** @param {import('./$types').RequestEvent} event */  async ({ params, cookies, request }) => {
		const token = cookies.get('userToken') ?? 'TOKEN NOT FOUND';
		const data = await request.formData();
		const fileContent = data.get('content');
		let userName = cookies.get('userName');
		if (userName == "null") userName = cookies.get('userLogin')
		// @ts-ignore
		saveFileContent(token, data.get('path') ?? '', fileContent, data.get('sha'), userName, params.category, params.postID);
		return { save: 'Guardado' };
	},
	load:/** @param {import('./$types').RequestEvent} event */  async ({ cookies, request }) => {
		const token = cookies.get('userToken') || 'TOKEN NOT FOUND';
		const data = await request.formData();
		const fileContent = await getFileContent(
			token,
			'src/lib/posts/' + data.get('category') + '/' + data.get('path') + '.md'
		);
		return { post: fileContent };
	}
};
/**
 *
 * @param {string} token
 * @param {string} path
 * @returns {Promise<*>}
 */
async function getFileContent(token, path) {
	let fileContent = await ghGet('repos/GorroRojo/kinkyvibe/contents/' + path, token);
	let raw = Buffer.from(fileContent.content, fileContent.encoding).toString();
	return { raw, ...fileContent };
}

/**
 * Saves the content of a file to a specified path in a GitHub repository.
 *
 * @param {string} token - The access token for the GitHub repository.
 * @param {string} path - The path to the file in the GitHub repository.
 * @param {string} content - The content to be saved in the file.
 * @param {string} sha - The file's original sha
 * @param {string} userName - The user's name
 * @param {string} category - The category of the post
 * @param {string} postID - The post ID
 * @return {Promise<*>} A promise that resolves with the response from the GitHub API.
 */
async function saveFileContent(token, path, content, sha, userName, category, postID) {
	return await ghPut('repos/GorroRojo/kinkyvibe/contents/' + path, token, content, sha, userName, category, postID);
}

# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/(content)/$types.d.ts
# =============================================

import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = {  };
type RouteId = '/(content)';
type MaybeWithVoid<T> = {} extends T ? T | void : T;
export type RequiredKeys<T> = { [K in keyof T]-?: {} extends { [P in K]: T[K] } ? never : K; }[keyof T];
type OutputDataShape<T> = MaybeWithVoid<Omit<App.PageData, RequiredKeys<T>> & Partial<Pick<App.PageData, keyof T & keyof App.PageData>> & Record<string, any>>
type EnsureDefined<T> = T extends null | undefined ? {} : T;
type OptionalUnion<U extends Record<string, any>, A extends keyof U = U extends U ? keyof U : never> = U extends unknown ? { [P in Exclude<A, keyof U>]?: never } & U : never;
export type Snapshot<T = any> = Kit.Snapshot<T>;
type PageParentData = Omit<EnsureDefined<import('../$types.js').LayoutData>, keyof LayoutData> & EnsureDefined<LayoutData>;
type LayoutRouteId = RouteId | "/(content)" | "/(content)/amigues" | "/(content)/amigues/[profile]" | "/(content)/calendario" | "/(content)/calendario/[event]" | "/(content)/material" | "/(content)/material/[post]" | "/(content)/todo" | "/(content)/wiki" | "/(content)/wiki/[term]"
type LayoutParams = RouteParams & { profile?: string; event?: string; post?: string; term?: string }
type LayoutParentData = EnsureDefined<import('../$types.js').LayoutData>;

export type PageServerData = null;
export type PageData = Expand<PageParentData>;
export type LayoutServerData = null;
export type LayoutData = Expand<LayoutParentData>;
# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/(content)/amigues/$types.d.ts
# =============================================

import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = {  };
type RouteId = '/(content)/amigues';
type MaybeWithVoid<T> = {} extends T ? T | void : T;
export type RequiredKeys<T> = { [K in keyof T]-?: {} extends { [P in K]: T[K] } ? never : K; }[keyof T];
type OutputDataShape<T> = MaybeWithVoid<Omit<App.PageData, RequiredKeys<T>> & Partial<Pick<App.PageData, keyof T & keyof App.PageData>> & Record<string, any>>
type EnsureDefined<T> = T extends null | undefined ? {} : T;
type OptionalUnion<U extends Record<string, any>, A extends keyof U = U extends U ? keyof U : never> = U extends unknown ? { [P in Exclude<A, keyof U>]?: never } & U : never;
export type Snapshot<T = any> = Kit.Snapshot<T>;
type PageParentData = Omit<EnsureDefined<import('../../$types.js').LayoutData>, keyof import('../$types.js').LayoutData> & EnsureDefined<import('../$types.js').LayoutData>;

export type PageServerData = null;
export type PageData = Expand<PageParentData>;
# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/(content)/amigues/[profile]/$types.d.ts
# =============================================

import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = { profile: string };
type RouteId = '/(content)/amigues/[profile]';
type MaybeWithVoid<T> = {} extends T ? T | void : T;
export type RequiredKeys<T> = { [K in keyof T]-?: {} extends { [P in K]: T[K] } ? never : K; }[keyof T];
type OutputDataShape<T> = MaybeWithVoid<Omit<App.PageData, RequiredKeys<T>> & Partial<Pick<App.PageData, keyof T & keyof App.PageData>> & Record<string, any>>
type EnsureDefined<T> = T extends null | undefined ? {} : T;
type OptionalUnion<U extends Record<string, any>, A extends keyof U = U extends U ? keyof U : never> = U extends unknown ? { [P in Exclude<A, keyof U>]?: never } & U : never;
export type Snapshot<T = any> = Kit.Snapshot<T>;
type PageParentData = Omit<EnsureDefined<import('../../../$types.js').LayoutData>, keyof import('../../$types.js').LayoutData> & EnsureDefined<import('../../$types.js').LayoutData>;

export type EntryGenerator = () => Promise<Array<RouteParams>> | Array<RouteParams>;
export type PageServerData = null;
export type PageLoad<OutputData extends OutputDataShape<PageParentData> = OutputDataShape<PageParentData>> = Kit.Load<RouteParams, PageServerData, PageParentData, OutputData, RouteId>;
export type PageLoadEvent = Parameters<PageLoad>[0];
export type PageData = Expand<Omit<PageParentData, keyof Kit.AwaitedProperties<Awaited<ReturnType<typeof import('./proxy+page.js').load>>>> & OptionalUnion<EnsureDefined<Kit.AwaitedProperties<Awaited<ReturnType<typeof import('./proxy+page.js').load>>>>>>;
# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/(content)/amigues/[profile]/proxy+page.js
# =============================================

// @ts-nocheck
import { fetchPost } from '$lib/utils';

/** @param {Parameters<import("./$types").PageLoad>[0]} event */
export async function load({ params }) {
	return await fetchPost('amigues', params.profile);
}

# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/(content)/calendario.ics/$types.d.ts
# =============================================

import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = {  };
type RouteId = '/(content)/calendario.ics';

export type RequestHandler = Kit.RequestHandler<RouteParams, RouteId>;
export type RequestEvent = Kit.RequestEvent<RouteParams, RouteId>;
# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/(content)/calendario/$types.d.ts
# =============================================

import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = {  };
type RouteId = '/(content)/calendario';
type MaybeWithVoid<T> = {} extends T ? T | void : T;
export type RequiredKeys<T> = { [K in keyof T]-?: {} extends { [P in K]: T[K] } ? never : K; }[keyof T];
type OutputDataShape<T> = MaybeWithVoid<Omit<App.PageData, RequiredKeys<T>> & Partial<Pick<App.PageData, keyof T & keyof App.PageData>> & Record<string, any>>
type EnsureDefined<T> = T extends null | undefined ? {} : T;
type OptionalUnion<U extends Record<string, any>, A extends keyof U = U extends U ? keyof U : never> = U extends unknown ? { [P in Exclude<A, keyof U>]?: never } & U : never;
export type Snapshot<T = any> = Kit.Snapshot<T>;
type PageParentData = Omit<EnsureDefined<import('../../$types.js').LayoutData>, keyof import('../$types.js').LayoutData> & EnsureDefined<import('../$types.js').LayoutData>;

export type PageServerData = null;
export type PageData = Expand<PageParentData>;
# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/(content)/calendario/[event]/$types.d.ts
# =============================================

import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = { event: string };
type RouteId = '/(content)/calendario/[event]';
type MaybeWithVoid<T> = {} extends T ? T | void : T;
export type RequiredKeys<T> = { [K in keyof T]-?: {} extends { [P in K]: T[K] } ? never : K; }[keyof T];
type OutputDataShape<T> = MaybeWithVoid<Omit<App.PageData, RequiredKeys<T>> & Partial<Pick<App.PageData, keyof T & keyof App.PageData>> & Record<string, any>>
type EnsureDefined<T> = T extends null | undefined ? {} : T;
type OptionalUnion<U extends Record<string, any>, A extends keyof U = U extends U ? keyof U : never> = U extends unknown ? { [P in Exclude<A, keyof U>]?: never } & U : never;
export type Snapshot<T = any> = Kit.Snapshot<T>;
type PageParentData = Omit<EnsureDefined<import('../../../$types.js').LayoutData>, keyof import('../../$types.js').LayoutData> & EnsureDefined<import('../../$types.js').LayoutData>;

export type EntryGenerator = () => Promise<Array<RouteParams>> | Array<RouteParams>;
export type PageServerData = null;
export type PageLoad<OutputData extends OutputDataShape<PageParentData> = OutputDataShape<PageParentData>> = Kit.Load<RouteParams, PageServerData, PageParentData, OutputData, RouteId>;
export type PageLoadEvent = Parameters<PageLoad>[0];
export type PageData = Expand<Omit<PageParentData, keyof Kit.AwaitedProperties<Awaited<ReturnType<typeof import('./proxy+page.js').load>>>> & OptionalUnion<EnsureDefined<Kit.AwaitedProperties<Awaited<ReturnType<typeof import('./proxy+page.js').load>>>>>>;
# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/(content)/calendario/[event]/proxy+page.js
# =============================================

// @ts-nocheck
import { fetchPost } from '$lib/utils';

/** @param {Parameters<import("./$types").PageLoad>[0]} event */
export async function load({ params }) {
	return await fetchPost('calendario', params.event);
}

# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/(content)/material/$types.d.ts
# =============================================

import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = {  };
type RouteId = '/(content)/material';
type MaybeWithVoid<T> = {} extends T ? T | void : T;
export type RequiredKeys<T> = { [K in keyof T]-?: {} extends { [P in K]: T[K] } ? never : K; }[keyof T];
type OutputDataShape<T> = MaybeWithVoid<Omit<App.PageData, RequiredKeys<T>> & Partial<Pick<App.PageData, keyof T & keyof App.PageData>> & Record<string, any>>
type EnsureDefined<T> = T extends null | undefined ? {} : T;
type OptionalUnion<U extends Record<string, any>, A extends keyof U = U extends U ? keyof U : never> = U extends unknown ? { [P in Exclude<A, keyof U>]?: never } & U : never;
export type Snapshot<T = any> = Kit.Snapshot<T>;
type PageParentData = Omit<EnsureDefined<import('../../$types.js').LayoutData>, keyof import('../$types.js').LayoutData> & EnsureDefined<import('../$types.js').LayoutData>;

export type PageServerData = null;
export type PageData = Expand<PageParentData>;
# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/(content)/material/[post]/$types.d.ts
# =============================================

import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = { post: string };
type RouteId = '/(content)/material/[post]';
type MaybeWithVoid<T> = {} extends T ? T | void : T;
export type RequiredKeys<T> = { [K in keyof T]-?: {} extends { [P in K]: T[K] } ? never : K; }[keyof T];
type OutputDataShape<T> = MaybeWithVoid<Omit<App.PageData, RequiredKeys<T>> & Partial<Pick<App.PageData, keyof T & keyof App.PageData>> & Record<string, any>>
type EnsureDefined<T> = T extends null | undefined ? {} : T;
type OptionalUnion<U extends Record<string, any>, A extends keyof U = U extends U ? keyof U : never> = U extends unknown ? { [P in Exclude<A, keyof U>]?: never } & U : never;
export type Snapshot<T = any> = Kit.Snapshot<T>;
type PageParentData = Omit<EnsureDefined<import('../../../$types.js').LayoutData>, keyof import('../../$types.js').LayoutData> & EnsureDefined<import('../../$types.js').LayoutData>;

export type EntryGenerator = () => Promise<Array<RouteParams>> | Array<RouteParams>;
export type PageServerData = null;
export type PageLoad<OutputData extends OutputDataShape<PageParentData> = OutputDataShape<PageParentData>> = Kit.Load<RouteParams, PageServerData, PageParentData, OutputData, RouteId>;
export type PageLoadEvent = Parameters<PageLoad>[0];
export type PageData = Expand<Omit<PageParentData, keyof Kit.AwaitedProperties<Awaited<ReturnType<typeof import('./proxy+page.js').load>>>> & OptionalUnion<EnsureDefined<Kit.AwaitedProperties<Awaited<ReturnType<typeof import('./proxy+page.js').load>>>>>>;
# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/(content)/material/[post]/proxy+page.js
# =============================================

// @ts-nocheck
import { fetchPost } from '$lib/utils';
import { redirect } from '@sveltejs/kit';

/** @param {Parameters<import("./$types").PageLoad>[0]} event */
export async function load({ params }) {
	let post = await fetchPost('material', params.post);
	if (post.meta?.redirect) {
		throw redirect(307, post.meta.link);
	}
	return post;
}

# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/(content)/sitemap.xml/$types.d.ts
# =============================================

import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = {  };
type RouteId = '/(content)/sitemap.xml';

export type RequestHandler = Kit.RequestHandler<RouteParams, RouteId>;
export type RequestEvent = Kit.RequestEvent<RouteParams, RouteId>;
# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/(content)/todo/$types.d.ts
# =============================================

import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = {  };
type RouteId = '/(content)/todo';
type MaybeWithVoid<T> = {} extends T ? T | void : T;
export type RequiredKeys<T> = { [K in keyof T]-?: {} extends { [P in K]: T[K] } ? never : K; }[keyof T];
type OutputDataShape<T> = MaybeWithVoid<Omit<App.PageData, RequiredKeys<T>> & Partial<Pick<App.PageData, keyof T & keyof App.PageData>> & Record<string, any>>
type EnsureDefined<T> = T extends null | undefined ? {} : T;
type OptionalUnion<U extends Record<string, any>, A extends keyof U = U extends U ? keyof U : never> = U extends unknown ? { [P in Exclude<A, keyof U>]?: never } & U : never;
export type Snapshot<T = any> = Kit.Snapshot<T>;
type PageParentData = Omit<EnsureDefined<import('../../$types.js').LayoutData>, keyof import('../$types.js').LayoutData> & EnsureDefined<import('../$types.js').LayoutData>;

export type PageServerData = null;
export type PageData = Expand<PageParentData>;
# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/(content)/wiki/$types.d.ts
# =============================================

import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = {  };
type RouteId = '/(content)/wiki';
type MaybeWithVoid<T> = {} extends T ? T | void : T;
export type RequiredKeys<T> = { [K in keyof T]-?: {} extends { [P in K]: T[K] } ? never : K; }[keyof T];
type OutputDataShape<T> = MaybeWithVoid<Omit<App.PageData, RequiredKeys<T>> & Partial<Pick<App.PageData, keyof T & keyof App.PageData>> & Record<string, any>>
type EnsureDefined<T> = T extends null | undefined ? {} : T;
type OptionalUnion<U extends Record<string, any>, A extends keyof U = U extends U ? keyof U : never> = U extends unknown ? { [P in Exclude<A, keyof U>]?: never } & U : never;
export type Snapshot<T = any> = Kit.Snapshot<T>;
type PageParentData = Omit<EnsureDefined<import('../../$types.js').LayoutData>, keyof import('../$types.js').LayoutData> & EnsureDefined<import('../$types.js').LayoutData>;

export type PageServerData = null;
export type PageData = Expand<PageParentData>;
# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/(content)/wiki/[term]/$types.d.ts
# =============================================

import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = { term: string };
type RouteId = '/(content)/wiki/[term]';
type MaybeWithVoid<T> = {} extends T ? T | void : T;
export type RequiredKeys<T> = { [K in keyof T]-?: {} extends { [P in K]: T[K] } ? never : K; }[keyof T];
type OutputDataShape<T> = MaybeWithVoid<Omit<App.PageData, RequiredKeys<T>> & Partial<Pick<App.PageData, keyof T & keyof App.PageData>> & Record<string, any>>
type EnsureDefined<T> = T extends null | undefined ? {} : T;
type OptionalUnion<U extends Record<string, any>, A extends keyof U = U extends U ? keyof U : never> = U extends unknown ? { [P in Exclude<A, keyof U>]?: never } & U : never;
export type Snapshot<T = any> = Kit.Snapshot<T>;
type PageParentData = Omit<EnsureDefined<import('../../../$types.js').LayoutData>, keyof import('../../$types.js').LayoutData> & EnsureDefined<import('../../$types.js').LayoutData>;

export type EntryGenerator = () => Promise<Array<RouteParams>> | Array<RouteParams>;
export type PageServerData = null;
export type PageLoad<OutputData extends OutputDataShape<PageParentData> = OutputDataShape<PageParentData>> = Kit.Load<RouteParams, PageServerData, PageParentData, OutputData, RouteId>;
export type PageLoadEvent = Parameters<PageLoad>[0];
export type PageData = Expand<Omit<PageParentData, keyof Kit.AwaitedProperties<Awaited<ReturnType<typeof import('./proxy+page.js').load>>>> & OptionalUnion<EnsureDefined<Kit.AwaitedProperties<Awaited<ReturnType<typeof import('./proxy+page.js').load>>>>>>;
# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/(content)/wiki/[term]/proxy+page.js
# =============================================

// @ts-nocheck
import { fetchPost } from '$lib/utils/index.js';
import tagsFactory from '$lib/utils/tags';
export const prerender = 'auto';
/** @param {Parameters<import("./$types").PageLoad>[0]} event */
export async function load({ params }) {
	let post;
	let tagManager = tagsFactory();
	try {
		post = await fetchPost('wiki', params.term);
	} catch (e) {
		post = { tag: tagManager.get(params.term) };
	}
	return {
		...post
	};
}

# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/.well-known/[param]/$types.d.ts
# =============================================

import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = { param: string };
type RouteId = '/.well-known/[param]';

export type EntryGenerator = () => Promise<Array<RouteParams>> | Array<RouteParams>;
export type RequestHandler = Kit.RequestHandler<RouteParams, RouteId>;
export type RequestEvent = Kit.RequestEvent<RouteParams, RouteId>;
# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/api/$types.d.ts
# =============================================

import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = {  };
type RouteId = '/api';

export type RequestHandler = Kit.RequestHandler<RouteParams, RouteId>;
export type RequestEvent = Kit.RequestEvent<RouteParams, RouteId>;
# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/api/posts/$types.d.ts
# =============================================

import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = {  };
type RouteId = '/api/posts';

export type RequestHandler = Kit.RequestHandler<RouteParams, RouteId>;
export type RequestEvent = Kit.RequestEvent<RouteParams, RouteId>;
# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/api/wiki/$types.d.ts
# =============================================

import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = {  };
type RouteId = '/api/wiki';

export type RequestHandler = Kit.RequestHandler<RouteParams, RouteId>;
export type RequestEvent = Kit.RequestEvent<RouteParams, RouteId>;
# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/auch/$types.d.ts
# =============================================

import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = {  };
type RouteId = '/auch';
type MaybeWithVoid<T> = {} extends T ? T | void : T;
export type RequiredKeys<T> = { [K in keyof T]-?: {} extends { [P in K]: T[K] } ? never : K; }[keyof T];
type OutputDataShape<T> = MaybeWithVoid<Omit<App.PageData, RequiredKeys<T>> & Partial<Pick<App.PageData, keyof T & keyof App.PageData>> & Record<string, any>>
type EnsureDefined<T> = T extends null | undefined ? {} : T;
type OptionalUnion<U extends Record<string, any>, A extends keyof U = U extends U ? keyof U : never> = U extends unknown ? { [P in Exclude<A, keyof U>]?: never } & U : never;
export type Snapshot<T = any> = Kit.Snapshot<T>;
type PageServerParentData = EnsureDefined<import('../$types.js').LayoutServerData>;
type PageParentData = EnsureDefined<import('../$types.js').LayoutData>;

export type PageServerLoad<OutputData extends OutputDataShape<PageServerParentData> = OutputDataShape<PageServerParentData>> = Kit.ServerLoad<RouteParams, PageServerParentData, OutputData, RouteId>;
export type PageServerLoadEvent = Parameters<PageServerLoad>[0];
export type ActionData = unknown;
export type PageServerData = Expand<OptionalUnion<EnsureDefined<Kit.AwaitedProperties<Awaited<ReturnType<typeof import('../../../../../src/routes/auch/+page.server.js').load>>>>>>;
export type PageData = Expand<Omit<PageParentData, keyof PageServerData> & EnsureDefined<PageServerData>>;
export type Action<OutputData extends Record<string, any> | void = Record<string, any> | void> = Kit.Action<RouteParams, OutputData, RouteId>
export type Actions<OutputData extends Record<string, any> | void = Record<string, any> | void> = Kit.Actions<RouteParams, OutputData, RouteId>
export type RequestEvent = Kit.RequestEvent<RouteParams, RouteId>;
# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/callback/$types.d.ts
# =============================================

import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = {  };
type RouteId = '/callback';

export type RequestHandler = Kit.RequestHandler<RouteParams, RouteId>;
export type RequestEvent = Kit.RequestEvent<RouteParams, RouteId>;
# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/login/$types.d.ts
# =============================================

import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = {  };
type RouteId = '/login';
type MaybeWithVoid<T> = {} extends T ? T | void : T;
export type RequiredKeys<T> = { [K in keyof T]-?: {} extends { [P in K]: T[K] } ? never : K; }[keyof T];
type OutputDataShape<T> = MaybeWithVoid<Omit<App.PageData, RequiredKeys<T>> & Partial<Pick<App.PageData, keyof T & keyof App.PageData>> & Record<string, any>>
type EnsureDefined<T> = T extends null | undefined ? {} : T;
type OptionalUnion<U extends Record<string, any>, A extends keyof U = U extends U ? keyof U : never> = U extends unknown ? { [P in Exclude<A, keyof U>]?: never } & U : never;
export type Snapshot<T = any> = Kit.Snapshot<T>;
type PageServerParentData = EnsureDefined<import('../$types.js').LayoutServerData>;
type PageParentData = EnsureDefined<import('../$types.js').LayoutData>;

export type PageServerLoad<OutputData extends OutputDataShape<PageServerParentData> = OutputDataShape<PageServerParentData>> = Kit.ServerLoad<RouteParams, PageServerParentData, OutputData, RouteId>;
export type PageServerLoadEvent = Parameters<PageServerLoad>[0];
type ExcludeActionFailure<T> = T extends Kit.ActionFailure<any> ? never : T extends void ? never : T;
type ActionsSuccess<T extends Record<string, (...args: any) => any>> = { [Key in keyof T]: ExcludeActionFailure<Awaited<ReturnType<T[Key]>>>; }[keyof T];
type ExtractActionFailure<T> = T extends Kit.ActionFailure<infer X>	? X extends void ? never : X : never;
type ActionsFailure<T extends Record<string, (...args: any) => any>> = { [Key in keyof T]: Exclude<ExtractActionFailure<Awaited<ReturnType<T[Key]>>>, void>; }[keyof T];
type ActionsExport = typeof import('./proxy+page.server.js').actions
export type SubmitFunction = Kit.SubmitFunction<Expand<ActionsSuccess<ActionsExport>>, Expand<ActionsFailure<ActionsExport>>>
export type ActionData = Expand<Kit.AwaitedActions<ActionsExport>> | null;
export type PageServerData = null;
export type PageData = Expand<PageParentData>;
export type Action<OutputData extends Record<string, any> | void = Record<string, any> | void> = Kit.Action<RouteParams, OutputData, RouteId>
export type Actions<OutputData extends Record<string, any> | void = Record<string, any> | void> = Kit.Actions<RouteParams, OutputData, RouteId>
export type RequestEvent = Kit.RequestEvent<RouteParams, RouteId>;
# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/login/proxy+page.server.js
# =============================================

// @ts-nocheck
import { env } from '$env/dynamic/private';
import { redirect } from '@sveltejs/kit';
const target = 'https://github.com/login/oauth/authorize';
const clientId = env.GITHUB_CLIENT_ID;
/** */
export const actions = {
	default:/** @param {import('./$types').RequestEvent} event */  async ({request}) => {
		const sessionId = '1234';
		const data = await request.formData()
		const redirectTo = data.get('redirectTo') ?? '/';
		throw redirect(
			302,
			`${target}?client_id=${clientId}&state=${sessionId}&scope=repo&redirectTo=${redirectTo}`
		);
		// 	throw redirect(303, url.searchParams.get('redirectTo') ?? '/');
	}
};

# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/logout/$types.d.ts
# =============================================

import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = {  };
type RouteId = '/logout';

export type RequestHandler = Kit.RequestHandler<RouteParams, RouteId>;
export type RequestEvent = Kit.RequestEvent<RouteParams, RouteId>;
# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/proxy+layout.server.js
# =============================================

// @ts-nocheck
import { fetchMarkdownPosts } from '$lib/utils';
/** @param {Parameters<import("./$types").LayoutServerLoad>[0]} event */
export const load = async ({ url, locals }) => {
	let allPosts = await fetchMarkdownPosts();
	let wiki = await fetchMarkdownPosts(true);
	// let allPosts = await (await fetch('/api/posts')).json()
	// let wiki = await (await fetch('/api/wiki')).json();
	return {
		currentRoute: url.pathname,
		allPosts,
		wiki,
		user: locals.user
	};
};

# =============================================
# ARCHIVO: ./.svelte-kit/types/src/routes/rss/$types.d.ts
# =============================================

import type * as Kit from '@sveltejs/kit';

type Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;
// @ts-ignore
type MatcherParam<M> = M extends (param : string) => param is infer U ? U extends string ? U : string : string;
type RouteParams = {  };
type RouteId = '/rss';

export type RequestHandler = Kit.RequestHandler<RouteParams, RouteId>;
export type RequestEvent = Kit.RequestEvent<RouteParams, RouteId>;
# =============================================
# ARCHIVO: ./LICENSE
# =============================================

MIT License

Copyright (c) 2023 Gorro_Rojo

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

# =============================================
# ARCHIVO: ./README.md
# =============================================

> Ahora mismo este readme sirve como guía para editar la página para quienes tienen permiso de commit, no pretende ser un README.md tradicional.

## Páginas

El contenido de las páginas está en los siguientes archivos

| URL           | Archivo                                                                                              |
| ------------- | ---------------------------------------------------------------------------------------------------- |
| `/`           | [`/src/routes/+page.svelte`](/src/routes/+page.svelte)                                               |
| `/nosotres`   | [`/src/routes/(content)/nosotres/+page.svelte`](<`/src/routes/(content)/nosotres/+page.svelte`>)     |
| `/material`   | [`/src/routes/(content)/material/+page.svelte`](<`/src/routes/(content)/material/+page.svelte`>)     |
| `/amigues`    | [`/src/routes/(content)/amigues/+page.svelte`](<`/src/routes/(content)/amigues/+page.svelte`>)       |
| `/calendario` | [`/src/routes/(content)/calendario/+page.svelte`](<`/src/routes/(content)/calendario/+page.svelte`>) |
| `/servicios`  | [`/src/routes/(content)/servicios/+page.svelte`](<`/src/routes/(content)/servicios/+page.svelte`>)   |

En los archivos `.md` está en Markdown, mezclado con Svelte _(que se ve como HTML)_ . En los `.svelte` es Svelte simplemente.

## Publicaciones

Después, las publicaciones (eventos, articulos, links, etc...) están en [/src/lib/posts](/src/lib/posts). Cada publicación consiste de un archivo `url-de-publicacion.md` que comienza con un bloque de propiedades delimitado por tres guiones `---` y luego tiene el contenido en sí de la publicación que va a estar visible.

Si la publicación tiene imágenes u otros archivos, estos están _(usando el ejemplo)_ en `/src/lib/posts/media/url-de-publicación/1.png`. Cada archivo debe tener como título un número comenzando por cero y nada más, sólo seguido por el formato del archivo. El nombre de la carpeta debe ser exactamente igual al nombre del archivo de la publicación. Tal que en este ejemplo, la publicación sería `/src/lib/posts/url-de-publicación.md`.

## Contenido

El contenido puede ser estilizado:

| formato                             | resultado                 |
| ----------------------------------- | ------------------------- |
| `*kinkyvibe*`                       | _kinkyvibe_               |
| `**kinkyvibe**`                     | **kinkyvibe**             |
| `***kinkyvibe***`                   | **_kinkyvibe_**           |
| \`kinkyvibe\`                       | `kinkyvibe`               |
| `[kinkyvibe](https://kinkyvibe.ar)` | [kinkyvibe](kinkyvibe.ar) |
| `~~kinkyvibe~~`                     | ~~kinkyvibe~~             |
| `kinky<sub>vibe</sub>`              | kinky<sub>vibe</sub>      |
| `kinky<sup>vibe</sup>`              | kinky<sup>vibe</sup>      |

Comenzando una linea con un `> ` se hace un bloque de cita

> Que se ve algo masomenos así. Wow.

Y las imágenes son iguales que los links pero con un `!` al principio: `![texto alternativo](https://imgur.com/mi-imagen.png)`. Sin embargo, para imagenes y otros archivos que carguemos nosotres mismes es ligeramente distinto. Ver [#imágenes](#imágenes).

Después, poniendo `#` al principio de una linea se pone como encabezado. Agregando más `#` se hace cada vez "mas chico" el título. Por ejemplo aquí viene un `## Propiedades`

## Propiedades

```md
---
propiedad: valor
lista:
  - un elemento de la lista
  - otro elemento
---

( Contenido visible de la página )
```

Las propiedades que indiquen un momento en el tiempo se hacen con el siguiente formato (año)`-`(mes)`-`(día)`T`(hora)`:`(minuto)`-03:00`

## Imágenes

Las imágenes y otros archivos deben cargarse en la subcarpeta `/media/` y luego en otra subcarpeta que tenga el nombre de la publicación, o sea el mismo nombre que el `.md` pero sin la extensión.

Luego, dentro de esa carpeta, se meten cuantos archivos se quiera, cada uno con un número como nombre, y nada más (sin contar la terminación de formato tipo `.png`).

De modo que quedaría:

- posts/
  - como-hacer-un-pete.md
  - media/
    - como-hacer-un-pete/
      - 1.png
      - 2.png
      - 3.jpeg
      - 4.pdf

Y así, luego en el cuerpo del documento se hace referencia a estos archivos por su número, así como en la propiedad `featured`.

Después dentro del contenido de la página, para insertar las imágenes, debemos hacer un par de cosas.

1. Entre el bloque de propiedades y el contenido, metemos un bloque de `script`

```svelte
<script>
	/* acá vamos a importar las imágenes */
</script>
```

2. Dentro del bloque _(donde acá arriba está el comentario)_, por cada archivo que hayamos subido que querramos usar, teniendo a mano el nombre del archivo _(por ejemplo, `1.png`)_ y un pseudónimo que le querramos dar _(por ejemplo, `pag1`)_, metemos la siguiente linea.

```svelte
import pag1 from '$lib/posts/media/como-hacer-un-pete/1.png'
```

De esta forma, después podremos hacer referencia a pag1 a la hora de meter una imagen, parecido a como metemos las imagenes externas _(`![alt](url)`)_ pero con unas llaves de más y con el pseudónimo que le pusimos a la imagen _(`![alt]({pseudonimo})`)_.

Siguiendo el ejemplo, puedo poner varias imágenes si las cargo y escribo esto.

```svelte
<script>
	import pag1 from '$lib/posts/media/como-hacer-un-pete/1.png';
	import pag2 from '$lib/posts/media/como-hacer-un-pete/2.png';
</script>

Bienvenides a la peteguía. Aquí está la guía en imágenes. ![diagrama de las partes de genitales]({pag1})
![diagrama de las partes de otros genitales]({pag2})
```

## Poner cosas en columnas

Rodeando dos bloques (por ejemplo, imágenes) con un divisor de clase `col-2` podemos ponerlos en dos columnas iguales

```html
<div class="col-2">
	<img src="{pag1}" />
	<img src="{pag2}" />
</div>
```

`col-3` es para 3, y `col-4` es para 4

si se quiere unir varias cosas como un solo bloque, simplemente se las rodea con un `<div>...</div>` sin ninguna clase

## Etiquetas

una pequeño contenido por etiqueta? tipo BDSM lleva a todos los posts que dicen bdsm + una pequeña explicación, o un post principal por etiqueta

hace falta un archivo:

- [x] titulando y estableciendo grupos de etiquetas
- [x] fusionando etiquetas como alias de una sola
- [x] marcando etiquetas que no deben estar visibles
- [ ] estableciendo un post como post principal para cada etiqueta?
- [ ] estableciendo iconos por etiqueta? superduper opcional
- [x] color de etiquetas?

Los colores, alias, y grupos están en [\_tags.md](/src/lib/posts/_tags.md?plain=1), las descripciones en [\_glossary.md](/src/lib/posts/_glossary.md?plain=1) y los posts para cada tag en [`/src/lib/wiki/`](/src/lib/wiki/)

## Propiedades de los posts

- - title\*
  - description\*
  - tags\*
  - category\*
  - featured (imagen para mostrar en tarjetas, vistas previas del link, etc; si no hay, generar uno de alguna forma?)
  - published_date
  - updated_date
  - author (quién escribió artículo, quién organiza un evento, quién es miembro de un proyecto)
  - type (por ahora sólo material: descargable, link, contenido)
  - force_unlisted
  - force_unpublished
- Material
  - link (\* para descargable y link, en contenido lleva al contenido original es es una trad, adapta, repost, etc)
  - cuando es de tipo "link"
    - access_date\* (la última que vez que se chequeó el link)
    - original_published_date
- Calendario
  - etiquetas particulares de eventos:
    - feria, charla, debate?, picnic?, social?, juegos?, taller
  - status\* (abierto | anunciado | agotadas| terminado?pasado? no, se hace solo con la fecha eso.)
  - start\*
  - end / duration \*
  - location (si no hay, es online)
  - link
- Amigues
  - tags particulares de amigues:
    - emprendimiento, proyecto, profesional de la salud
  - pronoun\* (https://pronombr.es)
  - link\*
  - logo || photo (si no, se usa featured)
  - email
  - location (si hay, es venue)
  - tel
  - job_title
  - job_role (explicando brevemente job_title)
  - gender_identity
  - bday
  - affiliation h-card
  - ?education h-event,h-card
  - ?experience h-event,h-card
  - ?skill

más info y ejemplos completos copiables para cada categoría en [\_template.md](/src/lib/posts/_template.md)

### layouts [wip]

- blank (contenido)
- [ ] standard [default material contenido]
  - [x] título
  - [x] summary
  - [ ] featured
  - [x] contenido
  - [x] og link
  - [x] og access date
  - [x] og publish
  - [x] publish date
  - [x] authors
  - [x] tags
- [ ] [default material link/descargable]
- [x] [default calendario] (poster, titulo, summary, fecha, hora, lugar, CTA)
  - [x] poster
  - [x] título
  - [x] summary
  - [x] fecha
  - [x] hora
  - [x] lugar
  - [x] CTA
  - [x] add to calendar
- [default amigues] (foto, titulo, jobtitle, summary, link (+ map))
  - [x] foto
  - [ ] título
  - [ ] jobtitle
  - [x] summary
  - [x] link
  - [ ] map
  - [ ] pronouns
  - [ ] mail
  - [ ] phone
  - [ ] bday

### pendientes: indieweb & standards

#### rel

- [x] author
- [ ] enclosure (para descargables)
- [ ] rel=license
- [ ] rel=nofollow para desincentivar a buscadores seguir ese link
- [x] rel=tag
- [x] rel=home

#### emoji post type (de baja esto?)

estandar de emoji por tipo de post

- material
  - descargable
    - 📑 collection (of posts...medio al pedo, un link a un tag y listo)
    - 🎴 comics
  - contenido
    - 📄 article
    - 🎥 video
    - 📷 photo
    - 🎤 audio
    - ⭐️ review
    - 📔 note
  - link
    - 🔖 bookmark
    - ♺ repost
- calendario
  - 📅 event
  - ♫ jam
  - 📽️ presentation
  - 🎙 performance
- amigues
  - 📍 venue

#### microformats2

- material
  - h-entry
    - h-cite
    - u-bookmark-of
    - u-repost-of
- calendario
  - h-event
- amigues
  - h-card
  - h-resume

##### h-feed

- p-name
- p-author (h-card)
- u-url
- u-photo
- ?p-summary
- [x] multiple nested h-entry

##### h-adr

- p-street-address
- p-extended-address
- p-location
- p-region
- p-postal-code
- p-country-name
- no tiene p-name, "it's likely a vanue, you should use h-card instead"

##### h-entry

- [x] p-name
- [x] p-summary
- e-content
- [x] dt-published
- dt-updated
- [x] p-author (o h-card)
- p-category??
- [x] u-url
- u-uid??
- p-location (o h-card, h-adr, h-geo)
- u-syndication??
- u-in-reply-to (o h-cite)
- p-rsvp: yes | no | maybe | interested
- u-like-of (o h-cite)
- u-repost-of (o h-cite)
  proposed
- u-repost??
- u-bookmark-of (o h-cite)
- u-featured (imagen principal)

##### h-event

- [x] p-name
- p-summary
- [x] dt-start
- [x] dt-end
- dt-duration
- p-description (o e-content)
- [x] u-url
- ~~category~~
- [x] (MASOMENOS) p-location (puede ser h-card, h-adr, h-geo)
- p-organizer (puede ser h-card)
  foto del lugar y punto en mapa

##### h-cite

- dt-accessed
- [x] u-url = u-uid
- p-publication
- p-name
- [x] dt-published
- p-author (o h-card)
- p-content

##### h-resume

- [x] p-name
- [x] p-summary (qualifications and objectives)
- [x] p-contact h-card
- p-education h-event, p-education h-card (education time, school)
- p-experience h-event, p-experience h-card
- p-skill
- p-affiliation h-card

##### h-card

- [x] p-name
- p-honorific-prefix
- p-sort-string
- p-honorifix-suffic
- p-nickname
- u-email
- u-logo
- [x] u-photo
- [x] u-url u-uid
- p-adr (o h-adr)
- p-geo / u-geo (o h-geo)
- p-tel
- p-note?
- p-org (o h-card)
- p-job-title
- p-role (descripcion del job-title)
- p-gender-identity
- u-pronoun (see http://pronoun.is)
- p-category?

- dt-anniversary
- dt-bday

# =============================================
# ARCHIVO: ./jsconfig.json
# =============================================

{
	"extends": "./.svelte-kit/tsconfig.json",
	"compilerOptions": {
		"allowJs": true,
		"checkJs": true,
		"esModuleInterop": true,
		"forceConsistentCasingInFileNames": true,
		"resolveJsonModule": true,
		"skipLibCheck": true,
		"sourceMap": true,
		"strict": true
	}
	// Path aliases are handled by https://kit.svelte.dev/docs/configuration#alias and https://kit.svelte.dev/docs/configuration#files
	//
	// If you want to overwrite includes/excludes, make sure to copy over the relevant includes/excludes
	// from the referenced tsconfig.json - TypeScript does not merge them in
}

# =============================================
# ARCHIVO: ./merge-repo.sh
# =============================================

#!/bin/bash

# Script para fusionar archivos relevantes de un repositorio en un solo archivo de texto
# Excluye archivos y carpetas típicamente no relevantes para revisión de código

# Configuración de salida
OUTPUT_FILE="repo_merged.txt"
REPO_PATH="."  # Ruta del repositorio (directorio actual por defecto)

# Arrays de patrones para ignorar
IGNORED_FILES=(
    "package-lock.json"
    "yarn.lock"
    "pnpm-lock.yaml"
    "*.log"
    "*.map"
    "*.min.js"
    "*.min.css"
    "*.gz"
    "*.zip"
    "*.tar"
    "*.tgz"
    "*.png"
    "*.jpg"
    "*.jpeg"
    "*.gif"
    "*.svg"
    "*.ico"
    "*.woff"
    "*.woff2"
    "*.ttf"
    "*.eot"
    "*.pdf"
    "*.DS_Store"
)

IGNORED_DIRS=(
    "node_modules"
    "dist"
    "build"
    "coverage"
    ".git"
    ".github"
    ".vscode"
    ".idea"
    ".cache"
    ".husky"
    ".next"
    ".nuxt"
    ".storybook"
    "vendor"
    "__pycache__"
    "venv"
    ".venv"
    "env"
    ".env"
    "tmp"
    "temp"
    "./src/lib/posts"
)

# Función para determinar si un archivo debe incluirse
should_include_file() {
    local file="$1"
    
    # Excluir directorios ignorados
    for dir in "${IGNORED_DIRS[@]}"; do
        if [[ "$file" == *"/$dir/"* || "$file" == "$dir/"* ]]; then
            return 1
        fi
    done
    
    # Excluir archivos que comienzan con punto (ocultos)
    if [[ "$(basename "$file")" == .* ]]; then
        return 1
    fi
    
    # Excluir archivos ignorados
    for pattern in "${IGNORED_FILES[@]}"; do
        if [[ "$(basename "$file")" == $pattern ]]; then
            return 1
        fi
    done
    
    # Verificar que el archivo sea un archivo de texto
    if file "$file" | grep -q "text"; then
        return 0
    else
        return 1
    fi
}

# Crear o limpiar el archivo de salida
echo "# Repositorio fusionado" > "$OUTPUT_FILE"
echo "# Generado el $(date)" >> "$OUTPUT_FILE"
echo "# Archivos incluidos:" >> "$OUTPUT_FILE"

# Variable para contar archivos
TOTAL_FILES=0
INCLUDED_FILES=0

# Encontrar todos los archivos en el repositorio
while IFS= read -r file; do
    TOTAL_FILES=$((TOTAL_FILES + 1))
    
    if should_include_file "$file"; then
        INCLUDED_FILES=$((INCLUDED_FILES + 1))
        
        # Añadir separador y nombre del archivo
        echo "" >> "$OUTPUT_FILE"
        echo "# =============================================" >> "$OUTPUT_FILE"
        echo "# ARCHIVO: $file" >> "$OUTPUT_FILE"
        echo "# =============================================" >> "$OUTPUT_FILE"
        echo "" >> "$OUTPUT_FILE"
        
        # Agregar contenido del archivo
        cat "$file" >> "$OUTPUT_FILE"
        
        # Registrar el archivo incluido
        echo "- $file" >> "$OUTPUT_FILE.index"
    fi
done < <(find "$REPO_PATH" -type f | sort)

# Mover la lista de archivos incluidos al principio del archivo
if [ -f "$OUTPUT_FILE.index" ]; then
    cat "$OUTPUT_FILE.index" >> "$OUTPUT_FILE.temp"
    echo "" >> "$OUTPUT_FILE.temp"
    cat "$OUTPUT_FILE" >> "$OUTPUT_FILE.temp"
    mv "$OUTPUT_FILE.temp" "$OUTPUT_FILE"
    rm "$OUTPUT_FILE.index"
fi

echo ""
echo "Proceso completado:"
echo "- Se analizaron $TOTAL_FILES archivos en total"
echo "- Se incluyeron $INCLUDED_FILES archivos en $OUTPUT_FILE"
echo "- Tamaño del archivo generado: $(du -h "$OUTPUT_FILE" | cut -f1)"
echo ""
echo "El archivo fusionado se encuentra en: $OUTPUT_FILE"
# =============================================
# ARCHIVO: ./package.json
# =============================================

{
	"name": "kinkyvibe",
	"version": "1.1.0",
	"private": true,
	"scripts": {
		"dev": "vite dev",
		"build": "vite build",
		"preview": "vite preview",
		"check": "svelte-kit sync && svelte-check --tsconfig ./jsconfig.json",
		"check:watch": "svelte-kit sync && svelte-check --tsconfig ./jsconfig.json --watch",
		"test": "playwright test",
		"test:unit": "vitest",
		"lint": "prettier --plugin-search-dir . --check . && eslint .",
		"format": "prettier --plugin-search-dir . --write ."
	},
	"devDependencies": {
		"@jsdevtools/rehype-toc": "^3.0.2",
		"@melt-ui/pp": "^0.3.0",
		"@melt-ui/svelte": "^0.71.0",
		"@playwright/test": "^1.28.1",
		"@sveltejs/adapter-auto": "^2.0.0",
		"@sveltejs/adapter-cloudflare": "^2.2.0",
		"@sveltejs/kit": "^1.5.0",
		"autoprefixer": "^10.4.14",
		"eslint": "^8.28.0",
		"eslint-config-prettier": "^8.5.0",
		"eslint-plugin-svelte3": "^4.0.0",
		"mdsvex": "^0.10.6",
		"prettier": "^2.8.0",
		"prettier-plugin-svelte": "^2.8.1",
		"rehype-slug": "^5.1.0",
		"sass": "^1.62.0",
		"schema-dts": "^1.1.2",
		"svelte": "^3.54.0",
		"svelte-check": "^3.0.1",
		"svelte-preprocess": "^5.0.3",
		"typescript": "^5.0.0",
		"vite": "^4.2.0",
		"vitest": "^0.25.3"
	},
	"type": "module",
	"dependencies": {
		"@codemirror/lang-markdown": "^6.2.2",
		"@octokit/core": "^4.2.0",
		"add-to-calendar-button": "^2.2.10",
		"buffer": "^6.0.3",
		"date-fns": "^2.30.0",
		"hast-util-find-and-replace": "^4.1.3",
		"hast-util-has-property": "^2.0.1",
		"hast-util-heading-rank": "^2.1.1",
		"hast-util-to-string": "^2.0.0",
		"hastscript": "^8.0.0",
		"ics": "^3.2.0",
		"lucide-svelte": "^0.217.0",
		"rehype": "^12.0.1",
		"rehype-autolink-headings": "^6.1.1",
		"remark-gfm": "^3.0.1",
		"simple-icons": "^8.14.0",
		"svelte-codemirror-editor": "^1.1.0",
		"unist-util-visit": "^5.0.0",
		"wrangler": "^3.3.0",
		"yaml": "^2.4.1"
	}
}

# =============================================
# ARCHIVO: ./playwright.config.js
# =============================================

/** @type {import('@playwright/test').PlaywrightTestConfig} */
const config = {
	webServer: {
		command: 'npm run build && npm run preview',
		port: 4173
	},
	testDir: 'tests'
};

export default config;

# =============================================
# ARCHIVO: ./repo_merged.txt
# =============================================


# =============================================
# ARCHIVO: ./src/app.d.ts
# =============================================

// See https://kit.svelte.dev/docs/types#app
// for information about these interfaces
declare global {
	namespace App {
		interface Locals {
			user: Partial<GHUser>|undefined,
			user_token: string // Your type here
		}
		// interface Error {}
		// interface Locals {}
		// interface PageData {}
		// interface Platform {}
	}
}

export {};

# =============================================
# ARCHIVO: ./src/app.html
# =============================================

<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<link rel="apple-touch-icon" sizes="180x180" href="%sveltekit.assets%/apple-touch-icon.png" />
	<link rel="icon" type="image/png" sizes="32x32" href="%sveltekit.assets%/favicon-32x32.png" />
	<link rel="icon" type="image/png" sizes="16x16" href="%sveltekit.assets%/favicon-16x16.png" />
	<link rel="manifest" href="%sveltekit.assets%/site.webmanifest" />
	<link rel="alternate" type="application/rss+xml" title="RSS Feed for KinkyVibe.ar" href="/rss" />
	<link rel="preconnect" href="https://fonts.googleapis.com" />
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
	<link href="https://fonts.googleapis.com/css2?family=Lato&display=swap" rel="stylesheet" />
	<meta name="viewport" content="width=device-width" />
	%sveltekit.head%
</head>

<body data-sveltekit-preload-data="hover">
	<div style="display: contents">%sveltekit.body%</div>

	<!-- Cloudflare Web Analytics -->
	<script defer src="https://static.cloudflareinsights.com/beacon.min.js"
		data-cf-beacon='{"token": "eb67d1991a6e47079e98bc624a13020d"}'></script>
	<!-- End Cloudflare Web Analytics -->
</body>

</html>
# =============================================
# ARCHIVO: ./src/hooks.server.js
# =============================================

import { ghGet } from '$lib/external/github';
const EMPTY_USER = { login: '', name: '', avatar_url: '' };
/** @type {import('@sveltejs/kit').Handle} */
export async function handle({ event: request, resolve }) {
	//@ts-ignore
	let prevToken = request.cookies.get('prevToken');
	let token = request.cookies.get('userToken');
	request.locals.user_token = token ?? '';
	let user = EMPTY_USER;
	if (token && token !== '' && token !== prevToken) {
		user = (await getUser(token)) ?? EMPTY_USER;
		request.locals.user = { login: user.login, name: user.name, avatar_url: user.avatar_url };
	} else if (token === '') {
		user = EMPTY_USER;
		request.locals.user = undefined;
	} else {
		user = {
			login: request.cookies.get('userLogin') ?? '',
			name: request.cookies.get('userName') ?? '',
			avatar_url: request.cookies.get('userAvatarUrl') ?? ''
		};
		request.locals.user = { login: user.login, name: user.name, avatar_url: user.avatar_url };
	}
	let { login, name, avatar_url } = user;
	request.cookies.set('userLogin', login, { path: '/' });
	request.cookies.set('userName', name, { path: '/' });
	request.cookies.set('userAvatarUrl', avatar_url, { path: '/' });
	const response = await resolve(request);
	return response;
}

/**
 * @param {string} token
 * @return {Promise<GHUser>}
 */
async function getUser(token) {
	// @ts-ignore
	return await ghGet('user', token);
}

# =============================================
# ARCHIVO: ./src/index.test.js
# =============================================

import { describe, it, expect } from 'vitest';

describe('sum test', () => {
	it('adds 1 + 2 to equal 3', () => {
		expect(1 + 2).toBe(3);
	});
});

# =============================================
# ARCHIVO: ./src/lib/components/AgeModal.svelte
# =============================================

<script>
	import { onMount } from 'svelte';
	import { fade } from 'svelte/transition';
	let mayorDeEdad = true;
	onMount(() => {
		mayorDeEdad = localStorage.getItem('mayorDeEdad') === 'true';
		localStorage.setItem('mayorDeEdad', '' + mayorDeEdad);
	});
</script>

{#if !mayorDeEdad}
	<div class="background" transition:fade>
		<div class="content box">
			<h2>¿Sos mayor de 18 años?</h2>
			<div class="button-group">
				<button
					class="button"
					on:click={() => {
						mayorDeEdad = true;
						localStorage.setItem('mayorDeEdad', '' + mayorDeEdad);
					}}>Sí</button
				>
				<a class="button" href="https://instagram.com/kinkyvibeargentina">No</a>
			</div>
		</div>
	</div>
{/if}

<style>
	.background {
		position: fixed;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		pointer-events: all;
		background: color-mix(in srgb, black 60%, transparent);
		z-index: 3;
	}
	.box {
		position: absolute;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
		text-align: center;
		padding: 1em;
		max-width: max-content;
		border-radius: 0.3em;
		background: white;
		color: black;
		z-index: 4;
		pointer-events: all;
	}
	.box h2 {
		margin-top: 0.3em;
	}
	.button-group {
		display: flex;
		gap: 1em;
		justify-content: center;
		margin-top: 1em;
	}
	.button {
		padding: 0.3em 1em;
		font-size: var(--step-0);
		border: 0;
		flex: 1 1;
		outline: 0;
		background: var(--1);
		color: white;
		cursor: pointer;
		border-radius: 0.3em;
		transition: 100ms;
	}
</style>

# =============================================
# ARCHIVO: ./src/lib/components/Calendar.svelte
# =============================================

<script>
	//@ts-nocheck
	import {
		getDate,
		getDay,
		getDaysInMonth,
		isSameMonth,
		setDate,
		format,
		addDays,
		isPast
	} from 'date-fns';
	import { scale } from 'svelte/transition';
	import { view_date } from '$lib/utils/stores';

	export let start_on_sunday = true;
	let today_date = new Date();
	// export let view_date = today_date;
	const WEEK_DAYS = ['L', 'M', 'X', 'J', 'V', 'S', 'D'];
	if (start_on_sunday) {
		const s = WEEK_DAYS.splice(WEEK_DAYS.length - 1, 1);
		WEEK_DAYS.unshift(s[0]);
	}
	$: view_is_same_month = isSameMonth($view_date, today_date);
	$: days_in_month = getDaysInMonth($view_date);
	$: first_week_day = getDay(setDate($view_date, 1)) || (start_on_sunday ? 0 : 7);
</script>

<!-- <CalendarHeader /> -->

{#key $view_date}
	<div class="grid">
		<!-- in:fly={{ x: 100 * $month_change_direction, duration: 300, delay: 300 }}
	out:fly={{ x: -100 * $month_change_direction, duration: 300 }} -->
		{#each WEEK_DAYS as day, i}
			<div class="week-days" out:scale={{ duration: 300 }} in:scale={{ delay: 300 }}>
				{day}
			</div>
		{/each}
		{#each Array(start_on_sunday ? first_week_day : first_week_day - 1) as _, i}
			<div class="cell" out:scale={{ duration: 300 }} in:scale={{ delay: 300 }} />
		{/each}
		{#each Array(days_in_month) as _, i}
			{@const date_og = setDate($view_date, i + 1)}
			{@const date = format(date_og, 'yyyy-MM-dd')}
			{@const today = view_is_same_month ? getDate(today_date) === i + 1 : false}
			{@const past = isPast(addDays(date_og, 1))}
			<div class="cell" out:scale={{ duration: 300 }} in:scale={{ delay: 300 }}>
				<slot {date} {today} {past}>
					{date_og.toLocaleDateString(undefined, { day: 'numeric' })}
				</slot>
			</div>
		{/each}
	</div>
{/key}

<style>
	.grid {
		display: grid;
		grid-template-columns: repeat(7, 1fr);
		align-items: center;
		justify-items: center;
		row-gap: 0em;

		/* width: 100%; */
		min-width: 0;
		max-width: 100%;

		height: 100%;
		/* max-height: 80vh; */
		min-height: 0;

		/* aspect-ratio: 7/5; */
	}

	.week-days {
		color: var(--week-days-color, gray);
		font-weight: var(--week-days-font-weight, 600);
		margin: var(--week-days-margin, 0 0 0rem 0);
	}

	.cell {
		text-align: center;
		width: 100%;
		height: 100%;
		min-width: 0;
		min-height: 0;
		/* aspect-ratio: 1/1; */
	}
</style>

# =============================================
# ARCHIVO: ./src/lib/components/CalendarHeader.svelte
# =============================================

<script>
	//@ts-nocheck
	import { isSameMonth, isSameYear, addMonths, isBefore, format } from 'date-fns';
	import { ArrowLeft, Home, ArrowRight } from 'lucide-svelte';
	import { view_date, month_change_direction } from '$lib/utils/stores';

	const today_date = new Date();
	// export let view_date = today_date;
	// export let set_next_month;
	// export let set_prev_month;
	// export let set_today;
	import { page } from '$app/stores';
	page.subscribe((p) => {
		if (p.url.searchParams.get('viewdate')) {
			$view_date = addMonths(new Date($page.url.searchParams.get('viewdate')), 1);
		}
	});
	let updateURL = () => {
		if (isSameMonth($view_date, today_date)) {
			$page.url.searchParams.delete('viewdate');
			window.history.replaceState('', '', $page.url);
		} else {
			$page.url.searchParams.set('viewdate', format($view_date, 'yyyy-MM'));
			window.history.pushState('', '', `?${$page.url.searchParams.toString()}`);
		}
	};

	function capitalize(string) {
		return string.charAt(0).toUpperCase() + string.slice(1);
	}
	const set_next_month = () => {
		month_change_direction.update(() => 1);
		view_date.update((d) => addMonths(d, $month_change_direction));
		updateURL();
	};
	const set_prev_month = () => {
		month_change_direction.update(() => -1);
		view_date.update((d) => addMonths(d, $month_change_direction));
		updateURL();
	};
	const set_today = () => {
		month_change_direction.update(() => (isBefore($view_date, today_date) ? -1 : 1));
		view_date.update(() => new Date(today_date));
		$page.url.searchParams.delete('viewdate');
		window.history.replaceState('', '', $page.url);
	};

	$: view_month_string = capitalize($view_date.toLocaleDateString('es-AR', { month: 'long' }));
	$: view_year_string = $view_date.toLocaleDateString('es-AR', { year: 'numeric' });
	$: view_is_different_year = !isSameYear($view_date, today_date);
	$: view_is_same_month = isSameMonth($view_date, today_date);
</script>

<div class="header">
	<span class="month">
		{view_month_string}
		{#if view_is_different_year}
			{view_year_string}
		{/if}
	</span>

	<div>
		<button on:click={set_prev_month} aria-label="Previous Month"> <ArrowLeft /> </button>
		<button on:click={set_today} aria-label="today" disabled={view_is_same_month}>
			<Home />
		</button>
		<button on:click={set_next_month} aria-label="Next Month"> <ArrowRight /> </button>
	</div>
</div>

<style>
	.header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		margin: var(--header-margin, 0 0 0rem 0);
		min-width: 0;
		max-width: 100%;
		width: 100%;
		min-height: 0;
		max-height: 100%;
		margin-inline: auto;
	}

	.month {
		font-weight: var(--month-font-weight, 600);
		font-size: var(--month-font-size, 2rem);
	}
	button {
		background: transparent;
		color: #222;
		border: 0;
		border-radius: 0.6em;
		padding: 1em;
		cursor: pointer;
	}
</style>

# =============================================
# ARCHIVO: ./src/lib/components/Card.svelte
# =============================================

<script>
	import { tagManager } from '$lib/utils/stores';
	import { onMount } from 'svelte/internal';
	import Tag from './Tag.svelte';
	import { isPast } from 'date-fns';
	export let post;
	/**@type {{path: string, mark: string|undefined, start: Date|undefined, meta: AnyPostData}}*/
	let {
		path: href,
		meta: { tags, featured: src, category, title, pronoun, start },
		mark
	} = post;
	export let setId = true;
	mark = tags.includes('KinkyVibe') ? 'KinkyVibe' : undefined;
	let mounted = false;
	onMount(() => (mounted = true));

	/**@type {(tag:string[])=>string[]}*/
	function removeParents(tags) {
		let allParents = [...new Set(tags.map((t) => $tagManager.get(t)?.parents ?? []).flat())];
		return tags.filter((t) => !allParents.includes(t));
	}
</script>

<a
	{href}
	class:past={isPast(new Date(start ?? ''))}
	class="card {mark ? 'mark' : ''} {category} {{
		amigues: 'h-card',
		calendario: 'h-event',
		material: 'h-entry',
		wiki: 'h-entry'
	}[category]}"
	tabindex="0"
	id={setId ? href : ''}
>
	{#if mark}
		<span class="card-mark">{mark}</span>
	{/if}
	<img class="card-img u-featured placeholder-gradient" {src} alt="" />
	<h3 class="p-name">
		{title}
		{#if pronoun && (pronoun + '').split('/').pop() != 'evitar'}
			<br />
			<small class="p-pronouns">
				{@html (pronoun + '').split('/').pop()?.split(',')[0].replaceAll('&', '&nbsp;/&nbsp;')}
			</small>
		{/if}
	</h3>
	{#if tags}
		<ul class="tagrow">
			{#each removeParents([...tags.filter((/**@type string*/ t) => t != 'KinkyVibe')]) as tag}
				{@const config = $tagManager.get(tag)}
				{@const color = config?.getColor() ?? 'var(--color-2,var(--1))'}
				<li
					style:--tag-color={color}
					style:white-space={'nowrap'}
					style:--hover-text-decoration={'underline white'}
				>
					<Tag {tag} icon={config.icon ?? ''} isLink={mounted} />
				</li>
			{/each}
		</ul>
	{/if}
</a>

<style lang="scss">
	.card-img {
		height: 15em;
		width: 100%;
		background: linear-gradient(
			to bottom right,
			color-mix(in srgb, var(--post-color, var(--2)) 70%, white) 0%,
			var(--post-color, var(--2)) 50%,
			color-mix(in srgb, var(--post-color, var(--2)) 70%, black) 100%
		);
		--cround: calc(var(--round) * 0.93);
		border-radius: var(--cround) var(--cround) 0 0;
		border: 0 !important;
		outline: 0;
		object-fit: cover;
	}
	.card {
		display: flex;
		justify-content: flex-start;
		flex-direction: column;
		margin: 0;
		border-radius: var(--round);
		width: var(--card-width, 13rem);
		height: 100%;
		background: white;
		cursor: pointer;
		padding-bottom: 1em;
		transition: 100ms;
		transform: scale(100%);
		text-decoration: none;
		color: inherit;
	}
	h3 {
		margin: auto auto;
		padding: 0.5em;
		text-align: center;
	}
	.p-pronouns {
		font-size: 0.6em;
		opacity: 0.7;
		color: var(--post-color, var(--2));
		text-decoration: none;
	}
	.card.past {
		opacity: 0.3;
	}
	.card.mark {
		--post-color: var(--1);
		--shadow-color: var(--color, var(--color-2, var(--1)));
		box-shadow: 0 0 0.3em 0.2em rgba(0, 0, 0, 0.05);
		height: 100%;
		outline: 0px var(--color, var(--color-2, var(--1))) solid;
		&.amigues img {
			box-shadow: 0em 0.1em 0 0.1em var(--post-color, var(--color-2, var(--2)));
		}
	}
	.card.mark:hover,
	.card.mark:focus {
		outline: 3px var(--color, var(--color-2, var(--1))) solid;
		box-shadow: 0em 0em 0em -0em var(--shadow-color);
		&.amigues img {
			outline: 3px var(--color, var(--color-2, var(--1))) solid;
		}
	}
	.card:hover,
	.card:focus {
		transform: scale(105%);
	}
	.card-mark {
		position: absolute;
		top: -0.7em;
		left: -1em;
		--radius: calc(var(--round) * 0.9);
		border-radius: var(--round);
		padding: 0.2em 0.5em;
		color: white;
		background: var(--color, var(--color-2, var(--1)));
		z-index: 1;
		scale: 0;
		opacity: 0;
		transition: 200ms;
	}
	.card.mark:hover .card-mark,
	.card.mark:focus .card-mark {
		opacity: 1;
		scale: 1;
	}
	.tagrow {
		list-style: none;
		padding: 0;
		display: flex;
		font-size: 0.8em;
		/* padding: 0 0.4em; */
		overflow-x: scroll;
		overflow-y: hidden;
		position: absolute;
		bottom: -1em;
		left: 0;
		width: var(--card-width);
		/* transition: 100ms; */
		max-width: 100%;
		scrollbar-width:none;
	}
	.tagrow::-webkit-scrollbar {
		display: none;
		opacity: 0;
		transition: 500ms;
	}
	.card:hover .tagrow {
		--scrollbar-width: calc(var(--step--1) * 0.4);
		scrollbar-width: thin;
		scrollbar-color: white transparent;
		margin-bottom: calc(var(--scrollbar-width) * -1);

		/* Chrome, Edge and Safari */
		&::-webkit-scrollbar {
			opacity: 1;
			display: unset;
			width: var(--scrollbar-width);
			height: var(--scrollbar-width);
		}
		&::-webkit-scrollbar-track {
			border-radius: 0px;
			background-color: transparent;
		}

		&::-webkit-scrollbar-thumb {
			border-radius: 1rem;
			background-color: var(--1-light);
			&:active {
				background-color: var(--1);
			}
		}
	}
	.amigues {
		border-top-left-radius: 999em;
		border-top-right-radius: 999em;
		margin-inline: 0.3em;
	}
	.amigues .card-img {
		outline: 1px solid var(--post-color, var(--2));
		height: unset;
		aspect-ratio: 1;
		border-radius: 999em;
		scale: 1.1;
	}
	.amigues h3 {
		font-size: var(--step-1);
		padding-top: 1em;
	}
</style>

# =============================================
# ARCHIVO: ./src/lib/components/CardRow.svelte
# =============================================

<script>
	//@ts-nocheck
	import Card from './Card.svelte';
	import { fly } from 'svelte/transition';
	export let title = '';
	export let items = [];
	export let id = undefined;
	export let href = undefined;
	export let index = undefined;
	export let setId = true;
</script>

<div
	{id}
	in:fly={{ y: ((index % 2) - 0.5) * 2 * 200, duration: 300, delay: 300 }}
	out:fly={{ y: ((index % 2) - 0.5) * 2 * -200, duration: 300 }}
	class="cardrowcontainer"
>
	{#if title}
		<h2 class="cardrow_title">
			{title}
		</h2>
	{/if}
	<ul class="cardrow">
		{#each items as post, i}
			<li class="cardcontainer">
				<Card {setId} {post} />
			</li>
		{/each}
	</ul>
	{#if href}<a class="btn-more" {href} tabindex="0">...ver más</a>{/if}
</div>

<style lang="scss">
	:root {
		--card-width: 13rem;
	}
	.cardrowcontainer {
		background: var(--color-1, var(--2));
		padding: 1em;
		border-radius: 0.5em;
		position: relative;
		margin: 0em 0 1em 0;
	}

	.cardrow {
		display: flex;
		gap: 1em;
		padding: 2em;
		overflow-x: scroll;
		overflow-y: visible;
		margin: 0;
		width: 100%;
	}
	.cardcontainer {
		width: var(--card-width);
		flex: 1;
		display: flex;
		justify-content: center;
		padding-bottom: 1em;
		position: relative;
		overflow: visible;
	}

	ul::after {
		content: '';
		display: block;
		position: absolute;
		right: 0;
		height: 100%;
		background: var(--color-1, var(--2));
		width: 20%;
		mask-image: linear-gradient(to right, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.8));
		pointer-events: none;
		transition: 300ms;
		top: 0;
		border-radius: 0 0.5em 0.5em 0;
	}
	.cardrowcontainer:has(+ a:hover)::after {
		width: 40%;
	}

	.cardrow_title {
		display: block;
		margin: 0em;
		padding: 0.5rem 1rem;
		/* height: em; */

		position: absolute;
		top: -1.2em;

		font-size: 1.2em;

		overflow: visible;

		color: var(--color-1, var(--2));
		background: white;
		border: 3px var(--color-1, var(--2)) solid;
		border-radius: 1rem;
	}
	.btn-more {
		display: block;
		position: absolute;
		right: -0.5rem;
		top: calc(50% - 1.5em);

		padding: 0.6em 1em;
		outline: 3px var(--color-1, var(--2)) solid;
		outline-offset: 0;
		border: 0;
		border-radius: 0.3em;
		background: var(--color-2, var(--1));
		color: white;
		font-weight: bold;
		font-size: 1.1em;
		cursor: pointer;
		transition: 100ms;

		text-decoration: none;
		font-weight: normal;
	}
	.btn-more:hover,
	.btn-more:focus {
		transform: scale(105%) translateX(-0.4em);
	}
	.btn-more:active {
		filter: brightness(90%);
		background: var(--1);
	}
	.cardrow::-webkit-scrollbar {
		display: none;
		opacity: 0;
		transition: 500ms;
	}
	.cardrow {
		--scrollbar-width: calc(var(--step--1) * 0.6);
		scrollbar-width: thin;
		scrollbar-color: var(--color-2, var(--1)) transparent;
		margin-bottom: calc(var(--scrollbar-width) * -1);

		/* Chrome, Edge and Safari */
		&::-webkit-scrollbar {
			opacity: 1;
			display: unset;
			width: var(--scrollbar-width);
			height: var(--scrollbar-width);
		}
		&::-webkit-scrollbar-track {
			border-radius: 0px;
			background-color: transparent;
		}

		&::-webkit-scrollbar-thumb {
			border-radius: 1rem;
			background-color: var(--color-2, var(--2));
			cursor: ew-resize;
		}
	}
</style>

# =============================================
# ARCHIVO: ./src/lib/components/Carrousel.svelte
# =============================================

<script>
	// @ts-nocheck
	import { format } from 'date-fns';
	import es from 'date-fns/locale/es/index.js';
	import { cubicInOut } from 'svelte/easing';
	import { fade } from 'svelte/transition';
	/**@type {{path: string, meta: AnyPostData}[]}*/
	export let posts;
	let index = 0;
	$: post = posts[index];
	const defaultCombos = [
		['var(--1)', 'white'],
		['var(--2)', 'white'],
		['var(--3)', 'white']
	];
	let currDefaultCombo = 0;
	$: slideColors = posts.map((p) => {
		if (p.meta.carrousel_background) {
			return [
				p.meta.carrousel_background,
				p.meta.carrousel_color ?? 'white',
				p.meta.carrousel_accent_text ?? p.meta.carrousel_color ?? 'white',
				p.meta.carrousel_accent_bg ?? p.meta.carrousel_background
			];
		} else {
			currDefaultCombo = currDefaultCombo == defaultCombos.length - 1 ? 0 : currDefaultCombo + 1;
			// alert(defaultCombos[currDefaultCombo])
			return defaultCombos[currDefaultCombo];
		}
	});
	$: currBackground = slideColors[index][0];
	$: currColor = slideColors[index][1];
	$: currAccent = slideColors[index]?.[2] ?? currColor ?? 'white';
	$: currAccentBg = slideColors[index]?.[3] ?? currBackground;
	/**
	 * @param {HTMLElement} node
	 * @param {{ delay?: number, duration?: number, easing?: (t: number) => number }} params
	 * @param {{direction: 'in'|'out'|'both'}} options
	 * @return {{ delay?: number, duration?: number, easing?: (t: number) => number, css?: (t: number, u: number) => string, tick?: (t: number, u: number) => void }}
	 */
	function spin(node, params, { direction }) {
		const existingTransform = getComputedStyle(node).transform.replace('none', '');
		const d = direction === 'in' ? 1 : -1;
		return {
			delay: params.delay || 0,
			duration: params.duration || 400,
			easing: params.easing || cubicInOut,
			css: (t, u) => `
				transform: ${existingTransform} rotate(${-d * u * 360}deg);
				opacity: ${t};
			`
		};
	}
	let clicked = false;
	let autoslide = setInterval(() => {
		if (clicked) {
			clearInterval(autoslide);
		} else {
			index != posts.length - 1 ? index++ : (index = 0);
		}
	}, 10000);
</script>

<div
	id="carrousel"
	style:--currBackground={currBackground}
	style:--currColor={currColor}
	style:--currAccent={currAccent}
	style:--currAccentBg={currAccentBg}
	out:fade
>
	<button
		on:click={() => {
			index != 0 ? index-- : (index = posts.length - 1);
			clicked = true;
		}}>&lt;</button
	>
	{#key index}
		<div class="slide">
			<div class="img-wrapper">
				<img
					in:spin={{ duration: 1500 }}
					out:spin={{ duration: 1500 }}
					src={(post.meta.logo ?? post.meta.featured) + ''}
					alt=""
				/>
			</div>
			<div class="details" in:fade={{ delay: 1100 }} out:fade>
				<h2>
					{format(new Date(post.meta.start), 'EEEE dd', { locale: es })} - {@html (
						post.meta.location_name ?? 'Online'
					).replaceAll(' ', '&nbsp;')}
				</h2>
				<p>{post.meta.summary}</p>
				<a href={post.path}>Saber más</a>
			</div>
		</div>
	{/key}
	<button
		on:click={() => {
			index != posts.length - 1 ? index++ : (index = 0);
			clicked = true;
		}}>&gt;</button
	>
</div>

<style>
	#carrousel {
		color: var(--currColor);
		height: 20rem;
		min-height: fit-content;
		display: flex;
		overflow: visible;
		max-width: 100vw;
		padding: 0;
		margin: 0;
		position: relative;
		margin-bottom: 3em;
		transition: 1500ms;
		/* z-index: -2; */
	}
	#carrousel::before,
	#carrousel::after {
		position: absolute;
		top: 0;
		bottom: 0;
		left: 0;
		right: 0;
		display: block;
		content: ' ';
		pointer-events: none;
	}
	#carrousel::before {
		z-index: -2;
		background-color: var(--currBackground);
		transition: 1000ms;
	}
	#carrousel::after {
		z-index: -1;
		background: linear-gradient(
			to right,
			transparent,
			color-mix(in srgb, transparent 70%, black) 100%
		);
	}
	.slide {
		/* display: flex; */
		gap: 4em;
		display: grid;
		align-items: center;
		grid-template-columns: min(20em, 40%) auto;

		height: 100%;
		min-height: 0;
		max-height: 100%;

		width: 90rem;
		max-width: 100vw;
		min-width: 0;
		padding: 0;
		margin: 0 auto;

		position: absolute;
		left: 3em;
		right: 3em;

		font-size: var(--step-1);
	}
	.details {
		/* color: var(--currColor); */
		/* text-shadow: 0 0 1em black; */
		/* max-height: 100%; */
		max-width: 100%;
		min-width: 0;
		margin-right: 7em;
		width: auto;
		z-index: 1;
		max-height: 100%;
	}
	h2 {
		text-transform: uppercase;
		margin-block: 0;
		font-size: var(--step-0);
	}
	p {
		margin-block: 0;
		text-overflow: ellipsis;
		/* white-space: pre-wrap; */
		max-height: 20%;
		min-height: 0;
		height: 100%;
		overflow: hidden;
	}
	.details a {
		background: var(--currAccentBg);
		color: var(--currAccent);
		padding: 0.3em 0.6em;
		display: block;
		text-align: center;
		max-width: max-content;
		margin-left: auto;
		margin-top: 0.2em;
		scale: 1;
		transition: background 1000ms 1000ms, color 1000ms 100ms, scale 200ms;
		text-decoration: none;
		border-radius: 0.3em;
	}
	.details a:hover {
		color: var(--currAccent);
		scale: 1.1;
	}
	button {
		position: absolute;
		top: 0;
		bottom: 0;
		z-index: 1;
		background: color-mix(in srgb, var(--currBackground) 70%, white);
		outline: 0;
		border: 0;
		color: var(--currColor);
		width: 3rem;
		transition: 1000ms;
		/* pointer-events: all; */
		/* cursor: pointer; */
	}
	button:first-child {
		left: 0;
	}
	button:last-child {
		right: 0;
	}
	.img-wrapper {
		max-height: 100%;
		min-width: 0;
		min-height: 0;
		height: 100%;
		/* width: 40em; */
		display: flex;
		justify-content: center;
	}
	img {
		padding: 0;
		margin: 0;
		scale: 1.1;
		/* box-shadow: 0 0 0.1em var(--currBackground); */
		border-radius: 0.3em;
		z-index: 2;
		transition: 1000ms;
		max-width: 100%;
		min-height: 0;
		max-height: 100%;
		object-fit: contain;
	}
	@media (max-width: 900px) {
		#carrousel {
			height: 40rem;
		}
		.slide {
			grid-template-columns: 1fr;
			width: 100%;
			max-width: 100%;
			left: 0;
			padding-inline: 2.5em;
		}
		.img-wrapper {
			width: 100%;
			max-width: 100%;
			min-width: 0;
			height: 20rem;
		}
		.details {
			margin-right: 0;
		}
		img {
			pointer-events: none;
		}
	}
</style>

# =============================================
# ARCHIVO: ./src/lib/components/FilterBar.svelte
# =============================================

<script>
	import '$lib/types.d.js';
	import { filteredTags, visibleTags, userConfig, tagManager } from '$lib/utils/stores';
	import { scale } from 'svelte/transition';
	import TagGroup from './TagGroup.svelte';
	import { onMount } from 'svelte';
	import { page } from '$app/stores';

	export let event_toggle = true;

	/**@type string[]*/
	let orphanTags = [];
	onMount(() => {
		visibleTags.subscribe((v) => {
			orphanTags = v.filter((v) => $tagManager.get(v).orphan);
		});
		// @ts-ignore
		page.subscribe((p) => {
			if (p.url.searchParams.has('tags')) {
				if (p.url.searchParams.get('tags') != '') {
					//@ts-ignore
					filteredTags.set(p.url.searchParams.get('tags')?.split(','));
				}
			} else filteredTags.set([]);
		});
	});

	let view_filters = true;
</script>

<div class="filterbar">
	<div class="option-group-wrapper">
		<div class="option-group-title">Ver como</div>
		<div id="display-type" class="option-group">
			<label>
				<input
					type="radio"
					name="display-type"
					id="display-type-list"
					bind:group={$userConfig.display_type}
					value="list"
				/>lista
			</label>
			<label>
				<input
					type="radio"
					name="display-type"
					id="display-type-grid"
					bind:group={$userConfig.display_type}
					value="grid"
				/>grilla
			</label>
		</div>
	</div>
	{#if event_toggle}
		<div class="option-group-wrapper">
			<div id="show-past-events" class="option-group">
				<label>
					<input
						type="radio"
						name="show-past-events"
						id="show-past-events-yes"
						bind:group={$userConfig.show_past_events}
						value={true}
					/>Mostrar
				</label>
				<label>
					<input
						type="radio"
						name="show-past-events"
						id="show-past-events-no"
						bind:group={$userConfig.show_past_events}
						value={false}
					/>Ocultar
				</label>
			</div>
			<div class="option-group-title">eventos pasados</div>
		</div>
	{/if}

	{#if $filteredTags.length > 0}
		<div class="tag-group-container">
			<button
				on:click={() => {
					$filteredTags = [];
					$page.url.searchParams.delete('tags');
					window.history.replaceState('', '', $page.url);
				}}>Despejar filtros</button
			>
		</div>
	{/if}
	{#if view_filters || $filteredTags.length > 0}
		{@const tags = [
			...$tagManager
				.tagsData()
				.filter(
					(td) =>
						td?.parents?.includes('root') &&
						(td.getAllChildren().some((t) => $visibleTags.includes(t)) ||
							$visibleTags.includes(td.id))
				),
			$tagManager.get('misc', {
				children: $visibleTags
					.filter((v) => $tagManager.get(v).orphan)
					.sort((a, b) => a.localeCompare(b)),
				noname: true
			})
		]}
		<div class="tagfilters">
			{#each tags as tag, i (tag.id)}
				<div class="tag-group-container" in:scale={{ duration: 500 /*@ts-ignore*/ }}>
					<TagGroup {tag} gap={tag?.getColor() != tags[i + 1]?.getColor()} nested={false} />
				</div>
			{/each}
		</div>
	{/if}
</div>

<style lang="scss">
	.option-group-wrapper {
		display: flex;
		align-items: baseline;
		gap: 0.4em;
		width: auto;
		min-width: 0;
		height: auto;
		min-height: 0;
		margin-bottom: 1em;
		font-size: var(--step--1);
	}
	.option-group-title {
		color: var(--1);
	}
	.option-group {
		display: flex;
		align-items: baseline;
		justify-content: center;
		width: auto;
		min-width: 0;
		height: auto;
		min-height: 0;
		background: white;
		border-radius: 0.5em;
		outline: 1px solid var(--1);
		label {
			display: flex;
			align-items: baseline;
			cursor: pointer;
			color: var(--1);
			padding: 0.2em 0.3em;
			border-radius: 0.5em;
			flex: 1 1;
			transition: 200ms;
			&:has(input:checked) {
				background: var(--1);
				color: white;
			}
		}
		input {
			display: none;
		}
	}
	.filterbar {
		display: flex;
		flex-direction: column;
		/* flex-wrap: wrap; */
		width: 100%;
		/* height: 10rem; */
		--gap: 1px;
		gap: var(--gap);
		justify-content: center;
		align-items: center;
		column-gap: calc(var(--gap) * 0.8);
		--tag-color: var(--1, indigo);
		max-width: min(100%, 100dvw);
		/* container-type: inline-size; */
	}
	.tagfilters {
		gap: var(--gap);
		display: flex;
		flex-direction: row;
		flex-wrap: wrap;
		justify-content: center;
		max-width: min(100dvw, 100%);
	}
	.tag-group-container {
		display: flex;
		flex-direction: column;
		justify-content: center;
		max-width: 100%;
	}
	@container (min-width: 1300px) {
		.tagfilters {
			flex-direction: column;
			max-width: 20rem;
		}
		.groupname {
			width: 100%;
		}
	}
	button {
		border: none;
		outline: 2px solid var(--1);
		border-radius: 0.5em;
		padding: 0.3em 0.6em;
		margin-bottom: 0.5em;
		color: var(--1);
		background: white;
		font-size: var(--step--1);
	}
</style>

# =============================================
# ARCHIVO: ./src/lib/components/Footer.svelte
# =============================================

<script>
	import {
		ArrowRight,
		BookOpen,
		Heart,
		CalendarRange,
		ShoppingCart,
		Rss,
		Layers,
		Globe,
		Home
	} from 'lucide-svelte';
	import { siTiktok, siInstagram, siTwitter, siKofi, siYoutube, siTelegram } from 'simple-icons';
	import SimpleIcon from '$lib/components/SimpleIcon.svelte';
	let style = `scale:var(--scale,1);
				 translate:var(--translate,0 0);`;
</script>

<footer>
	<div class="wip">
		Este sitió esta en constante construcción. Reportar problemas a <a
			href="https://t.me/Gorro_Rojo"
		>
			@Gorro_Rojo
		</a>
		por Telegram. O directamente en
		<a href="https://github.com/GorroRojo/kinkyvibe/issues/new">GitHub</a>.
	</div>
	Codigueado por
	<a href="/amigues/Gorro_Rojo">Gorro_Rojo</a>. Esta página es
	<a href="https://github.com/gorrorojo/kinkyvibe">código abierto</a>
	y software libre.
	<ul>
		<li>
			<h3>Contenido</h3>
			<ul class="contenido">
				<li><a href="/" rel="home"><Home {style} />Inicio</a></li>
				<li><a href="/material"><BookOpen {style} />Material</a></li>
				<li><a href="/amigues"><Heart {style} />Amigues</a></li>
				<li><a href="/calendario"><CalendarRange {style} />Calendario</a></li>
				<li><a href="/todo"><Layers {style} />Todo</a></li>
				<li><a href="/wiki"><Globe {style} />Kinkipedia</a></li>
			</ul>
		</li>
		<li>
			<h3>Sobre nosotres</h3>
			<ul>
				<li>
					<a href="/amigues/KinkyVibe"><ArrowRight {style} />Nosotres y nuestros servicios</a>
				</li>
				<li>
					<a href="https://tienda.kinkyvibe.ar" target="_blank"><ShoppingCart {style} />Tienda</a>
				</li>
				<li>
					<a href="https://cafecito.app/kinkyvibe" target="_blank">
						<SimpleIcon icon={siKofi} />CafecitoApp
					</a>
				</li>
			</ul>
		</li>
		<li>
			<h3>Redes</h3>
			<ul class="redes">
				<li>
					<a href="https://t.me/BDSMtextos" target="_blank">
						<SimpleIcon icon={siTelegram} />
						Telegram
					</a>
				</li>
				<li>
					<a href="https://www.instagram.com/kinkyvibeargentina/" target="_blank">
						<SimpleIcon icon={siInstagram} />
						Instagram
					</a>
				</li>
				<li>
					<a href="https://twitter.com/kinkyvibearg"><SimpleIcon icon={siTwitter} />Twitter</a>
				</li>
				<li>
					<a href="https://www.youtube.com/@KinkyVibe"><SimpleIcon icon={siYoutube} />Youtube</a>
				</li>
				<li>
					<a href="https://www.tiktok.com/@kinkyvibearg"><SimpleIcon icon={siTiktok} />TikTok</a>
				</li>
				<li>
					<a data-sveltekit-reload href="https://kinkyvibe.ar/rss"><Rss {style} />RSS</a>
				</li>
			</ul>
		</li>
		<li>
			<h3>Cuenta</h3>
			<ul>
				<li>
					<a href="/login">Iniciar sesión</a>
				</li>
				<li>
					<a href="/admin">Panel de admin</a>
				</li>
			</ul>
		</li>
	</ul>
</footer>

<style>
	.wip {
		background: var(--2-dark);
		color: white;
		text-align: center;
		padding-block: 0.5em;
		margin-bottom: 1em;
	}
	.wip a:hover {
		color: white;
		text-decoration-color: white;
	}
	footer {
		margin: 0;
		margin-top: 8em;
		padding: 2em;
		background: indigo;
		color: white;
		border-radius: 2em 2em 0 0;
		/* position: absolute; */
		bottom: 0;
		left: 0;
		right: 0;
		box-sizing: border-box;
		font-size: var(--step--1);
		/* transition: 1000ms; */
	}
	a {
		color: white;
		text-decoration: underline;
		text-decoration-color: rgba(250, 250, 250, 0.4);
	}
	li a {
		--scale: 0.8;
		--translate: -0.2em 0.4em;
		--color: white;
	}
	a:hover {
		text-decoration-color: var(--1);
	}
	footer > ul {
		display: flex;
		list-style: none;
		justify-content: space-around;
		padding: 0;
		flex-wrap: wrap;
		gap: 4px;
	}
	li > ul {
		padding: 0;
		list-style: none;
	}
	@media screen and (max-width: 680px) {
		footer {
			bottom: 6rem;
		}
		:global(body) {
			padding-bottom: 6rem;
		}
	}
</style>

# =============================================
# ARCHIVO: ./src/lib/components/GlosarioItem.svelte
# =============================================

<script context="module">
	import { ChevronRight, ChevronDown } from 'lucide-svelte';
	import MiniMarkup from './MiniMarkup.svelte';
	import GlosarioTree from './GlosarioTree.svelte';
	import { tagManager, wikiTagManager, query } from '$lib/utils/stores';
	import { page } from '$app/stores';
	import { createCollapsible, melt } from '@melt-ui/svelte';
	import { slide } from 'svelte/transition';
</script>

<script>
	/**@type {TagID}*/
	export let item = 'root';
	export let single = false;
	export let title = false;
	const {
		elements: { root, content, trigger },
		states: { open },
		options
	} = createCollapsible();
	query.subscribe((q) => {
		if (q != '') {
			open.set(true);
		}
	});
	/**@type {ProcessedTag}*/
	let tag = $wikiTagManager.get(item);
	wikiTagManager.subscribe((wtm) => (tag = wtm.get(item)));

	const name = tag?.visible_name ?? tag.id;
	/** @type {ProcessedPost} */
	const entry = $page.data.wiki.find(
		(/**@type ProcessedPost */ e) => e.meta.wiki == name.replaceAll(' ', '-')
	);
	const description =
		tag.parsedDescription ??
		[
			{
				type: 'text',
				line: entry?.meta?.summary ?? undefined
			}
		].filter(({ line }) => line);
	const hasDescription = description?.length > 0;
	const hasSub = tag.children?.length ?? 0 > 0;
	let expanded = false;
	let isVisible = isVisibleFn(item);
	/**
	 * @param {TagID} tagID
	 * @returns {boolean}
	 */
	function isVisibleFn(tagID) {
		let t = $wikiTagManager.get(tagID);
		if (
			(t.description && t.description != '') ||
			(t?.related?.length ?? 0) > 0 ||
			(t?.aka?.length ?? 0) > 0
		) {
			return true;
		} else {
			let children = t.getAllChildren();
			if (children.length > 0) {
				return children.some((s) => isVisibleFn(s));
			} else {
				return false;
			}
		}
	}
	const style = `
	scale: .8;
	translate: 0 .4em;
	color: var(--1);
	`;
</script>

{#if isVisible}
	<div
		use:melt={$root}
		class="all"
		class:single
		class:title
		style:--color={'var(--1)' ?? tag.getColor() ?? 'var(--2)'}
	>
		<dt id={name} class:onlyTitle={!(hasDescription || tag.related)}>
			<div class="itemtitle">
				{#if !title && entry && entry.meta && entry.meta.wiki}
					{tag?.icon ?? ''}
					<a href="/wiki/{entry.meta.wiki}">
						<MiniMarkup value={entry.meta.title} />
					</a>
				{:else if title}
					<h1>
						{tag?.icon ?? ''}
						<MiniMarkup value={name[0].toLocaleUpperCase() + name.slice(1)} />
					</h1>
				{:else}
					{tag?.icon ?? ''}
					<MiniMarkup value={name[0].toLocaleUpperCase() + name.slice(1)} />
				{/if}
				{#if tag?.aka?.length ?? 0 > 0}
					<small>
						(
						{#each tag?.aka ?? [] as other, i}
							{i == 0 ? '' : ', '}<MiniMarkup value={other} />
						{/each}
						)
					</small>
				{/if}
			</div>
		</dt>
		{#if hasDescription || hasSub || tag.related}
			<dd>
				{#if hasDescription || tag.related}
					<div class="self">
						{#if hasDescription}
							<span>
								<MiniMarkup value={description} parsed />
							</span>
						{/if}
						{#if hasDescription && tag.related}<br />{/if}
						{#if tag.related}
							{@const related = tag.related
								.map(
									(relatedTag) =>
										$page.data.wiki.find(
											(/** @type {ProcessedPost} */ e) => e.meta.wiki == relatedTag
										) ?? $tagManager.tagsData().find((t) => t.id == relatedTag)
								)
								.filter((t) => t)}
							{#if related.length > 0}
								<small
									>Ver también:
									{#each related as relatedTag, i}
										{#if relatedTag.meta}
											<a href="/wiki/{relatedTag.meta.wiki}">{relatedTag.meta.wiki}</a>
										{:else}
											<a href="/wiki#{relatedTag?.visible_name ?? tag.id}">{relatedTag.id}</a>
										{/if}
										{i < tag.related.length - 1 ? ' | ' : ''}
									{/each}
								</small>
							{/if}
						{/if}
					</div>
				{/if}
				{#if hasSub && !single}
					<button class:open={$open} use:melt={$trigger} class="expand">
						{#if $open}
							<ChevronDown {style} />
						{:else}
							<span>
								<ChevronRight {style} />
								{$wikiTagManager.get(item)?.children?.length} más...
							</span>
						{/if}
					</button>
					{#if $open}
						<dl use:melt={$content}>
							<GlosarioTree root={item} />
						</dl>
					{/if}
				{/if}
			</dd>
		{/if}
	</div>
{/if}

<mark hidden />

<style>
	mark {
		color: red !important;
	}
	dt {
		/* text-transform: capitalize; */
		border-bottom: 1px solid var(--color);
		width: fit-content;
		border-radius: var(--round);
		padding: 0.1em 0.4em;
		background: white;
		translate: 0 0.5em;
		z-index: 1;
		position: relative;
		font-size: var(--step-0-5);
	}
	dt.onlyTitle {
		translate: 0;
		margin-top: 0.5em;
	}
	dt a {
		text-decoration-thickness: 3px;
	}
	dt small {
		text-transform: none;
		opacity: 0.6;
		font-size: var(--step--1);
	}
	.itemtitle {
		display: inline;
	}
	.self small {
		font-size: var(--step--1);
		display: block;
		margin-top: 0.5em;
	}
	.all {
		padding-inline-start: 2em;
	}
	.all.single {
		padding-inline-start: 0;
	}
	.all.single dt {
		font-size: var(--step-1);
	}
	.all.title {
		margin-bottom: 1em;
	}
	.self {
		background: white;
		padding: 0.9em 1em;
		border-radius: var(--round);
	}
	.self span {
		font-size: var(--step-0);
	}
	dd {
		margin-inline-start: 0;
		/* padding: 0; */
		/* z-index: -1; */
		border-left: unset;
	}
	dd::before {
		content: '';
	}
	dl {
		/* padding:0; */
		margin-top: 0.5em;
		border-left: 2px solid color-mix(in srgb, var(--color, var(--1)) 40%, transparent);
	}
	button {
		font-size: var(--step--1);
		border: none;
		color: var(--1);
		padding: 0.6em 1em;
		border-radius: var(--round);
		/* display: inline-grid; */
		/* place-items: center; */
		background: transparent;
		margin-top: 0.1em;
		transition: 100ms;
		background: #eee;
	}
	button.open {
		position: absolute;
		/* padding: 0; */
		translate: -1.65em 0;
	}
</style>

# =============================================
# ARCHIVO: ./src/lib/components/GlosarioTree.svelte
# =============================================

<script context="module">
	import { wikiTagManager } from '$lib/utils/stores';
	import GlosarioItem from './GlosarioItem.svelte';
</script>

<script>
	export let root = 'root';
	/**@type TagID[]*/
	let items = [];
	wikiTagManager.subscribe((wtm) => {
		items = wtm.get(root).children ?? [];
	});
</script>
{#each items as item}
	<GlosarioItem {item} />
{/each}

# =============================================
# ARCHIVO: ./src/lib/components/HumanBody.svelte
# =============================================

<script>
	import parts from './body-parts.js';
	import '$lib/types.d.js';
	/**
	 * @param {{ target: { id: any; }; }} e
	 */
	function click(e) {
		alert(e.target.id);
	}
	/**
	 * @type {{default: string, groups: Array<{name: string, color: string, parts: BodyPart[]}> }}
	 */
	export let colors = { default: '#888', groups: [] };
	export let debug = false;
</script>

<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 68.587668 92.604164">
	{#each parts as part}
		{@const group = colors.groups.find((g) => g.parts.some((p) => part.name.startsWith(p)))}
		<!-- svelte-ignore a11y-click-events-have-key-events -->
		<path
			id={part.name}
			style:--color={group ? group.color : colors.default ?? '#888'}
			d={part.path}
			on:click={() => (debug ? alert(part.name) : '')}
		/>
	{/each}
</svg>

<style>
	svg {
		display: block;
		width: 100%;
		height: auto;
		max-height: 90vh;
	}
	path {
		/* cursor: pointer; */
		fill: var(--color);
	}
</style>

# =============================================
# ARCHIVO: ./src/lib/components/InlineTag.svelte
# =============================================

<script>
	import { togglePositiveTagFilterFn, filteredTags } from '$lib/utils/stores';
	import Tag from '$lib/components/Tag.svelte';

	/** @type string */
	export let tag;
	/** @type string|undefined */
	export let internalTag = undefined;
	/** @type {(a:boolean,b:string)=>*}*/
	let toggle = $togglePositiveTagFilterFn;
	let checked = $filteredTags?.includes(tag) ?? false;
	const aliasedTag = internalTag ?? tag;

	togglePositiveTagFilterFn.subscribe((f) => (toggle = f));
	filteredTags.subscribe((f) => (checked = f.includes(aliasedTag)));
</script>

<Tag
	onInput={(/**@type {*} */ evt) => toggle(evt.target?.checked, aliasedTag)}
	{tag}
	isCheckbox
	{checked}
	--off-background="color-mix(in srgb, var(--1-light) 10%, transparent)"
	--off-outline="1px solid var(--1-light)"
	--off-outline-offset="-2px"
	--font-size="1em"
	--padding="0.1em 0.2em"
	--border-radius=".3em"
	noBorder
/>

# =============================================
# ARCHIVO: ./src/lib/components/LDTag.svelte
# =============================================

<script context="module">
	import '$lib/types.d.js';
	let site = {
		title: 'Navillus: Jamstack developers for hire',
		description:
			"We specialize in finding simple solutions to complex software problems. We value data-driven decisions and accessibility over this month's latest tech trends.",
		url: 'https://KinkyVibe.ar',
		author: 'KinkyVibe',
		social: {
			twitter: 'navillus_dev',
			twitter_card: 'summary_large_image'
		},
		company: {
			name: 'Navillus'
		}
	};
	/**@type import('schema-dts').WithContext<import('schema-dts').Organization>*/
	const organizationSchema = {
		'@context': 'https://schema.org',
		'@type': 'Organization',
		'@id': `${site.url}#organization`,
		url: site.url,
		name: site.company.name,
		description: site.description,
		sameAs: [`https://twitter.com/${site.social.twitter}`],
		logo: `${site.url}/favicon.svg`
	};

	const websiteSchema = {
		'@context': 'https://schema.org',
		'@type': 'WebSite',
		name: site.title,
		url: site.url,
		description: site.description,
		sameAs: [`https://twitter.com/${site.social.twitter}`]
	};
	/**
	 * @param {LD.Schema} thing
	 **/
	function serializeSchema(thing) {
		return `<script type="application/ld+json">${JSON.stringify(thing, null, 2)}</${''}script>`;
	}
</script>

<script>
	/**@type LD.Schema*/
	export let schema;
</script>

<svelte:head>
	{@html serializeSchema(schema)}
</svelte:head>
<!-- {
    "title": "Navillus: Jamstack developers for hire",
    "description": "We specialize in finding simple solutions to complex software problems. We value data-driven decisions and accessibility over this month's latest tech trends.",
    "url": "https://navillus.dev",
    "author": "Navillus",
    "social": {
        "twitter": "navillus_dev",
        "twitter_card": "summary_large_image"
    },
    "company": {
        "name": "Navillus"
    }
} -->

# =============================================
# ARCHIVO: ./src/lib/components/MiniMarkup.svelte
# =============================================

<script>
	import { page } from "$app/stores";
	import { tagManager, query } from "$lib/utils/stores";

	/**@type {(description:string, query:string)=>Array<{type:string,line:string}>|undefined}*/
	function parseDescription(description, query) {
		const regex = /\[\[([^\]]*)\]\]/g;
		const nQuery = normalize(query);
		const lines = description
			.split(regex)
			.map((line, index) => ({ line, type: index % 2 == 0 ? 'text' : 'link' }))
			.map(({ line, type }) => {
				if (type == 'link') {
					if (line.includes(':')) {
						let [href, newStr] = line.split(':');
						return {
							line: newStr,
							type,
							href
						};
					} else {
						return {
							line,
							type,
							href: line
						};
					}
				} else return { line, type };
			})
			.map(({ line, type }) => {
				const nLine = normalize(line+'');
				if (query != '' && nLine.includes(nQuery)) {
					let nParts = nLine.split(nQuery);
					let k = 0;
					let parts = nParts.map((p, i) => {
						k += p.length;
						let end = k;
						if (i != 0 && i % 2 != 0) {
							k += nQuery.length;
							end = k + nQuery.length;
						}
						return line.slice(k - p.length, end);
					});
					return parts
						.map((p, i) =>
							i % 2 == 0
								? [
										{ line: p, type },
										{ line: query, type: 'mark' }
								  ]
								: { line: p, type }
						)
						.flat();
				} else return { line, type };
			})
			.flat()
			.filter(({ line, type }) => line !== '');
		return lines.length > 0 ? lines : undefined;
	}

	/**
	 *
	 * @param {string} s
	 */
	const normalize = (s) =>
		(s + '')
			.toLowerCase()
			.replaceAll('á', 'a')
			.replaceAll('é', 'e')
			.replaceAll('í', 'i')
			.replaceAll('ó', 'o')
			.replaceAll('ú', 'u');

	/**@type{*}*/
	export let value = '';
	export let parsed = false;
	/**@type {ProcessedPost[]}*/
	let entries = $page.data.wiki;
</script>

{#each parsed ? value : parseDescription(value, $query) as { line, type, href }}
	{@const entry = entries.find((e) => e.meta.wiki == (href ?? line)?.replaceAll(' ', '-'))}
	{@const tag = $tagManager.tagsData().find((t) => t.id == (href ?? line)?.replaceAll(' ', '-'))}
	{#if type == 'link' && entry}
		<a href="/wiki/{entry.meta.wiki}">{line}</a>
	{:else if type == 'link' && tag}
		<a href="/wiki#{tag?.visible_name ?? tag.id}">{line}</a>
	{:else if type == 'mark'}
		<mark>{line}</mark>
	{:else}
		{line}
	{/if}
{/each}

<style>
	mark {
		color: var(--2);
		font-weight: bold;
	}
</style>

# =============================================
# ARCHIVO: ./src/lib/components/Navbar.svelte
# =============================================

<script>
	//@ts-nocheck
	import { currentPostData } from './../utils/stores.js';
	import { page } from '$app/stores';
	export let links;
</script>

<nav>
	<ul>
		{#each links as { icon, name, sub, href, target = undefined }}
			<li
				class:current={$page.url.pathname.includes(href) ||
					($currentPostData &&
						$currentPostData?.path == $page?.url?.pathname &&
						$currentPostData?.category == href.slice(1))}
			>
				<a {href} {target} tabindex="0">
					<span>
						<span><svelte:component this={icon} size="1em" /></span>
						{name}
					</span>
					<small>{sub}</small>
				</a>
			</li>
		{/each}
	</ul>
</nav>

<style lang="scss">
	nav ul {
		padding: 0;
		display: flex;
		row-gap: 0.4em;
		justify-content: center;
		margin-inline: auto;
		max-width: 1000px;
	}

	nav li {
		list-style: none;
		max-width: 11em;
		/* padding-block: 0.4em; */
		width: 100%;
		height: 4em;
	}
	nav a {
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		font-weight: bold;
		color: var(--1);
		font-size: 1.2em;
		flex: 1;
		/* border: 2px solid var(--1); */
		/* border-radius: 1em; */
		background: transparent;
		height: 100%;
		text-decoration: none;
		/* box-shadow: 0 0 .2em rgba(1,1,1,.3); */
		transition: 200ms;
		max-width: 20vw;
		overflow-x: visible;
		border-radius: 1em;

		& > span > span {
			position: relative;
			top: 0.2em;
			margin-right: 0.3em;
		}
	}

	.current span {
		color: var(--2);
		--color: var(--2);
	}
	.current a {
		background: white;
		box-shadow: 0 0 0.5em rgba(1, 1, 1, 0.1);
	}
	nav span {
		--color: var(--1);
		color: var(--color);
		translate: 0 0.3em;
		transition: 100ms;
		text-decoration: none;
	}

	nav li:hover span,
	nav a:focus span {
		translate: 0 0;
	}
	nav a:focus {
		outline: 2px solid var(--color);
		border: 0;
	}

	nav li small {
		display: block;
		font-size: 0.6em;
		color: gray;
		scale: 0;
		transition: 100ms;
		white-space: nowrap;
	}
	nav li:hover small,
	nav a:focus small {
		scale: 1;
	}
	@media screen and (max-width: 680px) {
		nav {
			position: fixed;
			bottom: 0;
			left: 0;
			right: 0;
			padding-inline: 1em;
			z-index: 2;
			background: white;
			font-size: 1em;
			ul {
				flex-wrap: nowrap;
				gap: 1em;
				/* width: 100%; */
				li {
					width: 15vw;
					height: 4em;
					&:hover span,
					a:hover span,
					a:focus {
						outline: none;
						span {
							translate: 0 0.3em;
						}
					}
					/* &.current, */
					&.current {
						a {
							box-shadow: none;
						}
						span span {
							scale: 2;
							translate: 0 0.2em;
						}
					}
					a {
						border: 0;
						span {
							display: flex;
							flex-direction: column;
							/* width: 100%; */
							justify-items: center;
							align-items: center;
							font-size: 0.8em;

							span {
								color: var(--color);
								font-size: 1.2em;
								scale: 1.5;
								top: -1rem;
								margin-right: 0;
							}
						}
						small {
							display: none;
						}
					}
				}
			}
		}
	}
	@media screen and (max-width: 340px) {
		nav ul li a span {
			color: transparent;
		}
		nav ul li a span span {
			top: -0.3em;
			scale: 2;
		}
		.current span span {
			top: -0.7em;
		}
		.current span,
		nav a:focus span,
		nav li:hover span {
			translate: 0 0.4em;
		}
	}
</style>

# =============================================
# ARCHIVO: ./src/lib/components/PostList.svelte
# =============================================

<script>
	import { scale, fade } from 'svelte/transition';
	import { flip } from 'svelte/animate';
	import {
		filteredTags,
		visibleTags,
		allTags,
		userConfig,
		tagManager,
		redundantTags
	} from '$lib/utils/stores';
	import PostListItem from './PostListItem.svelte';
	import FilterBar from './FilterBar.svelte';
	import Card from './Card.svelte';
	/**
	 * @type {Record<string,*>[]}
	 */
	/**@type ProcessedPost[]*/
	export let posts = [];
	/** @type {false|{prop: string, value: *}}*/
	export let filter = false;

	/**@type ProcessedPost[]*/
	$: outerFilteredPosts = posts.filter(
		(/**@type {ProcessedPost}*/ p) =>
			// @ts-ignore
			(!filter || (filter && p[filter.prop] == filter.value)) &&
			($userConfig.show_past_events ||
				new Date(p.meta.start).getTime() > Date.now() ||
				p.meta.category != 'calendario')
	);

	/**@type {<T>(arr: T[])=>T[]}*/
	let uniq = (arr) => [...new Set(arr)];

	/**
	 * @param {ProcessedPost[]} posts
	 * @param {string[]} filteredTags
	 * @returns {string[]}
	 */
	function getVisibleTags(posts, filteredTags) {
		let presentTags = new Map();
		for (const post of posts) {
			for (const tag of post.meta.tags) {
				const present = presentTags.get(tag);
				if (present === undefined) {
					presentTags.set(tag, 1);
				} else {
					presentTags.set(tag, present + 1);
				}
			}
		}
		return [...presentTags.entries()]
			.filter(([tag, instances]) => {
				if (instances < posts.length || filteredTags.includes(tag)) {
					$redundantTags.delete(tag);
					return true;
				} else {
					$redundantTags.add(tag);
					const parents = $tagManager.get(tag)?.parents ?? [];
					return filteredTags.some((ft) => parents.includes(ft));
				}
			})
			.map((t) => t[0]);
	}

	$: visibleTags.set(getVisibleTags(tagFilteredPosts, $filteredTags));
	/**@type ProcessedPost[]*/
	$: tagFilteredPosts = outerFilteredPosts.filter(
		(post) =>
			$filteredTags.length == 0 ||
			$filteredTags.every((f) => {
				return (
					post.meta.tags.includes(f) ||
					post.meta.tags.some((t) => $tagManager.get(t)?.getAllParents().includes(f))
				);
			})
	);

	$: allTags.set([
		// @ts-ignore
		...posts.reduce((a, b) => [...a, ...b.meta.tags], []),
		...$tagManager.tagIDs()
	]);
</script>

<slot />
<div class="container">
	<div class="postlist">
		<div id="filterbar">
			<FilterBar
				event_toggle={tagFilteredPosts.length == 0 ||
					tagFilteredPosts.some((p) => p.meta.category == 'calendario')}
			/>
		</div>
		{#if tagFilteredPosts.length > 0 || $filteredTags.length > 0}
			{@const Item = $userConfig.display_type == 'list' ? PostListItem : Card}

			{#key $userConfig.display_type}
				<p class="post-amount">{tagFilteredPosts.length} resultados</p>
				<ul id="posts" in:fade={{ duration: 300 }} class={$userConfig.display_type + ' h-feed'}>
					{#each tagFilteredPosts as post, i (post.path)}
						<li in:scale={{ delay: i * 10 }} animate:flip={{ duration: 500 }}>
							<svelte:component this={Item} {post} />
						</li>
					{/each}
				</ul>
			{/key}
		{/if}
	</div>
</div>

<style lang="scss">
	#posts {
		display: flex;
		gap: 3em;
		flex-direction: column;
		padding: 0;
		/* margin-top: 3em; */
		max-width: 50rem;
		margin-inline: auto;
	}
	.post-amount {
		position: absolute;
		left: 0;
		right: 0;
		text-align: right;
		top: -2em;
		max-width: 50rem;
		margin-inline: auto;
		padding-left: 2em;
		opacity: 0.7;
	}
	li {
		list-style: none;
		max-width: 100dvw;
		min-width: 0;
	}

	.postlist {
		display: grid;
		gap: 1em;
	}
	.container {
		container-type: inline-size;
	}
	#posts.grid {
		/* display:grid; */
		/* grid-auto-flow: column; */
		/* max-width: 100%; */
		flex-direction: row;
		flex-wrap: wrap;
		justify-content: center;
		width: 100%;
	}
	@container (min-width: 1300px) {
		.postlist {
			grid-template-areas: 'left' 'main' 'right';
			grid-template-columns: 1fr 50rem 1fr;
			gap: 1em;
			align-items: start;
			align-content: start;
			padding-left: 1em;
		}
		#posts {
			width: 100%;
		}
		#filterbar {
			grid-area: left;
			top: 1em;
			display: block;
			height: auto;
			align-self: start;
			min-width: 0;
		}
		#display-type {
			margin-bottom: 1em;
		}
	}
	@media screen and (min-width: 1300px) {
	}
</style>

# =============================================
# ARCHIVO: ./src/lib/components/PostListItem.svelte
# =============================================

<script context="module">
	import {
		CalendarRange,
		BookOpen,
		ShoppingCart,
		Download,
		MousePointerClick,
		Heart
	} from 'lucide-svelte';
	import 'add-to-calendar-button';
	import { addHours, format, isPast } from 'date-fns';
	import Tag from './Tag.svelte';
	import { onMount } from 'svelte/internal';
	import { tagManager, filteredTags } from '$lib/utils/stores';
</script>

<script>
	//@ts-nocheck
	export let post;
	let {
		path,
		meta: {
			title,
			summary,
			tags,
			published_date,
			authors,
			start,
			end,
			status,
			featured: src,
			mark,
			link,
			link_text,
			category,
			job_title,
			redirect,
			pronoun
		}
	} = post;
	var date = start ? addHours(new Date(start), 3) : published_date;
	try {
		format(new Date(date), 'yyyy-MM-dd');
	} catch (e) {
		date = '';
	}
	if (tags.includes('KinkyVibe')) {
		mark = mark ? mark : 'KinkyVibe';
		let indexOfMark = tags.indexOf('KinkyVibe');
		tags = [...tags.slice(0, indexOfMark), ...tags.slice(indexOfMark + 1)];
	}
	// mark = tags.includes('KinkyVibe') ? 'KinkyVibe' : undefined;
	let mounted = false;
	onMount(() => (mounted = true));
	let past = start ? isPast(new Date(start)) : false;
	let style = `scale:var(--scale,1);
				 translate:var(--translate,0 0);
				 display: inline-block;
				 margin-right: .4em;`;
</script>

<a
	href={path}
	class="post {category} {{
		amigues: 'h-card',
		calendario: 'h-event',
		material: 'h-entry'
	}[category]} u-url"
	class:mark
	class:noimg={src == 'undefined' || !src}
	id={path}
	class:past={start ? isPast(new Date(start)) || status == 'cancelado' : false}
	tabindex="0"
	target={redirect || path.startsWith('https') ? '_blank' : undefined}
>
	<div class="publication">
		<div class="icon">
			{#if category == 'calendario'}
				<CalendarRange {style} />
			{:else if category == 'material'}
				{#if tags.includes('pago')}
					<ShoppingCart {style} />
				{:else if tags.includes('descargable')}
					<Download {style} />
				{:else if tags.includes('interactivo')}
					<MousePointerClick {style} />
				{:else}
					<BookOpen {style} />
				{/if}
			{:else}
				<Heart style={style + 'fill:var(--post-color);'} strokeWidth="3px" />
			{/if}
			&ThickSpace;
		</div>
		{#if category != 'amigues'}
			{#if date}
				{#if start}
					<time datetime={start} class="dt-start dt-end">
						{@html format(new Date(start), 'yyyy-MM-dd|HH:mm - ').replace(
							'|',
							'&ThickSpace;&ThickSpace;|&ThickSpace;&ThickSpace;'
						) + format(new Date(end ?? ''), 'HH:mm')}
					</time>
				{:else}
					<address class="p-author">
						{authors ? authors.join(', ') : ''}
					</address>
					{@html authors && date ? '&ThickSpace;-&ThickSpace;' : ''}
					<time class="dt-published" datetime={date}>
						{date ? format(new Date(date), 'yyyy-MM-dd') : ''}
					</time>
				{/if}
				{#if !((status && ['cancelado', 'agotadas'].includes(status)) || past) && link && status && status == 'abierto' && !past}
					<add-to-calendar-button
						style={`
							--btn-text: white;
							--keyboard-focus: var(--post-color, var(--2));
							--btn-background: transparent;
							--btn-shadow: none;
							--btn-shadow-hover: none;
							--list-background: white;
							--list-background-hover: var(--1-light) ;
							--list-text-hover: white;
							--btn-border: none;
							--list-shadow: 0 0 1em 0 var(--1-light);
							`}
						name={title}
						description={summary}
						startDate={format(new Date(start), 'yyyy-MM-dd')}
						startTime={format(new Date(start), 'HH:mm')}
						endDate={format(new Date(end), 'yyyy-MM-dd')}
						endTime={format(new Date(end), 'HH:mm')}
						timeZone="America/Buenos_Aires"
						options="'iCal','Apple','Outlook.com','Google','MicrosoftTeams','Microsoft365','Yahoo'"
						language="es"
						iCalFileName="Sample Event"
						listStyle="overlay"
						buttonStyle="3d"
						inline
						organizer="Mel|kinkyvibe@gmail.com"
						size="1"
						hideBackground
					/>
					<!-- TODO add authors WITH EMAILS to organizers, otherwise it doesn't let me add organizers -->
					<!-- label="CUSTOM LABEL" -->
					<!-- buttonStyle="round" -->
					<!-- location="World Wide Web" -->
					<!-- trigger="hover" -->
				{/if}
				{#if (status && ['cancelado', 'agotadas'].includes(status)) || past}
					<small class="status">
						{past && !(status && status == 'cancelado') ? 'TERMINADO' : status.toUpperCase()}
					</small>
				{/if}
			{/if}
		{:else}
			<span class="job-title">{job_title}</span>
		{/if}
	</div>
	{#if src}<img {src} alt="" />{/if}
	<h3>
		{title}
		{#if pronoun && (pronoun + '').split('/').pop() != 'evitar'}
			<small class="p-pronouns">
				{@html '&nbsp;' +
					(pronoun + '').split('/').pop()?.split(',')[0].replaceAll('&', '&nbsp;/&nbsp;')}
			</small>
		{/if}
	</h3>
	<p class="summary p-summary">
		{summary ?? ''}
	</p>
	<div class="tags">
		<ul class="tagrow">
			{#each [...tags.filter((/**@type string*/ t) => t != 'KinkyVibe' && !$filteredTags.includes(t) /* && !$redundantTags.has(t)*/)] as tag}
				{@const config = $tagManager.get(tag)}
				{@const color = config?.getColor() ?? 'var(--color-2,var(--1))'}
				<li
					style:--tag-color={color}
					style:--filled-text-color={'color-mix(in srgb, var(--tag-color) 90%, black'}
					style:--filled-outline={'1px solid var(--tag-color)'}
					style:--fill-color={'color-mix(in srgb, var(--tag-color) 5%, transparent'}
					style:--filled-outline-offset={'-2px'}
					style:--hover-text-decoration={'underline var(--tag-color)'}
					style:white-space={'nowrap'}
				>
					<Tag {tag} icon={config.icon ?? ''} isLink={mounted} />
				</li>
			{/each}
		</ul>
	</div>
	{#if link && status && status == 'abierto' && !past}
		<a href={link} class="CTA" target="_blank">{link_text ?? 'INSCRIPCIÓN'}</a>
	{/if}
</a>

<style lang="scss">
	.post.amigues {
		border-radius: 999em;
		padding-top: 0;
		outline: 2px solid var(--post-color, var(--2));
		padding-right: 3em;
		img {
			border-radius: 10em;
			aspect-ratio: 1;
			object-fit: cover;
		}
		.publication {
			background: none;
			time,
			address,
			.job-title {
				display: none;
			}
			.icon {
				color: var(--post-color);
				left: -1em;
				position: relative;
				scale: 0.8;
				top: -0.2em;
			}
		}
	}
	.tagrow {
		list-style: none;
		padding: 0;
		display: flex;
		font-size: 0.8em;
		/* padding: 0 0.4em; */
		overflow-x: scroll;
		overflow-y: hidden;
		gap: 0.3em;
		/* position: absolute; */
		/* bottom: -1em; */
		/* left: 0; */
		/* width: var(--card-width); */
		transition: 100ms;
	}
	.tagrow::-webkit-scrollbar {
		display: none;
	}
	.post:has(.CTA) {
		grid-template-areas: 'img title title' 'img summary summary' 'img tags cta';
	}
	.CTA {
		grid-area: cta;
		background: var(--post-color);
		color: white;
		padding: 0.5em;
		border-radius: 1em;
		/* outline: 2px dashed var(--post-color);
		outline-offset: 2px; */
	}
	.post {
		--post-color: var(--2);
		/* position: relative; */
		width: 100%;
		/* max-width: 900px; */
		height: 10.5em;

		display: grid;
		grid-template-areas: 'img title' 'img summary' 'img tags';
		grid-template-columns: 9em 1fr;
		grid-template-rows: auto 1fr 2.4em;
		column-gap: 1em;
		align-items: center;

		margin-inline: auto;
		padding-top: 1.7em;
		padding-right: 1em;
		list-style: none;
		background: white;
		border-radius: 2em;
		box-shadow: 0 0.1em 0.3em rgba(0, 0, 0, 0.1);
		/* overflow: hidden; */
		&.mark {
			--post-color: var(--1);
		}
		&.past {
			opacity: 0.5;
		}
		&.noimg {
			grid-template-columns: 0 1fr;
		}
	}
	.post.calendario {
		height: 13.5em;
	}
	.post.material {
		height: 11.5em;
	}
	a h3 {
		/* display: flex; */
		/* align-items: center; */
		grid-area: title;
		font-size: var(--step-2);
		/* align-self:flex-start; */
		margin: 0;
		margin-top: 0.2em;
		margin-bottom: 0.1em;
		/* text-decoration: underline; */
		text-decoration-color: var(--post-color, var(--2));
		/* margin-left: 1em; */
		small {
			color: var(--post-color, var(--2));
			font-size: 0.7em;
			font-weight: normal;
		}
	}
	/* .time {
		grid-area: time;
	} */
	.tags {
		grid-area: tags;
		max-width: 100%;
		min-width: 0;
		--color: var(--post-color);
		z-index: 3;
		/* cursor:crosshair; */
	}
	.summary {
		grid-area: summary;
		margin: 0;
		padding: 0.2em0;
		align-self: flex-start;
		font-size: var(--step-0);
		display: block;
		max-height: 100%;
		min-height: 0;
		white-space: normal;
		overflow: hidden;
		display: -webkit-box;
		-webkit-box-orient: vertical;
		-webkit-line-clamp: 3;
		line-clamp: 3;
		text-overflow: ellipsis;
	}

	img {
		grid-area: img;
		max-height: calc(100% - 1em);
		max-width: calc(100% - 0em);
		object-fit: contain;
		object-position: center;
		border-radius: 1em;
		margin-left: 1em;
		justify-self: center;
		min-height: 0;
		min-width: 0;
	}
	.publication {
		display: grid;
		grid-auto-flow: column;
		align-items: center;
		justify-content: start;
		background: var(--post-color, var(--2));
		color: whiite;
		position: absolute;
		right: 0;
		left: 0;
		top: 0;
		height: 1.7em;
		padding-inline: 1.5em;
		color: white;
		font-size: var(--step--1);
		border-radius: 2em 2em 0 0;
		--translate: 0 0.1em;
		& > * {
			min-height: 0;
			min-width: 0;
		}
	}
	.calendario .publication {
		grid-template-columns: 2em 1fr auto;
	}
	a {
		color: inherit;
		text-decoration-color: transparent;
		scale: 1;
		transition: 100ms;
	}
	a:hover:not(.past),
	a:focus {
		scale: 1.03;
	}

	@container (max-width: 680px) {
		.post:not(.amigues) {
			grid-template-areas: 'title title' 'img summary' 'img tags';
			grid-template-rows: auto 1fr 2em;
			&:has(.CTA) {
				grid-template-areas:
					'title title title'
					'img summary summary'
					'img tags cta';
			}
			/* &:has(.CTA).noimg {
				grid-template-areas:
					'title title'
					'summary summary'
					'tags cta';
			} */
		}
		:not(.amigues) > h3 {
			align-self: flex-start;
			padding-left: 1em;
			line-height: 1.3;
			height: auto;
			/* justify-self: center; */
			/* padding-top: 0.2em; */
		}
		:not(.amigues) > img {
			max-height: calc(100% - 1em);
		}
	}
</style>

# =============================================
# ARCHIVO: ./src/lib/components/SimpleIcon.svelte
# =============================================

<script>
	// @ts-nocheck
	/** Icon data from SimpleIcon's module import
	 * @type {SimpleIcon}
	 */
	export let icon;
</script>

<svg role="img" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
	<path d={icon.path} />
	<!-- {@html icon.svg.slice(71,-6)} -->
</svg>

<style>
	svg {
		scale: var(--scale, 1);
		translate: var(--translate, 0 0);
		color: var(--color, var(--1));
		fill: var(--color, var(--1));
		/* stroke: var(--color, var(--1)); */
	}
</style>

# =============================================
# ARCHIVO: ./src/lib/components/Tag.svelte
# =============================================

<script>
	//@ts-nocheck
	export let isCheckbox = false;
	export let isLink = false;
	export let tag = '';
	export let icon = '';
	export let name = tag;
	export let checked = false;
	export let noBorder = false;
	/**
	 * @type function
	 */
	export let onInput = () => {
		return;
	};
</script>

{#if isCheckbox}
	<label class="tag" class:checked class:noBorder>
		<input type="checkbox" on:input={onInput} {name} bind:checked tabindex="0" />
		{icon} {tag}
	</label>
{:else if isLink}
	<a class="tag" rel="tag" href="/todo?tags={tag}" class:noBorder>{icon} {tag}</a>
{:else}
	<span class="tag" class:noBorder>
		{icon} {tag}
	</span>
{/if}

<style>
	/*
	
	variables:

		--tag-color
		--border-radius
		--outline-color
		--text-color
		--off-background
		--off-outline
		--off-outline-offset
		--filled-text-color
		--filled-outline
		--filled-outline-offset
		--fill-color
		--text-decoration
		--off-text-decoration

	*/
	.tag {
		padding: var(--padding, 0.3em 0.6em);
		border-radius: var(--border-radius, 2em);
		user-select: none;
		display: inline-block;
		font-size: var(--font-size);
		flex: 1 1;
		text-decoration: var(--text-decoration);
	}
	.tag.noBorder {
		border: 0;
	}

	a.tag,
	label.tag.checked,
	span.tag {
		background: var(--fill-color, var(--tag-color, var(--1)));
		color: var(--filled-text-color, white);
		outline: var(--filled-outline, none);
		outline-offset: var(--filled-outline-offset, 0);
		text-decoration-color: var(--text-decoration, 'none');
	}
	label.tag,
	a.tag {
		cursor: pointer;
	}
	span.tag,
	label.tag {
		border: 1px solid var(--outline-color, var(--tag-color));
		color: var(--text-color, var(--tag-color));
		background: var(--off-background, transparent);
		transition: 0ms;
		outline: var(--off-outline, none);
		outline-offset: var(--off-outline-offset, 0);
	}
	span.tag {
		cursor: unset;
	}
	label.tag:has(:focus) {
		outline: 1px dotted var(--outline-color, var(--tag-color, var(--1))) !important;
		/* scale: 1.05; */
	}
	input {
		border: 0;
		margin: 0;
		padding: 0;
		width: 0;
		height: 0;
		opacity: 0;
		position: absolute;
	}
	a.tag:hover {
		text-decoration: var(--hover-text-decoration, var(--text-decoration), none);
	}
</style>

# =============================================
# ARCHIVO: ./src/lib/components/TagGroup.svelte
# =============================================

<script>
	import { scale } from 'svelte/transition';
	import Tag from './Tag.svelte';
	import { tagManager, visibleTags } from '$lib/utils/stores';
	import { page } from '$app/stores';
	import { onMount } from 'svelte/internal';
	import { togglePositiveTagFilterFn } from '$lib/utils/stores';

	/** @type ProcessedTag */
	export let tag;
	export let gap = false;
	export let nested = true;

	/**@type{(evt: {target: HTMLInputElement}, tag: string)=>*}*/
	export let onInput = (evt, t) => $togglePositiveTagFilterFn(evt.target?.checked, t);

	/** @param {string} tagID
	 *  @return {boolean}
	 */
	function isVisible(tagID) {
		let t = $tagManager.get(tagID);
		return (
			($visibleTags.includes(tagID) ||
				(t?.children && t.children.length > 0 && t.children.some((s) => isVisible(s)))) ??
			false
		);
	}
	let mounted = false;
	onMount(() => (mounted = true));
	let noname =
		tag.noname ||
		!($visibleTags.includes(tag.id) || tag.getAllChildren().some((t) => $visibleTags.includes(t)));
</script>

<div
	in:scale={{ duration: 500 }}
	class="filtergroup"
	style:--tag-color={tag.getColor() ?? 'inherit'}
	class:noname
	class:nested
	class:gap
>
	{#if tag.id && !noname}
		<span in:scale={{ duration: 500 }} class="groupname">
			<Tag
				tag={tag.visible_name + (tag.children && tag.children.length > 0 ? ' »' : '')}
				icon={tag.icon ?? ''}
				name={tag.id}
				noBorder
				isCheckbox
				onInput={(/** @type {{ target: HTMLInputElement; }} */ evt) => onInput(evt, tag.id)}
				checked={$page.url.searchParams.has('tags') &&
					$page.url.searchParams.get('tags')?.split(',').includes(tag.id)}
			/>
		</span>
	{/if}
	{#if tag.children && tag.children.length > 0 && tag.children.some(isVisible)}
		<ul class="groupitems" in:scale={{ duration: 500 }}>
			{#each tag.children.filter(isVisible) ?? [] as item (item)}
				{@const subTag = $tagManager.get(item)}
				<li in:scale={{ duration: 500 }}>
					{#if !subTag?.children || subTag.children.length == 0}
						{#if mounted}
							<Tag
								onInput={(/** @type {{ target: HTMLInputElement; }} */ evt) =>
									onInput(evt, subTag?.id ?? item)}
								tag={item}
								icon={subTag.icon ?? ''}
								isCheckbox
								checked={$page.url.searchParams.has('tags') &&
									$page.url.searchParams.get('tags')?.split(',').includes(item)}
								noBorder
								--off-background="color-mix(in srgb, white 35%, transparent)"
								--text-color="color-mix(in srgb, black 15%, var(--tag-color)"
							/>
						{:else}
							<Tag
								tag={item}
								icon={subTag.icon ?? ''}
								--filled-text-color="var(--text-color, var(--tag-color))"
								--filled-outline="none"
								--filled-outline-offset="0"
								--fill-color="transparent"
							/>
						{/if}
					{:else if subTag}
						<svelte:self tag={subTag} />
					{/if}
				</li>
			{/each}
		</ul>
	{/if}
</div>

<style langs="scss">
	.filtergroup {
		display: flex;
		border-radius: 0.3em;
		flex-direction: column;
		min-width: 0;
		align-items: stretch;
		--border-radius: 0.3em;
		transition: 100ms;
		justify-content: center;
		flex-wrap: wrap;
		width: 100%;
		--text-color: color-mix(in hsl, var(--tag-color) 100%, black);
		--faded-color: color-mix(in srgb, var(--tag-color) 2%, white);
		background: var(--faded-color);
	}
	.filtergroup:has(> .groupname :checked) {
		outline: 3px solid var(--tag-color);
		background: color-mix(in srgb, white 60%, transparent);
	}
	:global(.filtergroup:has(li)),
	:global(.filtergroup:has(span)) {
		box-shadow: -2px 0 var(--tag-color);
		outline: 1px solid color-mix(in srgb, var(--tag-color) 10%, transparent);
	}
	.filtergroup.nested {
		outline-color: var(--tag-color);
	}

	:global(.filterbar > .filtergroup) {
		outline: 2px solid var(--tag-color);
		/* box-shadow: 0 0 0em -0em rgba(0, 0, 0, 0.3); */
	}

	:global(.filterbar .groupitems:has(li)) {
		margin: 0;
		opacity: 1;
	}
	ul {
		justify-content: center;
		flex-wrap: wrap;
		padding: 0;
		max-width: 100%;
	}
	li {
		list-style: none;
		/* text-align: center; */
		display: flex;
		align-items: stretch;
		/* height: 0; */
	}
	:global(.filtergroup .groupitems li:has(li)),
	:global(.filtergroup .groupitems li:has(label)) {
		height: unset;
	}

	.groupname {
		display: flex;
		justify-content: stretch;
		flex: 1 1;
		/* text-align: center; */
	}
	:global(.groupname:has(:checked)) {
		--border-radius: 0.3em 0.3em 0 0;
	}
	.groupitems {
		flex-direction: column;
		row-gap: 1px;
		column-gap: 0.6em;
		justify-content: stretch;
	}
	:global(.groupitems) {
		display: none;
	}
	.groupname:has(:checked) + .groupitems,
	.groupname:has(span) + .groupitems,
	:global(.groupitems:has(:checked)) {
		display: flex;
	}
	:global(.filtergroup:has(:checked)),
	.filtergroup.noname {
		margin-block: 0.5em;
	}
	.filtergroup.gap {
		margin-block-end: 0;
		margin-inline-end: 0.5em;
	}
	.noname > .groupitems {
		display: flex;
	}
	@container (min-width: 1300px) {
		.groupname {
			width: 100%;
		}
		.filtergroup.gap {
			margin-block-end: 0.5em;
			margin-inline-end: 0;
		}
	}
</style>

# =============================================
# ARCHIVO: ./src/lib/components/Tags.svelte
# =============================================

<script>
	import { flip } from 'svelte/animate';
	import { scale } from 'svelte/transition';
	import { onMount } from 'svelte/internal';
	import { filteredTags, tagManager } from '$lib/utils/stores';

	/**@type {string[]}*/
	export let tags;
	export let mark = '';
	export let showFilteredTags = true;
	$: localFilteredTags = (
		mark
			? [...tags.slice(0, tags.indexOf('KinkyVibe')), ...tags.slice(tags.indexOf('KinkyVibe') + 1)]
			: tags
	).filter((t) => showFilteredTags || !$filteredTags.includes(t));
	let invisible = false;
	onMount(() => {
		invisible = false;
	});
</script>

<ul>
	{#each [...new Set(localFilteredTags)] as tag (tag)}
		{@const config = $tagManager.get(tag)}
		{@const color = config?.getColor() ?? 'var(--color,var(--1))'}
		{@const icon = config?.icon ?? ''}
		<li style:--tag-color={color} class:invisible in:scale animate:flip>
			<a href="/todo?tags={tag}" class:card={false}>
				{icon} {tag}
			</a>
		</li>
	{/each}
</ul>

<style>
	.invisible {
		opacity: 0;
		transition: 300ms;
	}
	ul {
		display: flex;
		flex-wrap: wrap;
		gap: 0.2em;
		font-size: 0.8em;
		padding: 0 0.4em;
		overflow-x: scroll;
		overflow-y: hidden;
		justify-content: center;
	}
	ul::-webkit-scrollbar {
		display: none;
	}
	li {
		display: block;
		border-radius: 3em;
		--tag-color: var(--color);
		background: var(--tag-color, var(--1));
		padding: 0.5em 0.8em;
		transition: 50ms;
	}
	a {
		color: white;
		text-decoration: none;
	}
	li:hover {
		text-decoration: underline;
		text-decoration-color: white;
	}
</style>

# =============================================
# ARCHIVO: ./src/lib/components/TagsInput.svelte
# =============================================

<script>
	import { createTagsInput, melt } from '@melt-ui/svelte';
	import { tagManager } from '$lib/utils/stores';
	import { tagSorter } from '$lib/utils';
	export let placeholder = '';
	export let initialTags = [];
	export let inputid = undefined;
    export let onUpdate = (arr) => {};
	const {
		elements: { root, input, tag, deleteTrigger, edit },
		states: { tags },
		helpers: { addTag }
	} = createTagsInput({
		placeholder: placeholder,
		unique: true,
		addOnPaste: true,
		add: (t) => {
			let tagData = $tagManager.get(t);
			return { id: tagData.id, value: tagData.visible_name ?? tagData.id };
		}
	});
    tags.subscribe((ts)=>onUpdate(ts.map((t)=>t.value)))
    // console.log(initialTags)
	initialTags.forEach((t) => addTag(t));
    let sortTags = tagSorter($tagManager);
</script>

<div use:melt={$root}>
	{#each $tags.sort((a,b)=>sortTags($tagManager.get(a.id),$tagManager.get(b.id))) as t}
        {@const tagData = $tagManager.get(t.value)}
		<div
			use:melt={$tag(t)}
			class="tag"
			style:--tag-color={tagData?.getColor() ?? 'var(--color-2,var(--1))'}
		>
			<span class="pill">{tagData?.icon ?? ''} {t.value}</span>
			<button class="pill" use:melt={$deleteTrigger(t)}>x</button>
		</div>
		<div use:melt={$edit(t)}>{t.value}</div>
	{/each}
	<input {inputid} use:melt={$input} placeholder="enter para añadir una etiqueta" type="text" />
</div>

<style>
	.tag {
		display: inline-block;
	}
	.pill {
        line-height:1;
		padding: var(--padding, 0.3em 0.6em);
		border-radius: var(--border-radius, 2em);
		user-select: none;
		display: inline-block;
		font-size: var(--step--1);
		flex: 1 1;

		background: var(--tag-color, var(--1));
		color: white;

		border: 1px solid var(--tag-color);
	}
	span.pill {
		border-bottom-right-radius: 0;
		border-top-right-radius: 0;
        margin-right: 0;
        border-right-width: 0;
	}
	button.pill {
		border-bottom-left-radius: 0;
		border-top-left-radius: 0;
        margin-left: 0;
        border-left-width:0;
	}
    input {
        font-size: var(--step--1);
		position: relative;
		padding: 0.4em 0.8em;
		margin-bottom: 0.5em;
		accent-color: var(--1);
		transition: 100ms;
        
        border-radius: 1em;
		border: 0;
		outline: 1px solid var(--1-light);

		&:focus {
			outline-width: 3px;
		}
		&:invalid {
			outline-color: red;
			outline-width: 2px;
		}
		&:placeholder-shown {
			opacity: 0.5;
		}
    }
    input,.pill {
        margin-top: .4rem;
    }
</style>

# =============================================
# ARCHIVO: ./src/lib/components/UserMenu.svelte
# =============================================

<script>
	import { createDropdownMenu, melt } from '@melt-ui/svelte';
	import { fly } from 'svelte/transition';
	import { page } from '$app/stores';
	/** @type {GHUser} */
	export let user;
	const {
		elements: { trigger, menu, item },
		states: { open }
	} = createDropdownMenu({
		preventScroll:false
	});
	$: isPageEditable = /\/?(amigues|calendario|material)\/.*/.test($page.url.pathname);
	/**
	 *
	 * @param {string} token
	 * @param {string} username
	 * @returns {boolean}
	 */
	function isAdmin(token, username) {
		return ['GorroRojo', 'Tallarines333', 'VelvetVoid'].includes(username);
		// TODO make it read it from github
		// try {
		// 	await ghGet(`repos/GorroRojo/kinkyvibe/collaborators/${username}}`, token)
		// } catch (e) {
		// 	console.log(e)
		// 	return false
		// }
		// return true
	}
	let admin = isAdmin('', user.login);
</script>

<div class="profile-header" use:melt={$trigger}>
	<img src={user.avatar_url} class="profile-pic" alt="" />
	<span id="title" class="profile-name">
		{user.name ?? user.login}
	</span>
	{#if $open}
	<div class="menu" use:melt={$menu} transition:fly={{ duration: 150, y: -10 }}>
		{#if admin}
		<a href="/admin" class="menuitem" use:melt={$item}>Panel de admin</a>
		{#if isPageEditable}
			<!-- TODO handle wikiless wiki links -->
			<a href="/edit{$page.url.pathname}" class="menuitem" use:melt={$item}>Editar contenido</a>
		{:else}
			<span class="menuitem disabled" use:melt={$item}>Editar contenido</span>
		{/if}
		{/if}
		<a href="/logout?redirectTo={$page.url}" class="menuitem" use:melt={$item}>Cerrar sesión</a>
	</div>
	{/if}
</div>

<style lang="scss">
	a {
		text-decoration: none;
	}
	.menu {
		display: flex;
		flex-direction: column;
		background: #fff;
		.menuitem {
			padding: 0.5em 1em;
			width: 100%;
		}
		.disabled {
			opacity: 0.5;
		}
	}
	.profile-header {
		display: flex;
		gap: 0.4em;
		align-items: center;
		font-size: var(--step-0);
		justify-content: start;
		justify-items: start;
		width: max-content;
		max-width: 100%;
	}
	.profile-pic {
		display: block;
		border-radius: 9999em;
		object-fit: cover;
		max-height: 1.5em;
		width: auto;
		justify-self: right;
		aspect-ratio: 1;
		translate: 0 -0em;
	}
	.profile-name {
		margin-right: 1em;
		color: #222;
	}
</style>

# =============================================
# ARCHIVO: ./src/lib/components/body-parts.js
# =============================================

const parts = [
	{
		name: 'head',
		path: 'm 11.671635,6.3585449 -0.0482,-2.59085 4.20648,-2.46806 4.42769,2.95361 -0.0405,1.94408 0.24197,-3.34467 -2.03129,-2.31103004 -2.84508,-0.51629 -2.20423,0.52915 -1.9363,2.63077004 z'
	},
	{
		name: 'face',
		path: 'm 19.748825,6.7034949 0.0203,-2.20747 -3.96689,-2.7637 -3.74099,2.23559 -0.006,2.63528 -0.60741,0.0403 0.27408,1.82447 0.97635,0.33932 0.44244,2.1802901 1.82222,2.06556 2.03518,-0.0607 1.79223,-1.94408 0.35957,-2.2406601 0.97616,-0.33932 0.25159,-1.78416 z'
	},
	{
		name: 'neck',
		path: 'm 13.304665,11.910505 1.64975,2.35202 0.74426,2.62159 -1.73486,-1.38354 -0.86649,-2.97104 z m 5.08047,0 -1.64975,2.35202 -0.74538,2.62234 1.73486,-1.38354 0.86649,-2.97104 z'
	},
	{
		name: 'shoulder-left',
		path: 'm 19.047795,13.248365 3.55748,1.97916 0.72653,-0.35074 z m -0.107,0.43288 -0.37119,1.73073 2.1846,0.53561 1.40116,-0.49436 z m 3.98151,1.97595 0.75814,-0.41 2.40806,1.66799 1.17364,1.50707 0.62662,1.5626 -0.0464,3.70194 -1.3284,-1.72153 0.0407,-2.59376 -0.48842,-0.50049 c 0,0 -3.09778,-3.19058 -3.14371,-3.21401 z m -0.2409,0.10873 c -0.001,0.0525 3.32987,3.54733 3.32987,3.54733 l 0.10067,3.10396 -1.15426,-1.97782 -2.22547,-0.94804 -1.56576,-2.88481 z'
	},
	{
		name: 'shoulder-right',
		path: 'm 12.624785,13.248365 -3.5574599,1.97916 -0.72653,-0.35074 z m 0.107,0.43288 0.37119,1.73073 -2.18459,0.53561 -1.4011499,-0.49436 z m -3.9814899,1.97595 -0.75814,-0.41 -2.40806,1.66799 -1.17364,1.50707 -0.62662,1.56259 0.0464,3.70195 1.3284,-1.72153 -0.0407,-2.59376 0.48843,-0.5005 c 0,0 3.09777,-3.19057 3.1437,-3.214 z m 0.2409,0.10873 c 0.002,0.0525 -3.32987,3.54733 -3.32987,3.54733 l -0.10067,3.10396 1.15426,-1.97782 2.22547,-0.94804 1.5657499,-2.88481 z'
	},
	{
		name: 'arm-left',
		path: 'm 27.621665,30.814715 -0.33838,1.70499 -1.81932,-2.54418 -0.6629,-1.26895 z m -2.85271,-2.6096 c -0.0259,-0.0144 -0.0536,-0.0254 -0.0824,-0.0324 l -1.48333,-4.95503 1.00456,-2.08428 1.65511,1.74532 2.23034,6.67667 0.0415,0.93739 c -1.06528,-0.84215 -2.18962,-1.60679 -3.36434,-2.28803 z m 1.6945,-5.75654 1.64893,6.43421 -0.36469,-4.92266 z'
	},
	{
		name: 'forearm-left',
		path: 'm 26.955425,32.969125 1.30083,10.28927 -1.10778,0.01 -1.89387,-7.99609 0.19174,-4.53719 z m 1.21978,-1.94971 -0.58729,2.58635 1.11876,9.15614 0.55849,-0.21663 0.2304,-6.77018 z'
	},
	{
		name: 'arm-right',
		path: 'm 4.0746451,30.814715 0.33838,1.70499 1.81931,-2.54418 0.66289,-1.26895 z m 2.8527,-2.6096 c 0.0259,-0.0144 0.0536,-0.0254 0.0824,-0.0324 l 1.48332,-4.95503 -1.00455,-2.08428 -1.65509,1.74532 -2.23034,6.67667 -0.0415,0.93739 c 1.06528,-0.84215 2.18961,-1.60679 3.36433,-2.28803 z m -1.6945,-5.75654 -1.64891,6.43421 0.36468,-4.92266 z'
	},
	{
		name: 'forearm-right',
		path: 'm 4.5752651,32.969125 -1.30083,10.28927 1.10778,0.01 1.89387,-7.99609 -0.19174,-4.53719 z m -1.21978,-1.94971 0.58728,2.58635 -1.11875,9.15614 -0.55849,-0.21663 -0.2304,-6.77018 z'
	},
	{
		name: 'chest-left',
		path: 'm 20.337455,17.085495 1.72942,3.09103 1.89346,0.94785 -1.15295,0.90662 -0.90604,2.63773 -2.09968,0.86537 -3.34524,-1.655 0.83425,-6.50527 z'
	},
	{
		name: 'chest-right',
		path: 'm 11.351215,17.085495 -1.7294199,3.09103 -1.89346,0.94785 1.15295,0.90662 0.90586,2.63773 2.0996699,0.86537 3.34636,-1.655 -0.83462,-6.50527 z'
	},
	{
		name: 'belly-left',
		path: 'm 19.641935,34.707615 1.81341,-1.36479 0.15748,1.83347 1.28642,2.37338 -1.98044,2.73652 -1.03109,0.16554 -0.37026,-3.88816 z'
	},
	{
		name: 'ribs-left',
		path: 'm 19.288925,26.151995 -3.11202,-1.40604 0.0937,2.27965 2.80119,1.43603 z m 1.93471,1.66849 -1.29355,0.7212 0.14997,-1.70898 z m -1.05303,-1.63718 2.47968,-1.03241 -0.9336,2.52093 z m 1.53164,1.73729 -1.69005,1.03372 -0.28871,2.0678 1.64975,-1.07533 z m -2.91143,1.10421 -0.0622,1.62387 -2.30308,-0.49961 -0.12448,-2.21722 z m -0.1556,2.4045 0.0311,1.99844 -2.20953,0.59391 -0.0311,-3.1227 z m 2.65459,-0.98535 -1.48383,1.03372 -0.20622,2.10905 1.64862,-1.32355 z'
	},
	{
		name: 'belly-right',
		path: 'm 12.045985,34.707615 -1.81341,-1.36479 -0.15748,1.83347 -1.2856799,2.37432 1.9804499,2.73595 1.03109,0.16554 0.37119,-3.88721 z'
	},
	{
		name: 'belly',
		path: 'm 15.636055,44.919735 -0.60647,-5.91209 -0.015,-3.84879 -2.18479,-1.07533 -0.24746,7.03017 z m 0.41581,-5.7e-4 0.60628,-5.91209 0.0154,-3.84915 2.18404,-1.07515 0.24746,7.03017 z'
	},
	{
		name: 'ribs-right',
		path: 'm 12.399365,26.152365 3.11202,-1.40603 -0.0937,2.27965 -2.80138,1.4364 z m -1.93508,1.6685 1.29355,0.72139 -0.14997,-1.70899 z m 1.05303,-1.637 -2.4793099,-1.03259 0.93361,2.52148 z m -1.5316399,1.73729 1.6900499,1.03372 0.28871,2.06743 -1.64881,-1.07515 z m 2.9114199,1.10421 0.0623,1.62387 2.30327,-0.49961 0.12448,-2.21703 z m 0.15561,2.40432 -0.0309,1.99844 2.20973,0.59353 0.0311,-3.1227 z m -2.6546,-0.98516 1.48384,1.0339 0.20622,2.10905 -1.64975,-1.32355 z'
	},
	{
		name: 'thigh-front-left',
		path: 'm 22.38731,44.12268 -2.75152,6.07258 -0.62015,4.87425 1.16232,6.85771 2.51886,-6.98144 0.15504,-7.18764 z'
	},
	{
		name: 'thigh-outer-left',
		path: 'm 23.419015,50.399125 -0.15504,4.75091 -2.40263,6.60949 0.7362,1.90021 2.36401,-8.34435 z m -0.58154,-11.60825 -0.15485,4.00722 1.31793,7.93154 0.61977,-6.40308 z'
	},
	{
		name: 'innerthigh-left',
		path: 'm 22.063225,39.369605 v 4.21363 l -2.94574,5.82511 -1.86027,5.78349 0.19365,-4.0072 z m -3.24944,13.42596 -0.0649,0.15467 -1.21294,2.90207 0.78325,7.18803 1.23619,-0.66122 -1.0714,-6.69272 z'
	},
	{
		name: 'feet-left',
		path: 'm 17.255895,87.868445 0.1243,3.45228 0.28983,1.20638 h 0.87136 l 0.24897,-0.83181 0.29058,-0.0416 -0.0624,0.83181 1.09914,-0.33332 0.29058,-0.16629 1.24444,-0.27033 0.0416,-0.97748 -1.20319,-2.03743 -0.82974,-1.0399 -2.03294,-0.83181 z'
	},
	{
		name: 'calf-left',
		path: 'm 18.251375,70.441125 0.29058,0.91486 0.6224,3.8681 0.0829,5.15733 -0.87136,5.03304 0.0412,-6.44714 -0.91242,-2.57848 -0.12561,-2.82837 z m 1.9915,2.32915 -0.20753,7.73637 -1.65949,6.23904 1.80478,-0.853 3.00816,-10.83583 -1.03727,-6.82095 z'
	},
	{
		name: 'knee-left',
		path: 'm 21.404635,64.784375 0.1243,1.12295 -0.87118,1.08171 -0.29058,1.70599 -0.58116,0.24933 -0.49774,-2.57866 -0.33182,-0.91486 0.29058,-0.58247 z m -3.85853,0.0832 0.6224,1.74685 1.3273,2.57867 -0.33182,2.37095 -0.95423,-2.66209 -0.78738,-1.49734 z m 4.97811,-2.37039 -0.95423,5.11609 0.62241,-0.33295 0.49773,1.66381 z'
	},
	{
		name: 'thigh-outer-right',
		path: 'm 8.2694651,50.399125 0.15504,4.75053 2.4026299,6.60968 -0.73638,1.90021 -2.3640099,-8.34435 z m 0.58117,-11.60768 0.15503,4.00684 -1.31754,7.93154 -0.61978,-6.40308 z'
	},
	{
		name: 'thigh-front-right',
		path: 'm 9.38769,44.1223 2.7515099,6.07239 0.61997,4.87425 -1.16232,6.85771 -2.5190499,-6.98163 -0.15504,-7.18801 z'
	},
	{
		name: 'genitalia',
		path: 'm 14.404465,45.040075 0.0221,-0.0277 -0.14866,-0.37945 -3.10172,-3.40449 -0.23283,-0.0825 2.05918,5.32009 z m -1.17263,2.01833 1.27705,3.29948 0.42631,-4.04862 -0.25196,-0.64303 z m 4.05219,-2.01795 -0.0221,-0.0281 0.14867,-0.37926 3.10171,-3.40449 0.23246,-0.0825 -2.05843,5.3199 z m 1.17263,2.01795 -1.27706,3.29948 -0.42631,-4.04843 0.25197,-0.64303 z'
	},
	{
		name: 'innerthigh-right',
		path: 'm 9.6258251,39.369415 v 4.21363 l 2.9451699,5.8253 1.86028,5.78349 -0.19366,-4.0072 z m 3.2488699,13.42559 0.0647,0.15485 1.21294,2.90207 -0.78307,7.18803 -1.23618,-0.66102 1.0714,-6.69273 z'
	},
	{
		name: 'feet-right',
		path: 'm 14.433335,87.868265 -0.12448,3.45228 -0.29058,1.20637 h -0.87118 l -0.24877,-0.83181 -0.29059,-0.0416 0.0623,0.83181 -1.09934,-0.33333 -0.29058,-0.16629 -1.2448,-0.27033 -0.0412,-0.97747 1.2031899,-2.03781 0.82975,-1.04009 2.03294,-0.83181 z'
	},
	{
		name: 'calf-right',
		path: 'm 13.437675,70.440945 -0.29058,0.91486 -0.62241,3.86828 -0.0829,5.15733 0.87174,5.03304 -0.0418,-6.44714 0.91298,-2.57848 0.1243,-2.82837 z m -1.99151,2.32914 0.20735,7.73637 1.65968,6.23904 -1.80497,-0.85299 -3.0079799,-10.83584 1.03728,-6.82095 z'
	},
	{
		name: 'knee-right',
		path: 'm 10.284405,64.784375 -0.12448,1.12295 0.87118,1.08171 0.29058,1.70599 0.58116,0.24933 0.49774,-2.57866 0.33182,-0.91486 -0.29058,-0.58247 z m 3.85854,0.0832 -0.62241,1.74685 -1.32767,2.57867 0.33182,2.37095 0.95423,-2.66209 0.78832,-1.4964 z m -4.9786799,-2.37058 0.9542299,5.11609 -0.6223999,-0.33313 -0.49793,1.6638 z'
	},
	{
		name: 'elbow-right',
		path: 'm 3.2054751,27.370125 0.005,3.09419 -0.57959,1.91184 -0.54539,-2.41185 z'
	},
	{
		name: 'hand-right',
		path: 'm 4.3904451,43.563145 -1.5198,0.0506 -0.76631,-0.67112 -1.21261996,2.15767 -0.86245,3.32873 0.49386,0.22113 0.59814996,-2.20238 0.50016,0.25356 -0.35639,2.49422 0.62382,0.24345 0.41402,-2.49194 0.55839,0.17851 -0.2262,2.76603 0.76938,0.32268 0.25788,-2.86764 0.4578,-0.0181 0.16611,2.65239 0.65997,0.2633 0.0712,-4.56643 0.34158,-0.19428 1.35316,1.68367 0.32832,-0.34354 -0.72644,-2.0551 z'
	},
	{
		name: 'elbow-left',
		path: 'm 28.325215,27.370125 -0.005,3.09419 0.57959,1.91184 0.54538,-2.41185 z'
	},
	{
		name: 'hands-left',
		path: 'm 27.140245,43.563145 1.5198,0.0506 0.76631,-0.67111 1.21262,2.15766 0.86245,3.32873 -0.49386,0.22113 -0.59815,-2.20238 -0.50016,0.25356 0.35639,2.49422 -0.62382,0.24345 -0.41402,-2.49194 -0.55839,0.17851 0.2262,2.76603 -0.76938,0.32268 -0.25788,-2.86764 -0.4578,-0.0181 -0.16611,2.6524 -0.65997,0.26329 -0.0712,-4.56643 -0.34158,-0.19428 -1.35316,1.68368 -0.32832,-0.34355 0.72644,-2.0551 z'
	},
	{
		name: 'armback-left',
		path: 'm 43.185645,27.069445 0.4297,-1.4164 1.30458,-1.68577 -1.39393,-2.96155 -2.28367,0.92162 -1.83567,1.7467 -0.53524,1.78673 0.27068,4.30806 z m -2.46869,15.35539 -1.5182,0.0863 -0.78184,-0.65295 -1.16168,2.1855 -0.78414,3.34805 0.49892,0.20949 0.54632,-2.2158 0.50597,0.24175 -0.29779,2.5019 0.62936,0.22875 0.35546,-2.50096 0.56242,0.16536 -0.16126,2.77057 0.77674,0.30455 0.19056,-2.87291 0.45724,-0.0289 0.22827,2.64778 0.66597,0.24774 -0.0359,-4.56685 0.33693,-0.20224 1.39227,1.65147 0.32017,-0.35115 -0.77444,-2.03749 z m -0.97726,-0.17765 -1.43509,-0.746 -0.30622,-7.00985 c 0,0 0.64359,-2.77938 0.63694,-3.06274 l 0.6093,-1.21924 3.62552,-2.56583 -0.68276,1.9919 0.41561,4.74788 -1.80402,7.69727 z'
	},
	{
		name: 'leg-left',
		path: 'm 51.176145,64.073985 -1.20605,3.01461 0.70738,0.26558 0.89754,3.51771 -0.55801,-4.01191 z m -5.08496,-3.15003 0.63355,1.8609 0.16813,2.03261 0.61314,1.93117 -0.90585,-0.0851 -0.28534,2.15982 z m 4.3014,6.58834 1.27664,4.99697 -0.28984,3.02284 -0.67869,10.06546 -1.66325,0.63506 -3.50399,-11.96959 1.24985,-7.17525 z m 0.54053,20.8287 0.85194,1.3581 0.37189,0.79238 -0.15588,1.21774 -0.76984,0.74446 -1.51185,0.12543 -1.1299,-0.29192 -0.24225,-0.95894 0.80765,-1.30405 -0.22562,-0.85987 0.29679,-0.84153 -0.0194,-1.81524 1.53568,-0.54817 z m -1.19598,0.4675 0.15943,1.25776 -0.6023,0.97431 m -0.54436,0.29544 1.06474,0.40084 1.55326,-0.65137 m -4.19331,-39.53466 4.55099,-2.03879 0.63802,0.23079 0.0353,1.80672 0.075,4.64669 -1.97837,6.04282 0.47612,1.41403 -1.42812,3.29446 -1.76611,-0.30111 -0.50079,-2.11605 -0.1695,-1.75674 -2.42102,-8.15763 -0.34279,-3.64687 z'
	},
	{
		name: 'buttock',
		path: 'm 44.742845,39.689035 5.48374,1.86457 2.27386,1.3378 2.74195,-1.74412 4.51804,-1.28077 0.90009,2.29721 0.675,3.4346 -0.81272,5.02838 -2.82636,0.16819 -4.11256,-1.67581 -1.00814,0.39118 -0.95849,-0.39888 -4.44053,1.94411 -2.77023,-0.51478 -0.95181,-6.15325 0.36754,-2.7864 z'
	},
	{
		name: 'loin',
		path: 'm 51.818445,37.309575 0.14418,2.97292 1.15984,-0.0241 0.048,-2.96488 2.80867,-0.81981 2.34029,-0.7541 1.34121,3.73319 -4.77886,1.36455 -2.33301,1.2158 -2.37536,-1.2333 -5.45663,-1.37716 1.51961,-3.95743 z'
	},
	{
		name: 'column',
		path: 'm 51.733705,14.788555 0.53876,25.33066 0.48967,-0.0297 0.65658,-25.3387 -0.28147,-0.84188 -1.25059,-4.9e-4 z'
	},
	{
		name: 'head-back',
		path: 'm 48.157455,6.3585449 0.44208,-0.14964 0.16111,0.16427 1.48163,4.0475101 2.32401,1.45118 2.39971,-1.52387 0.97577,-3.6896901 0.52752,-0.55908 0.23367,0.0981 0.24198,-3.34467 -2.03129,-2.31103004 -2.84509,-0.51629 -2.20422,0.52915 -1.93631,2.63077004 z'
	},
	{
		name: 'nape',
		path: 'm 52.369695,12.105075 -2.35767,-1.55045 -1.47119,-3.9514301 -0.60741,0.0403 0.27409,1.82447 0.97635,0.33932 0.7613,2.2157201 0.33017,1.06849 0.0895,2.14894 1.16448,0.008 0.10563,-0.70833 0.54716,-0.0606 z m 1.01793,1.47595 0.23768,0.64982 1.38107,-0.004 0.01,-2.38784 0.25971,-0.79061 0.57215,-2.1698001 0.76359,-0.41018 0.25158,-1.78416 -0.62859,0.0193 -1.08488,3.8998101 -2.39725,1.46684 0.2768,1.48507 z'
	},
	{
		name: 'armback-right',
		path: 'm 61.657445,27.250625 -0.32785,-1.05121 -1.27383,-2.05489 1.38708,-2.96476 2.28579,0.91634 1.83971,1.74245 0.53937,1.78549 -0.26073,4.30868 z m 2.64394,15.3417 1.51839,0.0828 0.78033,-0.65476 1.16673,2.18281 0.79187,3.34623 -0.49843,0.21064 -0.55144,-2.21453 -0.50541,0.24292 0.30356,2.5012 -0.62882,0.23021 -0.36124,-2.50014 -0.56203,0.16666 0.16765,2.77019 -0.77603,0.30634 -0.19719,-2.87245 -0.45732,-0.0278 -0.22215,2.64829 -0.66539,0.24928 0.0254,-4.56692 -0.3374,-0.20146 -1.38845,1.65469 -0.32098,-0.35041 0.76973,-2.03928 z m 0.97685,-0.1799 1.43335,-0.74932 0.29002,-7.01054 c 0,0 -0.65,-2.77789 -0.64401,-3.06126 l -0.61212,-1.21783 -3.98124,-2.57566 1.0222,1.93525 -0.38967,4.82212 1.8218,7.69308 z'
	},
	{
		name: 'leg-right',
		path: 'm 54.019305,64.073985 1.20605,3.01461 -0.70737,0.26558 -0.89755,3.51771 0.55802,-4.01191 z m 5.08496,-3.15003 -0.63355,1.8609 -0.16813,2.03261 -0.61313,1.93117 0.90584,-0.0851 0.28534,2.15982 z m -4.3014,6.58834 -1.27664,4.99697 0.28984,3.02284 0.67869,10.06546 1.66325,0.63506 3.504,-11.96959 -1.24986,-7.17525 z m -0.54053,20.8287 -0.85194,1.3581 -0.37189,0.79238 0.15589,1.21774 0.76983,0.74446 1.51186,0.12543 1.12989,-0.29192 0.24225,-0.95894 -0.80765,-1.30405 0.22563,-0.85987 -0.29679,-0.84153 0.0194,-1.81524 -1.53568,-0.54817 z m 1.19598,0.4675 -0.15943,1.25776 0.6023,0.97431 m 0.54436,0.29544 -1.06474,0.40084 -1.55326,-0.65137 m 3.56525,-39.90247 -3.97962,-1.70224 -0.56389,0.27131 -0.0528,1.79746 -0.075,4.64669 1.97837,6.04282 -0.47612,1.41403 1.42813,3.29446 1.7661,-0.30111 0.50079,-2.11605 0.1695,-1.75674 2.42102,-8.15763 0.009,-3.68308 z'
	},
	{
		name: 'back-right',
		path: 'm 62.863315,16.685695 1.57473,1.56518 0.81404,2.06904 0.0384,2.52859 -1.48921,-1.23926 -2.76223,-1.15539 -1.84691,3.4342 -1.13679,5.49715 -0.0767,5.8593 -4.07066,1.10938 0.10355,-7.94098 1.94107,-4.90021 5.04395,-8.19335 z'
	},
	{
		name: 'clavicule-right',
		path: 'm 55.439085,14.728535 -0.063,-2.62463 0.71441,1.15181 4.37994,1.49796 -4.97857,8.36746 -1.83043,5.08189 0.21949,-13.55362 z'
	},
	{
		name: 'back-left',
		path: 'm 42.200945,16.586495 -1.57473,1.56517 -0.81404,2.06905 -0.38603,2.52859 1.83679,-1.23927 2.76223,-1.15538 1.84691,3.4342 1.13679,5.49715 0.0767,5.8593 4.07066,1.10938 -0.10355,-7.94098 -1.94107,-4.90022 -5.04395,-8.19334 z'
	},

	{
		name: 'clavicule-left',
		path: 'm 49.625175,14.629325 0.063,-2.62462 -0.71441,1.15181 -4.37994,1.49796 4.97857,8.36746 1.83043,5.08188 -0.21949,-13.55362 z'
	}
];

export default parts;

# =============================================
# ARCHIVO: ./src/lib/external/github.js
# =============================================

import { Buffer } from 'buffer';
/**
 * Sends a request to the GitHub API using the specified method and token.
 *
 * @param {string} endpoint - The method to be used in the API request.
 * @param {string} token - The token to be used for authentication.
 * @return {Promise<*>} A promise that resolves with the response data from the API.
 * @throws {Error} If the API request fails, an error is thrown with the corresponding status and status text.
 */
export async function ghGet(endpoint, token) {
	let response = await fetch('https://api.github.com/' + endpoint, {
		headers: {
			'User-Agent': 'GorroRojo',
			Accept: 'application/json',
			Authorization: `Bearer ${token}`
		}
	});
	if (response.ok) {
		let ret = response.json();
		return ret;
	} else {
		console.log(`GitHub API Error when getting ${endpoint}: ${response.status} ${response.statusText}`)
	}
}

/**
 * Sends a PUT request to the GitHub API with the specified endpoint, token, and body.
 *
 * @param {string} endpoint - The endpoint to send the PUT request to.
 * @param {string} token - The authentication token to include in the request header.
 * @param {string} body - The body of the PUT request.
 * @param {string} sha
 * @return {Promise<*>} - A promise that resolves to the response from the GitHub API.
 */
export async function ghPut(endpoint, token, body, sha, userName = 'admin', category = '', postID = '') {
	let response = await fetch('https://api.github.com/' + endpoint, {
		method: 'PUT',
		headers: {
			'User-Agent': 'GorroRojo',
			Accept: 'application/json',
			Authorization: `Bearer ${token}`
		},
		body: JSON.stringify({
			message: `[admin] ${userName} updated ${category}/${postID}`,
			content: Buffer.from(body, 'utf-8').toString('base64'),
			sha: sha
		})
	});
	if (response.ok) {
		let ret = response.json();
		return ret;
	} else {
		throw new Error(
			`GitHub API Error when putting ${endpoint}: ${response.status} ${response.statusText}`
		);
	}
}
export default ghGet;

# =============================================
# ARCHIVO: ./src/lib/styles/style.scss
# =============================================

:root {
	--1: hsl(319, 90%, 60%);
	--2: hsl(262, 90%, 60%);
	--3: hsl(165, 84%, 45%);
	--4: hsl(50, 100%, 60%);
	--1-light: hsl(319, 100%, 70%);
	--2-light: hsl(262, 100%, 75%);
	--3-light: hsl(165, 84%, 65%);
	--4-light: hsl(50, 100%, 70%);
	--1-dark: hsl(319, 100%, 40%);
	--2-dark: hsl(262, 90%, 50%);
	--3-dark: hsl(165, 84%, 30%);
	--4-dark: hsl(50, 100%, 40%);

	/** Fluid type **/
	/* @link https://utopia.fyi/type/calculator?c=320,18,1.2,1240,20,1.25,5,2,&s=0.75|0.5|0.25,1.5|2|3|4|6,s-l&g=s,l,xl,12 */

	--step--2: clamp(0.78rem, calc(0.77rem + 0.03vw), 0.8rem);
	--step--1: clamp(0.94rem, calc(0.92rem + 0.11vw), 1rem);
	--step-0: clamp(1.13rem, calc(1.08rem + 0.22vw), 1.25rem);
	--step-0-5: clamp(1.24rem, calc(1.18rem + 0.29vw), 1.4rem);
	--step-1: clamp(1.35rem, calc(1.28rem + 0.37vw), 1.56rem);
	--step-2: clamp(1.62rem, calc(1.5rem + 0.58vw), 1.95rem);
	--step-3: clamp(1.94rem, calc(1.77rem + 0.87vw), 2.44rem);
	--step-4: clamp(2.33rem, calc(2.08rem + 1.25vw), 3.05rem);
	--step-5: clamp(2.8rem, calc(2.45rem + 1.77vw), 3.82rem);

	--round: 1rem;
}
@font-face {
	font-family: NotoColorEmojiLimited;
	unicode-range: U+1F1E6-1F1FF;
	src: url(https://raw.githack.com/googlefonts/noto-emoji/main/fonts/NotoColorEmoji.ttf);
}
body {
	scroll-behavior: smooth;
	margin: 0;
	background: #eee;
	color: #333;
	font-family: 'NotoColorEmojiLimited', 'Lato', sans-serif;
	// font-size: var(--step-0);
	position: relative;
	min-height: 99vh;
	box-sizing: border-box;
}
html {
	overflow-x: hidden;
}
html,
body,
* {
	scroll-behavior: smooth;
	-webkit-tap-highlight-color: transparent;
}

*:not(code *) {
	box-sizing: border-box;
}

a {
	text-decoration-color: var(--color, var(--1));
	color: unset;
	&:hover {
		color: var(--color, var(--1));
	}
}

/** post formatting **/
article {
	padding: 10px;
}
article h1,
article address {
	width: 100%;
	max-width: 50rem;
	margin-inline: auto;
	margin-top: 0;
	text-align: center;
}
article h1 {
	font-size: var(--step-5);
	max-width: 70rem;
	margin-bottom: 0.3em;
	text-align: center;
}
article address {
	font-size: var(--step-0);
}

article.wiki {
	h1 {
		text-align: left;
		max-width: calc(var(--step-0) * 40);
		margin-bottom: 0;
	}
}

.content {
	width: 100%;
	position: relative;
	margin-inline: auto;
	margin-top: 2em;
	overflow-x: visible;
	padding-inline: 5px;

	& > * {
		max-width: calc(var(--step-0) * 40);
		width: 100%;
		margin-inline: auto;
		font-size: var(--step-0);
		display: block;
	}
	hr {
		margin-block: 3rem;
	}
	h1,
	h2,
	h3,
	h4,
	h5,
	h6 {
		position: relative;
	}
	h1 {
		font-size: var(--step-4);
		margin-bottom: 0.2em;
	}
	h2 {
		font-size: var(--step-3);
	}
	h3 {
		font-size: var(--step-2);
	}
	h4 {
		font-size: var(--step-1);
	}
	h5,
	h6 {
		font-size: var(--step-0);
	}
	h6 {
		font-size: var(--step-0);
	}
	sup {
		line-height: 0;
		font-size: var(--step--1);
		color: var(--2-dark);
		font-weight: bold;
	}
	p,
	li {
		line-height: 1.5;
	}
	li {
		position: relative;
		margin-block: 1em;
	}
	ul li {
		list-style: none;
		&::before {
			position: absolute;
			left: -1em;
			content: '+ ';
			color: var(--2);
		}
		li {
			margin-block: 0.4em;
			&::before {
				content: '|';
				color: var(--1);
			}
		}
	}
	ol li::marker {
		color: var(--2);
		// font-weight: bold;
	}

	strong {
		color: var(--2);
		font-weight: black;
	}
	h1 strong,
	h2 strong,
	h3 strong,
	h4 strong,
	h5 strong,
	h6 strong {
		color: var(--2);
	}
	small {
		font-size: var(--step-0);
		opacity: 0.8;
		&.p-pronoun {
			font-size: var(--step--2);
			text-decoration: none;
			display: inline-block;
			background: transparent;
			color: var(--1);
			border: 1px solid var(--1);
			padding: 0.05em 0.3em;
			border-radius: 0.3em;
			margin-left: 0.2em;
			position: relative;
			bottom: 0.05em;
		}
	}
	pre,
	code {
		background: var(--3);
	}
	pre {
		padding: 1em;
		border-radius: 1em;
		box-shadow: inset 0 0 1em rgba(1, 1, 1, 0.1);
		overflow-x: auto;
	}
	code {
		padding: 0.1em 0.4em;
		border-radius: 0.4em;
		font-family: 'Courier New', Courier, monospace !important;
		font-size: var(--step-0);
		span.token {
			font-family: 'Courier New', Courier, monospace !important;
		}
	}
	img,
	video,
	figure {
		margin-inline: auto;
		position: relative;
		width: 100%;
		object-fit: contain;
		object-position: center;
		border-radius: 1em;
		max-width: 900px;
		max-height: 90vh;
		figcaption {
			text-align: center;
			opacity: 0.9;
			font-style: italic;
			font-size: var(--step--1);
		}
	}
	figure {
		margin-bottom: 3rem;
	}
	blockquote {
		font-size: var(--step-0);
		opacity: 0.9;
		margin-block: 0;
		padding-left: 1em;
		border-left: 2px solid var(--1);
		p {
			margin-block: 0;
		}
	}
	* + blockquote {
		margin-top: 1em;
	}
	blockquote + blockquote {
		margin-top: 0;
		padding-top: 1em;
	}
	dl {
		div {
			dt {
				font-weight: bold;
			}
			dd {
				position: relative;
				border-left: 1px solid color-mix(in srgb, var(--color, var(--1)) 30%, transparent);
				padding-left: 0.7em;
				translate: -0.7em;
				dl {
					margin-top: 0;
				}
				span + dl {
					margin-top: 0.4em;
				}
			}
			dd::before {
				translate: 0.7em;
				position: absolute;
				left: -1.2em;
				top: -0.2em;
				content: '┗ ';
				color: var(--1);
				opacity: 0.5;
			}
			&:has(dd) + div {
				margin-top: 0.2em;
			}
		}
	}
	.toc {
		display: none;
		background: color-mix(in srgb, var(--1-light) 10%, transparent);
		padding: 0.5em;
		font-size: var(--step-0);
		li {
			margin: 0;
		}
		&:has(li) {
			display: block;
		}
	}

	.col-2,
	.col-3,
	.col-4 {
		display: grid;
		gap: 0.5em;
		margin-block: 1em;
		/* margin-inline: -4em; */
		max-width: 900px;
	}
	.col-2 {
		grid-template-columns: 1fr 1fr;
	}
	.col-3 {
		grid-template-columns: 1fr 1fr 1fr;
	}
	.col-4 {
		grid-template-columns: 1fr 1fr 1fr 1fr;
	}

	.backtotop,
	.linktothis {
		opacity: 0.15;
		text-decoration: none;
		&:hover {
			opacity: 0.3;
		}
	}
	.backtotop {
		margin-left: 0.2em;
		svg {
			height: auto;
			width: 1ch;
		}
	}
	.linktothis {
		position: absolute;
		opacity: 0.1;
		right: 100%;
		font-weight: 400;
		padding-right: 0.2em;
		transform-origin: right;
		scale: 0.7;
	}
	.cta {
		background: var(--1);
		padding: 0.5em 1em;
		color: white;
		font-weight: bold;
		border-radius: 0.3em;
		margin-inline: auto;
		display: block;
		width: max-content;
		text-align: center;
		/* translate: 6em; */
		font-size: var(--step-3);
		text-decoration: none;
		margin-block: 2em;
		transition: 200ms;
		box-shadow: 0 0 0 0;
		&:hover {
			scale: 1.1;
			box-shadow: 0.6em 0.6em 1em rgba(0, 0, 0, 0.1);
		}
	}
}
@media (max-width: 900px) {
	.col-2,
	.col-3,
	.col-4 {
		margin-inline: 0;
	}
}
img.placeholder-gradient {
	position: relative;
	width: 100%;
	height: 100%;
}
img.placeholder-gradient::after {
	content: ' ';
	display: block;
	height: 100%;
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	background: linear-gradient(
		to bottom right,
		color-mix(in srgb, var(--post-color, var(--2)) 70%, white) 0%,
		var(--post-color, var(--2)) 50%,
		color-mix(in srgb, var(--post-color, var(--2)) 70%, black) 100%
	);
}
a,
button {
	cursor: pointer;
}

# =============================================
# ARCHIVO: ./src/lib/types.d.js
# =============================================

/**
 * @typedef { 'head' |'face' |'neck' |'shoulder-left' |'shoulder-right' |'arm-left' |'forearm-left' |'arm-right' |'forearm-right' |'chest-left' |'chest-right' |'belly-left' |'ribs-left' |'belly-right' |'belly' |'ribs-right' |'thigh-left' |'innerthigh-left' |'feet-left' |'calf-left' |'knee-left' |'thigh-right' |'genitalia' |'innerthigh-right' |'right-feet' |'calf-right' |'knee-right' |'elbow-right' |'hand-right' |'elbow-left' |'hands-left' |'armback-left' |'leg-left' |'buttock' |'loin' |'column' |'head-back' |'nape' |'armback-right' |'leg-right' |'back-right' |'clavicule-right' |'back-left' |'clavicule-left'|string  } BodyPart
 */
/**@typedef Group
 * @prop {string} name
 * @prop {string[]} [members]
 * @prop {Group[]} sub
 * @prop {boolean} [noname]
 * @prop {string} [color]
 * @prop {string} [parent]
 */

/** @typedef TagProps
 * @prop {string} [aliasOf]
 * @prop {string} [color]
 */

/** @typedef {string} TagID */
/** @typedef {string} postID */

/**
 * @typedef {Object} RawTag
 * @prop {TagID} id
 * @prop {string} [icon]
 * @prop {string} [visible_name]
 * @prop {string} [color]
 * @prop {string} [description]
 * @prop {TagID[]} [related]
 * @prop {string[]} [aka]
 * @prop {TagID} [aliasOf]
 * @prop {TagID[]} [children]
 * @prop {postID} [entry]
 * @prop {boolean} [noname]
 * */

/**
 * @typedef {RawTag & {
 *      getColor: ()=>(string|undefined),
 *      getAllChildren: ()=>(TagID[]),
 *      getAllParents: ()=>(TagID[]),
 *      cleanDescription?: string,
 *      parsedDescription?: Array<{line: string, type: "text"|"link"|"mark", href?: string}>,
 *      parents?: TagID[],
 *      orphan?: boolean
 * }} ProcessedTag
 */
/**@typedef TagManager
 * @prop {(tagID: TagID, fallbackData?: *)=>(ProcessedTag)} get
 * @prop {()=>([TagID, ProcessedTag][])} entries
 * @prop {()=>(TagID[])} tagIDs
 * @prop {()=>(ProcessedTag[])} tagsData
 * @prop {(tagID: TagID, value: RawTag)=>void} set
 * @prop {(tagID: TagID)=>void} delete
 * @prop {string[]} missingTags
 */

/**@typedef List
 * @prop {string[]|Group[]} items
 * @prop {string} classname
 * @prop {boolean} visible
 * */

/** @typedef PostData
 * @prop {string} postID
 * @prop {string} title
 * @prop {string} summary
 * @prop {string[]} tags
 * @prop {'material'|'calendario'|'amigues'|'wiki'} category
 * @prop {'material'|'calendario'|'amigues'} layout
 * @prop {string[]} authors
 * @prop {string} [featured]
 * @prop {string} [published_date]
 * @prop {string} [updated_date]
 * @prop {boolean} [force_unlisted]
 * @prop {boolean} [force_unpublished]
 */
/** @typedef {PostData & {
 * 		type: 'descargable' | 'link' | 'contenido',
 * 		link: string,
 * 		access_date: Date,
 * 		original_published_date: Date
 *      redirect: boolean
 *      wiki?: string
 * }} MaterialPostData
 */
/** @typedef {PostData & {
 *		status: 'abierto' | 'anunciado' | 'agotadas' | 'cancelado',
 * 		start: string,
 * 		end?: string,
 * 		duration?: Date,
 * 		location?: string,
 * 		location_name?: string,
 * 		link?: URL
 * 		link_text?: string
 * }} CalendarioPostData */
/** @typedef {PostData & {
 * 		pronoun: string,
 * 		link: URL,
 * 		logo?: string,
 * 		photo?: string,
 * 		email?: string,
 * 		location?: string,
 * 		tel?: string,
 * 		job_title?: string,
 * 		job_role?: string,
 * 		gender_identity?: string | URL,
 * 		bday?: Date,
 * }} AmiguesPostData */
// TODO affiliation, education, experience, skill

/**
 * @typedef ProcessedPost
 * @prop {string} path
 * @prop {AnyPostData} meta
 * @prop {ConstructorOfATypedSvelteComponent|undefined} [content]
 * @prop {ProcessedPost[]} [authorsProfiles]
 * @prop {ProcessedPost[]} [relatedPosts]
 */
/** @typedef {AmiguesPostData & MaterialPostData & CalendarioPostData} AnyPostData */

/**
 * @typedef {import('schema-dts').Thing | import('schema-dts').WithContext<import('schema-dts').Thing>} LD.Schema
 */
/** @typedef {import('schema-dts').Organization} LD.Organization */
/** @typedef {import('schema-dts').WebSite} LD.Website */
/** @typedef {import('schema-dts').Article} LD.Article */
/** @typedef {import('schema-dts').Event} LD.Event */
/** @typedef {import('schema-dts').EventSeries} LD.EventSeries */
/** @typedef {import('schema-dts').Person} LD.Person */
/** @typedef {import('schema-dts').ProfilePage} LD.ProfilePage */
/** @typedef {import('schema-dts').EventVenue} LD.EventVenue */
/** @typedef {import('schema-dts').Book} LD.Book */
/** @typedef {import('schema-dts').BreadcrumbList} LD.BreadcrumbList */
/** @typedef {import('schema-dts').ClaimReview} LD.ClaimReview */
/** @typedef {import('schema-dts').FAQPage} LD.FAWPage */
/** @typedef {import('schema-dts').SpeakableSpecification} LD.SpeakableSpecification */
/** @typedef {import('schema-dts').SearchAction} LD.SearchAction */
/**
 * @typedef {Object} GHUser
 * @property {string} login
 * @property {number} id
 * @property {string} node_id
 * @property {string} avatar_url
 * @property {string} gravatar_id
 * @property {string} url
 * @property {string} html_url
 * @property {string} followers_url
 * @property {string} following_url
 * @property {string} gists_url
 * @property {string} starred_url
 * @property {string} subscriptions_url
 * @property {string} organizations_url
 * @property {string} repos_url
 * @property {string} events_url
 * @property {string} received_events_url
 * @property {string} type
 * @property {boolean} site_admin
 * @property {string} name
 * @property {null|string} company
 * @property {string} blog
 * @property {string} location
 * @property {string} email
 * @property {boolean} hireable
 * @property {null|string} bio
 * @property {null|string} twitter_username
 * @property {number} public_repos
 * @property {number} public_gists
 * @property {number} followers
 * @property {number} following
 * @property {string} created_at
 * @property {string} updated_at
 */
# =============================================
# ARCHIVO: ./src/lib/utils/customRehype.js
# =============================================

import { SKIP, visit } from 'unist-util-visit';
import { headingRank } from 'hast-util-heading-rank';
import { hasProperty } from 'hast-util-has-property';
import { findAndReplace } from 'hast-util-find-and-replace';
import { h } from 'hastscript';

const cornerRightUpIcon = {
	// <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-corner-right-up">
	type: 'element',
	tagName: 'svg',
	properties: {
		xmlns: 'http://www.w3.org/2000/svg',
		width: '24',
		height: '24',
		viewBox: '0 0 24 24',
		fill: 'none',
		stroke: 'currentColor',
		'stroke-width': '2',
		'stroke-linecap': 'round',
		'stroke-linejoin': 'round',
		class: 'lucide lucide-corner-right-up'
	},
	children: [
		// <polyline points="10 9 15 4 20 9"/>
		{
			type: 'element',
			tagName: 'polyline',
			properties: {
				points: '10 9 15 4 20 9'
			},
			children: []
		},
		// <path d="M4 20h7a4 4 0 0 0 4-4V4"/>
		{
			type: 'element',
			tagName: 'path',
			properties: {
				d: 'M4 20h7a4 4 0 0 0 4-4V4'
			},
			children: []
		}
	]
};
//<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-link"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>
const linkIcon = {
	type: 'element',
	tagName: 'svg',
	properties: {
		xmlns: 'http://www.w3.org/2000/svg',
		width: '24',
		height: '24',
		viewBox: '0 0 24 24',
		fill: 'none',
		stroke: 'currentColor',
		'stroke-width': '2',
		'stroke-linecap': 'round',
		'stroke-linejoin': 'round',
		class: 'lucide lucide-link'
	},
	children: [
		{
			type: 'element',
			tagName: 'path',
			properties: {
				d: 'M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71'
			},
			children: []
		},
		{
			type: 'element',
			tagName: 'path',
			properties: {
				d: 'M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71'
			},
			children: []
		}
	]
};
/**
 * Plugin to add `id`s to headings.
 *
 * @type {import('unified').Plugin<[import('rehype-slug').Options?]|Array<void>, import('rehype-slug').Root>}
 */
export default function customRehype() {
	return (tree) => {
		// eslint-disable-next-line no-unused-vars
		visit(tree, 'element', (node, _index, _parent) => {
			if (headingRank(node) && hasProperty(node, 'id')) {
				node.children.unshift({
					type: 'element',
					tagName: 'a',
					properties: { href: '#' + node.properties?.id, class: 'linktothis' },
					// @ts-ignore
					children: [linkIcon]
				});
				node.children.push({
					type: 'element',
					tagName: 'a',
					properties: { href: '#title', class: 'backtotop' },
					// @ts-ignore
					children: [cornerRightUpIcon]
				});
				return [SKIP];
			}
		});
		let foundInParent = 0;
		/**
		 * @type {any}
		 */
		let prevParent;
		findAndReplace(tree, [
			[
				/\[([^\]:]+)( : [^\]]+)?\]/g,
				(original, link, lit, { stack }) => {
					const parent = stack[stack.length - 2];
					const index =
						parent.children.findIndex(
							(/**@type **/ c) => c?.value && c?.value?.includes(original)
						) - 1;
					if (prevParent !== parent) {
						foundInParent = 0;
						prevParent = parent;
					}
					const previous = parent.children[index + foundInParent];
					const next = parent.children[index + 2 + foundInParent];
					const lastCharOfPreviousNode = previous?.value?.slice(-1) ?? '';
					const firstCharOfNextNode = next?.value[0] ?? '';
					if (lastCharOfPreviousNode == '[' && firstCharOfNextNode == ']') {
						previous.value = previous.value.slice(0, -1);
						next.value = next.value.slice(1);
						return h(
							'a.wikilink',
							{
								href: '/wiki/' + link.trim().replaceAll(' ', '-').toLowerCase()
							},
							lit ? lit.slice(3) : link
						);
					} else {
						return original;
					}
				}
			],
			[
				// eslint-disable-next-line no-useless-escape
				/(?<![\w\d])(\\?)@(\S+)/g,
				(_, escape, user) => {
					if (escape) return '@' + user;
					const href = '/amigues/' + user;
					return h('a.mention', { href }, '@' + user);
				}
			]
		]);
	};
}

# =============================================
# ARCHIVO: ./src/lib/utils/hardcodedTags.js
# =============================================

export const hardcodedTags = [
	{ id: 'KinkyVibe', icon: '⚫︎ ', color: 'var(--1)' },
	{
		id: 'root',
		children: [
			'KinkyVibe',
			'idioma',
			'lugar',
			'precio',
			'calendario',
			'material',
			'amigues',
			'BDSM',
			'prácticas',
			'implementos',
			'género y salud sexual',
			'antipunitivismo',
			'despatologización',
			'neurodivergencia',
			'vincularidad'
		]
	},
	{ id: 'idioma', icon: '🌐', children: ['español', 'LSA', 'inglés'], color: 'darkblue' },
	{ id: 'español', icon: '🇪🇸' },
	{ id: 'LSA', icon: '🇦🇷' },
	{ id: 'inglés', icon: '🇬🇧' },
	{
		id: 'lugar',
		icon: '📍',
		children: ['Online', 'Presencial'],
		color: 'darkblue'
	},
	{ id: 'Online', icon: '🖥️' },
	{ id: 'Presencial', icon: '👥', children: ['Argentina', 'Uruguay', 'Chile'] },
	{ id: 'Argentina', icon: '🇦🇷', children: ['AMBA', 'Córdoba', 'Santa Cruz'] },
	{ id: 'AMBA', icon: '𓉶' },
	{ id: 'Córdoba', icon: '♜' },
	{ id: 'Santa Cruz', icon: '⛰️' },
	{ id: 'Uruguay', icon: '🇺🇾', children: ['Montevideo'] },
	{ id: 'Chile', icon: '🇨🇱' },
	{ id: 'precio', icon: '💸', children: ['pago', 'a la gorra', 'gratis'], color: 'darkblue' },
	{ id: 'pago', icon: '💲' },
	{ id: 'a la gorra', icon: '🧢' },
	{ id: 'gratis', icon: '🆓' },
	{
		id: 'calendario',
		icon: '📆',
		children: ['tipo de evento', 'evento recurrente'],
		color: 'var(--3-dark)'
	},
	{
		id: 'tipo de evento',
		children: [
			'cabaret',
			'charla debate',
			'cine',
			'concurso de drag',
			'entrevista',
			'evento',
			'exposición de arte',
			'feria',
			'fiesta',
			'grupo',
			'jam de cuerdas',
			'laboratorio',
			'perfo',
			'poesía',
			'rancheadita',
			'sesión en vivo',
			'taller'
		]
	},
	{ id: 'cabaret', icon: '🎀' },
	{ id: 'charla debate', icon: '📢' },
	{ id: 'cine', icon: '🍿' },
	{ id: 'concurso de drag', icon: '👨‍🎤' },
	{ id: 'entrevista', icon: '🎙️' },
	{ id: 'evento', icon: '🔥' },
	{ id: 'exposición de arte', icon: '🖼️' },
	{ id: 'feria', icon: '🏮' },
	{ id: 'fiesta', icon: '🎉' },
	{ id: 'grupo', icon: '🫂' },
	{ id: 'jam de cuerdas', icon: '🪢' },
	{ id: 'laboratorio', icon: '🧪' },
	{ id: 'perfo', icon: '🤹‍♂️' },
	{ id: 'poesía', icon: '✍️'},
	{ id: 'rancheadita', icon: '🧺' },
	{ id: 'sesión en vivo', icon: '🏇' },
	{ id: 'taller', icon: '🎓' },
	{ id: 'evento recurrente', children: ['Picantearla', 'Cine para Sucixs'] },
	{ id: 'Picantearla', icon: '🔥' },
	{ id: 'Cine para Sucixs', icon: '🎞️' },
	{
		id: 'material',
		icon: '📖',
		color: 'var(--3-dark)',
		children: ['tipo de material', 'formato de material']
	},
	{ id: 'tipo de material', children: ['online', 'descargable', 'interactivo'] },
	{ id: 'online', icon: '🛜' },
	{ id: 'descargable', icon: '📥' },
	{ id: 'interactivo', icon: '🖱️' },
	{
		id: 'formato de material',
		children: ['guía', 'artículo', 'libro', 'fanzine', 'checklist', 'video']
	},
	{ id: 'guía', icon: '🧭' },
	{ id: 'artículo', icon: '📰' },
	{ id: 'libro', icon: '📕' },
	{ id: 'fanzine', icon: '📔' },
	{ id: 'checklist', icon: '📋' },
	{ id: 'video', icon: '▶️' },
	{ id: 'amigues', icon: '❤️', children: ['tipo de perfil', 'servicio'], color: 'var(--3-dark)' },
	{ id: 'tipo de perfil', children: ['emprendimiento', 'profesional'] },
	{ id: 'emprendimiento', icon: '👥' },
	{ id: 'profesional', icon: '👤' },
	{
		id: 'servicio',
		children: [
			'arte',
			'clases',
			'comida vegana',
			'comunidad',
			'eventos',
			'productos',
			'sesiones',
			'terapia',
			'editorial'
		]
	},
	{ id: 'arte', icon: '🎨' },
	{ id: 'clases', icon: '👩‍🏫' },
	{ id: 'comida vegana', icon: '🥕' },
	{ id: 'comunidad', icon: '👥' },
	{ id: 'eventos', icon: '🗓️' },
	{ id: 'productos', icon: '🛒' },
	{ id: 'sesiones', icon: '🔥' },
	{ id: 'terapia', icon: '🗨️' },
	{ id: 'editorial', icon: '📚' },
	{
		icon: '❤️',
		id: 'BDSM',
		description:
			'Una conjunción de [[bondage]] y [[disciplina]], [[dominación]] y [[sumisión]], y [[sadismo]] y [[masoquismo]].',
		related: ['top', 'bottom', 'dominante', 'sumise'],
		color: '#ff4444',
		children: [
			'seguridad',
			'negociación',
			'consentimiento',
			'dinámicas',
			'caída',
			'cuidados posteriores',
			'sadomasoquismo',
			'24/7'
		]
	},
	{
		id: 'negociación',
		icon: '🤝',
		description:
			'Los momentos previos a la práctica [[bdsm]], donde buscamos compartir y discernir cuáles son nuestros intereses, intensiones, deseos, niveles de comodidad, y [[límites]], así como cuidados necesarios.'
	},
	{ id: 'consentimiento', icon: '✅', children: ['RACK', 'SSC', 'CCCC'] },
	{
		id: 'RACK',
		aka: ['Risk-Aware Consensual Kink'],
		description:
			'Fetiche consensuado con conciencia de riesgo, propuesta ética y filosófica para pensar las sexualidades y prácticas [[BDSM]], formulada en 1999 por Gary Switch para la comunidad estadounidense.'
	},
	{
		id: 'SSC',
		aka: ['Safe Sane and Consensual', 'Sano Seguro y Consensuado', 'Sensato Seguro y Consensuado'],
		description:
			"Sano Seguro y consensuado (safe sane and consensual) acrónimo propuesto por David Stein, es un código de conducta ética para la comunidad BDSM usado durante los 80's en Estados Unidos"
	},
	{
		id: 'caída',
		icon: '😭',
		aka: ['drop', 'bajón'],
		description:
			'El estado mental físico psicoemocional en el cual estamos después de una experiencia intensa pero positiva.',
		related: ['cuidados posteriores']
	},
	{
		id: 'cuidados posteriores',
		icon: '🫂',
		aka: ['aftercare'],
		description:
			'Prácticas de cuidado que suceden después de un intercambio fetichista o [[sesión]], con el fin de procesar la [[escena]] y transicionar hacia la cotidianeidad.',
		related: ['caída']
	},
	{
		id: 'sadomasoquismo',
		children: ['sadismo', 'masoquismo'],
		related: ['cosquillas', 'impacto', 'predicamento', 'tortura genital', 'dolor', 'humillación']
	},
	{
		id: 'sadismo',
		description:
			'Excitación que algunas personas experimentan al infligir dolor y/o sufrimiento de forma consensuada o al verlo ser infligido.'
	},
	{
		id: 'masoquismo',
		description:
			'Excitación que algunas personas experimentan al recibir dolor y/o sufrir de forma consensuada.'
	},
	{ icon: '🕕', id: '24/7' },
	{
		id: 'prácticas',
		children: [
			'top',
			'bottom',
			'disciplina',
			'protocolo',
			'cnc',
			'hablar sucio',
			'roles',
			'impacto',
			'sensaciones',
			'bondage',
			'predicamento',
			'privación sensorial',
			'intercambio de poder',
			'cuchillos',
			'dolor',
			'humillación',
			'asfixia',
			'miedo',
			'adoración de pies',
			'chemsex',
			'cera',
			'comida',
			'sadomasoquismo en pechos',
			'lluvias',
			'edging',
			'pegging',
			'fisting',
			'rimming'
		],
		color: '#ff4444'
	},
	{
		id: 'implementos',
		icon: '🛠️',
		color: '#ff4444',
		children: ['paleta', 'palmeta', 'látigo', 'fusta', 'cuerdas', 'cuchillos']
	},
	{
		icon: '🏏',
		id: 'paleta',
		description:
			'Implemento de [[impacto]] generalmente plano y rectangular. Similar a las [[palmeta]]s pero con mayor peso y rigidez. Suele venir de madera, acrílico o plástico rígido, etc'
	},
	{
		icon: '🥍',
		id: 'palmeta',
		description:
			'Implemento de [[impacto]] generalmente plano y rectangular, comúnmente flexible y de cuero/ina. Pueden venir con calados, peluches o tachas para distintas [[sensaciones]].'
	},
	{
		id: 'látigo',
		aka: ['whip'],
		children: ['cola de dragón', 'flogger'],
		description:
			'Implemento de [[impacto]] formado por un mango rígido, sumado a una o más tiras largas y flexibles llamadas colas. Existen muchas variantes que provocarán distintas sensaciones en le bottom dependiendo de su forma, peso y material.'
	},
	{
		id: 'cola de dragón',
		aka: ['dragon tail'],
		description:
			'Tipo de látigo compuesto por un mango rígido sumado a una pieza de cuero/ina, enrollada y con terminación en la punta.'
	},
	{
		id: 'flogger',
		children: ['florentino'],
		description:
			'Implemento de [[impacto]] y [[sensaciones]] formado por un mango y múltiples tiras/colas que impactan en la piel. Produce diferentes sensaciones según el grosor, cantidad de colas y material con el que esté confeccionado'
	},
	{
		id: 'florentino',
		description:
			'Tipo específico de [[flogger]] articulado y sin mango rígido. Suelen venir en pares para utilizarse en, justamente, la técnica de azote florentina'
	},
	{
		id: 'fusta',
		aka: ['riding crop'],
		description:
			'Implemento de [[impacto]] que consiste en una varilla con una pieza de cuero o cuerina en el extremo donde impacta, y un mango para sostenerla del otro lado'
	},
	{
		id: 'género y salud sexual',
		children: ['queer', 'materiales', 'porno', 'squirt', 'feminismo', 'salud'],
		color: '#ff4444'
	},
	{
		icon: '💦',
		id: 'squirt',
		visible_name: 'Eyaculación vaginal',
		aka: ['squirt', 'eyaculación prostática'],
		description:
			'Expulsión de fluidos liberados por las glándulas de Anarcha (ex glándula de Skene) durante la estimulación genital de personas que nacieron con agujero frontal/canal vaginal.'
	},
	{ icon: '⚖️', id: 'antipunitivismo', color: 'var(--2)' },
	{ icon: '⚕️', id: 'despatologización', color: 'var(--2)' },
	{ icon: '♾️', id: 'neurodivergencia', color: 'var(--2)' },
	{ icon: '💞', id: 'vincularidad', children: ['no monogamia', 'celos'], color: 'var(--2)' },
	{ id: '', color: '#ff4444' },
	{ id: 'queer', icon: '🏳️‍🌈', children: ['furry', 'género', 'asexualidad', 'drag'] },
	{
		id: 'asexualidad',
		aka: ['ace', 'espectro asexual'],
		description:
			'Orientación sexual caracterizada por no sentir atracción sexual hacía otras personas.'
	},
	{ icon: '⬆️', id: 'top', description: 'Comúnmente, la persona que "da" una [[práctica]].' },
	{
		icon: '⬇️',
		id: 'bottom',
		description:
			'Comúnmente, la persona que "recibe" una [[práctica]]. Hay múltiples formas y sabores de bottom: [[conejite de cuerdas]], [[power bottom]], [[Dom]] bottom, [[brat]] bottom, etc...'
	},
	{
		id: 'disciplina',
		icon: '📏',
		related: ['bondage', 'brat'],
		description:
			'Enseñarle a le [[bottom]] y/o [[sub]] a obedecer órdenes, o a seguir las reglas que le Dom establezca a través de premios y/o castigos. También puede incluir modificación del comportamiento.'
	},
	{
		icon: '📝',
		id: 'protocolo',
		related: ['intercambio de poder'],
		description:
			'Serie de normas consensuadas, generalmente entre Doms y Subs que pautan comportamientos, reglas, simbolismos y valores dentro de una dinámica D/s'
	},
	{
		icon: '🍆',
		id: 'pegging',
		description:
			'Históricamente usado para referirse a el acto de que una mujer cis penetre analmente con un strap on/cinturonga a un hombre cis. Hoy en día es utilizado por algunas personas para referirse a cualquier persona que use un strap-on para sexo anal, aunque suele circular más con ese nombre cuando se usa sobre hombres cis.'
	},
	{
		id: 'roles',
		icon: '🎭',
		aka: ['role play', 'rolplay'],
		visible_name: 'Juegos de roles',
		children: ['edad', 'primal', 'mascota', 'brat', 'cnc', 'cazadore-presa'],
		description:
			'Donde las partes acuerdan "actuar" roles (enfermera/médicx, profesore/alumne, Dueño/mascota, etc), algunas veces incluye [[intercambio de poder]].'
	},
	{
		icon: '😤',
		id: 'primal',
		visible_name: 'Juegos primales',
		aka: ['primal play'],
		related: ['mascota', 'cazadore-presa'],
		description: 'Juego de roles en donde se toman características asociadas a lo animalístico no-humano. Algunos ejemplos serían: rasguñar, gruñir, morder, etc.'
	},
	{
		icon: '🐕‍🦺',
		id: 'mascota',
		visible_name: 'Juegos de mascotas',
		aka: ['pet'],
		related: ['primal']
	},
	{
		icon: '😈',
		id: 'brat',
		aka: ['malcriade'],
		related: ['disciplina'],
		description:
			'Un rol donde se toma actitud rebelde y provocadora a través de acciones o palabras. En caso de ser sumi, usualmente es buscando un castigo como consecuencia.'
	},
	{
		icon: '🟢',
		id: 'cnc',
		visible_name: 'No-consenso consensuado',
		aka: ['cnc', 'consensual non-consent'],
		description:
			'Juego de roles donde se forcejea y finge una falta de consentimiento. Puede encontrarse como parte de otros roles y dinámicas.'
	},
	{ icon: '🗣️', id: 'hablar sucio' },
	{
		id: 'cazadore-presa',
		icon: '🏹',
		visible_name: 'Cazadore / presa',
		aka: ['Hunter/prey', 'H/p', 'C/p'],
		related: ['primal'],
		description: 'Donde las partes adoptan esos roles, que pueden ser tanto humanos como no-humanos'
	},
	{
		id: 'edad',
		icon: '🍭',
		children: ['pequeñe', 'middle', 'cuidadore', 'grande', 'ddlg', 'abdl'],
		aka: ['age play'],
		description:
			'Un término paraguas para referirse a cualquier tipo de juego en donde alguna persona adulta pretenda tener una edad diferente a la que tiene en la actualidad.'
	},
	{
		icon: '👶',
		id: 'pequeñe',
		aka: ['peque', 'little'],
		description:
			'Suele ser como se le llama a las personas adultas que juegan a tener menos edad que su edad cronológica en juegos con la [[edad]].'
	},
	{
		icon: '🤟',
		id: 'middle',
		aka: ['lolite'],
		description:
			'Personas adultas que disfrutan de tomar roles relacionados a la adolescencia / pubertad en juegos con la [[edad]]. También "lolites".'
	},
	{
		icon: '🧑‍🍼',
		id: 'cuidadore',
		aka: ['caregiver', 'caretaker'],
		description:
			'Refiere a personas que quieren jugar a cuidar / compartir con [[pequeñe]]s sin tomar algún rol especifico.'
	},
	{
		icon: '💼',
		id: 'grande',
		description:
			'En los juegos con la [[edad]], son personas que juegan a tener más edad que su edad cronológica y / o son les [[cuidadore]]s.'
	},
	{
		icon: '👨‍👧',
		id: 'ddlg',
		visible_name: 'Papi Dom / niña pequeña',
		aka: ['Daddy Dom/little girl', 'DD/lg'],
		description:
			'Es un tipo de dinámica relacional y juego con la edad en donde una persona toma el rol parental de "[[daddy]]" o "papi" y otre le de la "pequeña". En general es un vínculo masc/fem'
	},
	{
		id: 'abdl',
		icon: '🩲',
		visible_name: 'Bebé Adulte Amante de los Pañales',
		aka: ['ABDL', 'Adult Baby Diaper Lover'],
		description:
			'Mezcla de juegos con la [[edad]] y [[fetiche de pañales]] (usarlos, tenerlos puestos bajo la ropa y que los mismos sean cambiados). Se disfruta de tomar características asociadas a la edad infantil (llorar, usar pañales, ropa de bebé).'
	},
	{
		id: 'impacto',
		icon: '💢',
		visible_name: 'Juegos de Impacto',
		children: ['calentamiento', 'nalgueadas', 'caning', 'golpes', 'bastinado'],
		description:
			'[[práctica]] variada que consiste en impactar físicamente sobre zonas del cuerpo con fines eróticos/sensuales/catárticos.',
		related: ['sensaciones', 'juego de roles', 'miedo', 'dolor', 'calentamiento']
	},
	{
		id: 'predicamento',
		icon: '⚖️',
		description:
			'Colocar a le [[bottom]] en una situación donde tenga que elegir entre dos posiciones que son incómodas o dolorosas de distintas formas, frecuentemente hecho con [[bondage]].',
		related: ['sadomasoquismo']
	},
	{
		icon: '♨️',
		id: 'calentamiento',
		description:
			'Práctica de impacto de baja intensidad para preparar una zona del cuerpo a ser impactada con mayor fuerza. Típicamente se hace como comienzo de una sesión de impacto. Reduce las chances de generar moretones.'
	},
	{ id: 'golpes', icon: '🤜', description: 'Práctica de impacto utilizando los puños' },
	{
		icon: '🍑',
		id: 'nalgueadas',
		aka: ['spanking'],
		description: 'Práctica de impactar con las manos sobre las nalgas de une misme u otre'
	},
	{
		icon: '🦯',
		id: 'bastinado',
		description:
			'Práctica de impacto realizada específicamente sobre la planta del pie, clásicamente con una varilla.'
	},
	{
		id: 'sensaciones',
		icon: '🪶',
		visible_name: 'Juegos de sensaciones',
		children: ['temperatura', 'electro'],
		aka: ['sensation play'],
		description:
			'Donde se busca crear sensaciones físicas placenteras o displacenteras sobre una persona. Se puede usar hielo, seda, [cera] caliente, texturas, etc. Se suele hacer con le [[bottom]] cegade.'
	},
	{
		id: 'cuchillos',
		icon: '🗡️',
		visible_name: 'Juegos con cuchillos',
		aka: ['knife play'],
		description:
			'Donde se involucran el uso de cuchillos, con o sin filo, para generar [[sensaciones]], [[miedo]], [[dolor]] o [[cortes]] como parte de un juego de [[roles]].'
	},
	{
		id: 'electro',
		icon: '⚡️',
		visible_name: 'Juegos con electricidad',
		aka: ['electro play'],
		description:
			'[[práctica]] que involucra el uso de electricidad para generar sensaciones en el cuerpo. Se considera un tipo de [[edge]] play.',
		related: ['sensaciones', 'miedo']
	},
	{
		id: 'temperatura',
		icon: '🌡️',
		visible_name: 'Juegos con la temperatura',
		children: ['fuego'],
		aka: ['temperature play'],
		description:
			'Una forma de juego de [[sensaciones]] donde se usan objetos o sustancias que estimulan los neuroreceptores del cuerpo con calor y frío para generar placer.'
	},
	{
		id: 'fuego',
		icon: '🔥',
		visible_name: 'Juegos con fuego',
		description:
			'[[práctica]]s que involucran el uso de fuego o de llamas. Por ejemplo el uso de alcohol para generar una llama breve y rápidamente extinguirla. Considerado un tipo de [[edge]] play.',
		aka: ['fire play']
	},
	{
		icon: '⛓️',
		id: 'bondage',
		children: ['cuerdas', 'momificación', 'restricción mental'],
		aka: ['juegos con restricciones'],
		description: 'Las [[prácticas]] de restricción física.',
		related: ['humillación', 'objetificación', 'privación sensorial', 'disciplina', 'predicamento']
	},
	{
		id: 'cuerdas',
		icon: '🪢',
		children: ['shibari', 'atadore', 'bottom de cuerdas'],
		description:
			'Elemento compuesto de sogas trenzadas, por lo general de algodón o yute, utilizado en [[shibari]] y/o [[bondage]]',
		color: '#ff4444'
	},
	{
		id: 'shibari',
		aka: ['bondage japonés', 'bondage con cuerdas', 'rope bondage', 'kinbaku'],
		description:
			'[[práctica]] erótica de origen japonés que consiste en restringir la movilidad de una persona usando cuerdas.'
	},
	{
		id: 'atadore',
		aka: ['top de cuerdas', 'rigger'],
		description: 'La persona [[top]] en el [[shibari]] que ata a le [[bottom de cuerdas]]'
	},
	{
		id: 'bottom de cuerdas',
		icon: '🐇',
		aka: ['conejite de cuerdas', 'rope bunny'],
		description: 'La persona que es atada en el [[shibari]]'
	},
	{
		id: 'momificación',
		icon: '🧻',
		aka: ['mummification'],
		description:
			'Restringir la movilidad de un cuerpo parcial o totalmente, típicamente utilizando film, tela o yeso.'
	},
	{
		id: 'restricción mental',
		description:
			'Retringir el movimiento únicamente mediante órdenes y obediencia, en un [[intercambio de poder]]'
	},
	{ id: 'privación sensorial', icon: '🥽' },
	{
		id: 'dolor',
		aka: ['juegos con el dolor', 'pain play'],
		description:
			'Cualquier [[práctica]] donde una persona inflige dolor consensuadamente para generar placer.',
		related: ['impacto', 'electro', 'sadomasoquismo']
	},
	{
		id: 'intercambio de poder',
		icon: '🧎',
		children: ['dominación', 'dominante', 'sumisión', 'sumise'],
		description:
			'Un acuerdo entre varias partes, comunmente alguna [[dominante]] y alguna [[sumisa]], donde la parte [[sumisa]] le entrega poder sobre aspectos de sí misma a la [[dominante]].',
		related: ['dinámicas']
	},
	{
		id: 'dominante',
		description: 'Persona que tiene el poder en un [[intercambio de poder]].',
		related: ['dominación']
	},
	{
		id: 'fisting',
		icon: '🤌',
		description:
			'Meter 4 o más dedos en el canal vaginal/agujero frontal o en el ano, muchas veces llegando a meter la mano entera y cerrándola en un puño.'
	},
	{
		icon: '🛞',
		id: 'rimming',
		aka: ['anilingus'],
		description: 'practicar sexo oral a un ano'
	},
	{
		id: 'adoración de pies',
		icon: '🦶',
		aka: ['feet worship', 'feet kink', 'feet fetish'],
		description: 'Contemplar, acariciar, masajear, oler, lamer o besar pies, entre otras.'
	},
	{
		icon: '🫣',
		id: 'humillación',
		visible_name: 'Humillación erótica',
		aka: ['erotic humilliation'],
		related: ['sadomasoquismo', 'bondage'],
		description:
			'Tomar acciones, objetos, palabras que en el "mundo exterior" (subjetivo de cada persona) parecerían "humillantes" y re contextualizarlas en un marco erótico a través de un lente de apreciación, cuidado, aceptación y disfrute.'
	},
	{
		id: 'asfixia',
		icon: '😶‍🌫️',
		children: ['headscissors'],
		description:
			'Reducir la cantidad de oxígeno que llega al cerebro de le [[bottom]] para generar distintas [[sensaciones]] o como muestra de un [[intercambio de poder]] mediante [[estrangulación]] o juegos con la [[respiración]]'
	},
	{ icon: '😨', id: 'miedo' },
	{
		id: 'respiración',
		icon: '🫁',
		visible_name: 'Juegos con la Respiración',
		aka: ['breath play'],
		description:
			'Restricción intencional del aire que inspira mediante [[control]], [[implementos]] o [[dominación]] física'
	},
	{
		id: 'estrangulación',
		icon: '🫶',
		aka: ['choking'],
		description:
			'Restricción del flujo normal de sangre al cerebro mediante la presión de las arterias carótidas del cuello.'
	},
	{
		id: 'headscissors',
		icon: '🦵',
		description: '[[estrangulación]] generada rodeando el cuello con los muslos.'
	},
	{
		icon: '💊',
		id: 'chemsex',
		visible_name: 'Juego con drogas',
		aka: ['PNP', 'Party and Play', 'chemsex'],
		related: ['intox'],
		description:
			'Prácticas sexuales o [[sadomasoquista]]s hechas consicentemente bajo el uso de sustancias psicoactivas/drogas recreacionales. Usualmente en fiestas. Considerado un tipo de [[juego límite]]'
	},
	{
		icon: '😫',
		id: 'edging',
		visible_name: 'Edgear',
		aka: ['edging', 'tease and denial'],
		description: 'Estimular los genitales hasta casi llegar al [[orgasmo]] y luego parar.'
	},
	{
		id: 'cera',
		icon: '🕯️',
		visible_name: 'Juegos con Cera',
		aka: ['wax play', 'velas', 'juegos con velas'],
		description:
			'Verter cera caliente de velas sobre un cuerpo. Puede implicar dolor o [[sensaciones]] suaves dependiendo del material, la distancia, y la técnica.'
	},
	{ id: 'lluvias', icon: '🌧️', children: ['lluvia dorada'] },
	{
		id: 'lluvia dorada',
		aka: ['golden shower', 'watersports', 'piss play', 'juegos con pis'],
		description: 'Orinar sobre el cuerpo de le [[bottom]]'
	},
	{ id: 'comida', icon: '🍰', children: ['enchastre'] },
	{
		id: 'enchastre',
		aka: ['sploshing', 'wet and messy', 'WAM'],
		description:
			'Desparramar sustancias o alimentos, típicamente líquidos, densos y/o pegajosos, sobre el cuerpo une misme u otre'
	},
	{ id: 'espanol', aliasOf: 'español' },
	{ id: 'ingles', aliasOf: 'inglés' },
	{ id: 'practica', aliasOf: 'prácticas' },
	{ id: 'práctica', aliasOf: 'prácticas' },
	{ id: 'practicas', aliasOf: 'prácticas' },
	{ id: 'negociacion', aliasOf: 'negociación' },
	{ id: 'guia', aliasOf: 'guía' },
	{ id: 'bdsm', aliasOf: 'BDSM' },
	{ id: 'Dominatrix', aliasOf: 'dominatrix' },
	{ id: 'articulo', aliasOf: 'artículo' },
	{ id: 'Shibari', aliasOf: 'shibari' },
	{ id: 'Kinkyvibe', aliasOf: 'KinkyVibe' },
	{ id: 'kinkyvibe', aliasOf: 'KinkyVibe' },
	{ id: 'D/s', aliasOf: 'intercambio de poder' }
];
export default hardcodedTags;

# =============================================
# ARCHIVO: ./src/lib/utils/index.js
# =============================================

import '$lib/types.d.js';
import tagsFactory from './tags';

/**Calls fn for the group and every subgroup and returns the resulting group.
 * @param {Group} group
 * @param {(group: Group)=>Group|false} fn
 * @returns {any}
 */
export function groupMap(group, fn) {
	let mappedSubs = [];
	let mappedGroup = fn(group);
	if (mappedGroup === false) return false;
	if (group.sub && group.sub.length > 0) {
		for (const sub of group.sub) {
			const neoSub = groupMap(sub, fn);
			if (neoSub != false) mappedSubs.push(neoSub);
		}
		return {
			...mappedGroup,
			sub: mappedSubs,
			members: mappedGroup.members ?? []
		};
	} else {
		return { ...mappedGroup, members: mappedGroup.members ?? [], sub: [] };
	}
}

/**
 * @param {"calendario"|"amigues"|"material"|"wiki"} category
 * @param {string} postID
 * @param {string} assetID
 */
export const thumbURL = async (category, postID, assetID) => {
	//check if string is an integer
	let formats = ['jpeg', 'jfif', 'jpg', 'png', 'webp'];
	if (('' + assetID).match(/^\d+$/)) {
		for (const format of formats) {
			try {
				let thumb = await import(`$lib/posts/${category}/media/${postID}/${assetID}.${format}`);
				return thumb.default;
			} catch (e) {
				continue;
			}
		}
		return undefined;
	} else {
		let [filename, format] = assetID.split('.');
		try {
			let thumb = await import(`$lib/assets/${filename}.${format}`);
			return thumb.default;
		} catch (e) {
			return undefined;
		}
	}
};

/**
 * @param {TagManager} [tagManager=tagsFactory()]
 * @returns {(tag: string)=>string}
 */
export function aliaserFactory(tagManager = tagsFactory()) {
	return (tag) => tagManager.get(tag)?.id ?? tag;
}

/**
 * Fetches a post from the specified category and post id.
 *
 * @param {"calendario"|"amigues"|"material"|"wiki"} category - The category of the post.
 * @param {string} postID - The id of the post.
 * @param {boolean} [shallow=false]
 * @return {Promise<ProcessedPost>} - The content and metadata of the post.
 */
export const fetchPost = async (category, postID, shallow = false) => {
	let { default: postContent, metadata: meta } = await import(`../posts/${category}/${postID}.md`);
	if (meta?.force_unpublished) throw Error('Post is unpublished');
	return await processPost(postContent, postID, meta, shallow);
};

/**
 * Processes a post and returns relevant information.
 *
 * @param {ConstructorOfATypedSvelteComponent} postContent - The content of the post.
 * @param {string} postID - The ID of the post.
 * @param {AnyPostData} meta - The metadata associated with the post.
 * @param {boolean} [shallow=false] - Indicates whether to perform a shallow processing.
 * @param {TagManager} [tagManager=tagsFactory()] - The tag manager to use.
 * @return {Promise<ProcessedPost>} An object containing the processed post information.
 */
async function processPost(postContent, postID, meta, shallow = false, tagManager = tagsFactory()) {
	let authorsProfiles = [];
	/**@type {ProcessedPost[]} */
	if (!shallow) {
		for (const author of meta?.authors ?? []) {
			const authorID = author.replaceAll(' ', '-');
			if (authorID !== postID) {
				try {
					const authorProfile = await fetchPost('amigues', authorID, true);
					authorsProfiles.push(authorProfile);
				} catch (e) {
					continue;
				}
			}
		}
	}

	const sortTags = tagSorter(tagManager);
	const processedMeta = {
		...meta,
		tags: [...(meta.tags ?? [])]
			.map((t) => tagManager.get(t))
			.sort(sortTags)
			.map((t) => t.id),
		featured:
			meta.featured !== undefined
				? await thumbURL(meta.category, postID, meta.featured)
				: undefined,
		photo: meta.photo !== undefined ? await thumbURL(meta.category, postID, meta.photo) : undefined,
		logo: meta.logo !== undefined ? await thumbURL(meta.category, postID, meta.logo) : undefined,
		postID
	};
	const processedPost = {
		content: shallow ? undefined : postContent,
		meta: processedMeta,
		authorsProfiles,
		path: '/' + meta.category + '/' + postID
	};
	return processedPost;
}

/**
 * @param {TagManager} tagManager
 */
export function tagSorter(tagManager) {
	/**
	 * @param {ProcessedTag} tag
	 * @return {string[][]}
	 */
	const ancestry = (tag) => {
		let branches = [];
		let tagParents = tag.parents?.filter((p) => p != 'root') ?? [];
		for (let p of tagParents) {
			let subbranch = [];
			let grandparents = ancestry(tagManager.get(p));
			if (grandparents.length > 0) {
				for (let g of grandparents) {
					subbranch.push([...g, p]);
				}
			} else {
				subbranch.push([p]);
			}
			branches.push(...subbranch);
		}
		return branches;
	};
	/**
	 * @param {ProcessedTag} a
	 * @param {ProcessedTag} b
	 * @returns {number}
	 */
	function sortTags(a, b) {
		let aAncestry = ancestry(a).map((br) => [...br.flat(), a.id]);
		let bAncestry = ancestry(b).map((br) => [...br.flat(), b.id]);
		if (aAncestry.length == 0) aAncestry = [[a.id]];
		if (bAncestry.length == 0) bAncestry = [[b.id]];
		return (
			tagManager.tagIDs().indexOf(aAncestry[0][0]) - tagManager.tagIDs().indexOf(bAncestry[0][0])
		);
	}
	return sortTags;
}

/**
 * Fetches markdown posts and performs validations and transformations.
 * @param {boolean} wiki - Whether or not the posts are from the wiki
 * @param {boolean} unlisted - Whether or not the posts shown are unlisted
 * @return {Promise<ProcessedPost[]>} An array of validated and transformed posts.
 */
export const fetchMarkdownPosts = async (wiki = false, unlisted = false) => {
	/** @type {[string, (()=>Promise<any>)|any][]} */
	var allPosts;
	if (wiki) {
		allPosts = Object.entries(import.meta.glob('$lib/posts/wiki/*.md'));
	} else {
		allPosts = Object.entries(import.meta.glob('$lib/posts/calendario/*.md'));
		allPosts.push(...Object.entries(import.meta.glob('$lib/posts/amigues/*.md')));
		allPosts.push(...Object.entries(import.meta.glob('$lib/posts/material/*.md')));
	}
	let processedPosts = [];
	for (const [rawPath, constructor] of allPosts) {
		const postID = rawPath.split('/').slice(-1)[0].split('.md')[0];
		if (postID.startsWith('_')) continue;
		const { metadata, default: postContent } = await constructor();
		if (
			!metadata ||
			(!unlisted && metadata.force_unlisted) ||
			(unlisted && !metadata.force_unlisted)
		) {
			continue;
		}
		const tagManager = tagsFactory();
		processedPosts.push(await processPost(postContent, postID, metadata, true, tagManager));
	}
	processedPosts.sort((a, b) => {
		/** @param {ProcessedPost} x @returns number */
		let f = (x) =>
			new Date(x.meta?.start ?? x.meta?.updated_date ?? x.meta?.published_date).getTime();
		return f(b) - f(a);
	});
	return [...processedPosts];
};

/** @type {import('svelte/action').Action}  */
export const processContent = async (node) => {
	// @ts-ignore
	node.querySelectorAll('a.mention').forEach(async (/**@type {HTMLAnchorElement}*/ el) => {
		let p = document.createElement('small');
		let name = el.textContent?.slice(1);
		if (name === undefined) return;
		let post;
		try {
			post = await fetchPost('amigues', name, true);
		} catch (e) {
			return;
		}
		if (post.meta.pronoun == '' || !post.meta.pronoun || (post.meta.pronoun + '').split('/').pop() == 'evitar') return;
		p.className = 'p-pronoun';
		p.textContent =
			' ' + (post?.meta.pronoun + '').split('/').pop()?.split(',')[0].replaceAll('&', '/') + '';
		el.appendChild(p);
	});
};

# =============================================
# ARCHIVO: ./src/lib/utils/stores.js
# =============================================

/* eslint-disable no-unused-vars */
import { writable } from 'svelte/store';
import { browser } from '$app/environment';
import '$lib/types.d.js';
import tagsFactory from './tags';
export const view_date = writable(new Date());
export const month_change_direction = writable(1);

/** @type {import('svelte/store').Writable<string[]>} */
export const filteredTags = writable([]);
/** @type {import('svelte/store').Writable<string[]>} */
export const visibleTags = writable([]);
/** @type {import('svelte/store').Writable<string[]>} */
export const allTags = writable([]);
/** @type {import('svelte/store').Writable<Set<string>>} */
export const redundantTags = writable(new Set());

/** @type {import('svelte/store').Writable<{category:'amigues'|'calendario'|'material'|'wiki'|undefined, path: string}>} */
export const currentPostData = writable();

/** @type {import('svelte/store').Writable<(a:boolean,b:string)=>string|void>} */
export const togglePositiveTagFilterFn = writable((a, b) => '');

/**@type {import('svelte/store').Writable<TagManager>} */
export const tagManager = writable(tagsFactory());

/** @type import('svelte/store').Writable<{display_type: 'list'|'grid', show_past_events: boolean}> */
export const userConfig = writable({ display_type: 'list', show_past_events: false });

/**@type {import('svelte/store').Writable<TagManager>} */
export const wikiTagManager = writable(tagsFactory());

/**@type {import('svelte/store').Writable<string>} */
export const query = writable('');

if (browser) {
	try {
		userConfig.set(
			JSON.parse(
				localStorage.getItem('kinkyconfig') ??
					'[object Object]' /** forcing an error without breaking typing */
			)
		);
	} catch {
		//
	} finally {
		userConfig.subscribe((v) => localStorage.setItem('kinkyconfig', JSON.stringify(v)));
	}
}

# =============================================
# ARCHIVO: ./src/lib/utils/tags.js
# =============================================

/**@type Array<RawTag> */
import hardcodedTags from './hardcodedTags';

/**
 *
 * @param {TagID} id
 * @param {*} [data]
 * @returns {ProcessedTag}
 */
function orphanTagFactory(id, data) {
	return {
		id,
		visible_name: id,
		getColor() {
			return undefined;
		},
		getAllChildren() {
			return [];
		},
		getAllParents() {
			return [];
		},
		orphan:
			(!data?.parents || data?.parents.length == 0) &&
			!data?.aliasOf &&
			(!data?.children || data?.children.length == 0),
		...data
	};
}
/**
 *
 *
 * @param {Array<ProcessedTag>} [rawTags=hardcodedTags]
 * @return {TagManager}
 */
// @ts-ignore
export function tagsFactory(rawTags = hardcodedTags) {
	/** @type Array<ProcessedTag> */
	/**@type Map<TagID, ProcessedTag> */
	let tagsMap = new Map([...rawTags].map((t) => [t.id, t]));
	let missingTags = [];
	let tagManager = {
		[Symbol.iterator]() {
			return tagsMap.entries();
		},
		entries() {
			return [...tagsMap.entries()];
		},
		tagIDs() {
			return [...tagsMap.keys()];
		},
		tagsData() {
			return [...tagsMap.values()];
		},
		/**
		 * @param {TagID} id
		 */
		get(id, value = {}) {
			const tag = tagsMap.get(id);
			let res = tag;
			if (tag?.aliasOf !== undefined) {
				res = tagsMap.get(tag?.aliasOf);
			}
			return res ?? orphanTagFactory(id, value);
		},
		/**
		 * @param {TagID} id
		 * @param {*} value
		 */
		set(id, value) {
			// @ts-ignore
			tagsMap.set(id, orphanTagFactory(id, value));
			return;
		},
		/**
		 *
		 * @param {TagID} id
		 * @returns boolean - true if it existed, else false
		 */
		delete(id) {
			return tagsMap.delete(id);
		}
	};
	for (let [id, tag] of tagManager) {
		// add parents prop to all tags
		for (let childID of tag?.children ?? []) {
			let child = tagManager.get(childID);

			if (child.orphan) {
				tagManager.set(childID, {
					parents: [id]
				});
			} else if (child.parents && !child.parents.includes(id)) {
				child.parents = [...child.parents, id];
			} else {
				child.parents = [id];
			}
		}
		// generate alias tags from "aka"
		if (tag.aka && tag.aka.length > 0) {
			for (let aliasOfThis of tag?.aka ?? []) {
				if (aliasOfThis !== id) {
					tagManager.set(aliasOfThis, {
						id: aliasOfThis,
						aliasOf: id
					});
				}
			}
		}
		// backlink related tags
		if (tag.related && tag.related.length > 0) {
			for (let relatedToThis of tag.related) {
				let r = tagManager.get(relatedToThis);
				if (r !== undefined) {
					if (r.related && r.related.length > 0) {
						if (!r.related.includes(tag.id)) {
							r.related.push(tag.id);
						}
					} else r.related = [tag.id];
				} else {
					missingTags.push(relatedToThis);
				}
			}
		}
		tag.getColor = () => {
			if (tag.color !== undefined) {
				return tag.color;
			}
			let queue = [tag.id];
			while (queue.length > 0) {
				let currID = queue.pop();
				if (currID === undefined) return undefined;
				let curr = tagManager.get(currID);
				if (curr == undefined) {
					continue;
				}
				if (currID != tag.id && curr.color) {
					return curr.color;
				} else {
					if (curr.parents) {
						queue.push(...curr.parents);
					} else {
						return undefined;
					}
				}
			}
			return undefined;
		};
		tag.getAllChildren = () => {
			let res = [];
			let queue = [tag.id];
			while (queue.length > 0) {
				let currID = queue.pop();
				if (currID === undefined) return res;
				let curr = tagManager.get(currID);
				if (curr === undefined || curr.children === undefined) continue;
				queue.push(...curr.children);
				res.push(...curr.children);
			}
			return res;
		};
		tag.getAllParents = () => {
			let res = [];
			let queue = [tag.id];
			while (queue.length > 0) {
				let currID = queue.pop();
				if (currID === undefined) return res;
				let curr = tagManager.get(currID);
				if (curr === undefined || curr.parents === undefined) continue;
				queue.push(...curr.parents);
				res.push(...curr.parents);
			}
			return res;
		};
		if (tag.description !== undefined) {
			tag.parsedDescription = parseDescription(tag.description, '').map((l) => {
				if (l.type == 'link') {
					if (tagManager.get(l.line) === undefined) {
						missingTags.push(l.line);
						return { type: 'text', line: l.line };
					} else return l;
				} else return l;
			});
		}
		tag.visible_name = tag.visible_name ?? tag.id;
	}

	// link related and wikilinks

	// @ts-ignore
	return { ...tagManager, missingTags: [...new Set(missingTags)] };
}
export default tagsFactory;

/**
 * Normalizes a string by converting it to lowercase and replacing
 * accented characters with their non-accented counterparts.
 *
 * @param {string} s - The string to be normalized.
 * @return {string} The normalized string.
 */
const normalize = (s) =>
	(s + '')
		.toLowerCase()
		.replaceAll('á', 'a')
		.replaceAll('é', 'e')
		.replaceAll('í', 'i')
		.replaceAll('ó', 'o')
		.replaceAll('ú', 'u');

/**
 * Parses the given description and extracts links based on the provided query.
 *
 * @param {string} description - The description to parse.
 * @param {string} query - The query to search for in the description.
 * @return {Array<{ line: string, type: "text"|"link", href?: string }>} - An array of lines with their types and optional href.
 */
function parseDescription(description, query) {
	const regex = /\[\[([^\]]*)\]\]/g;
	const nQuery = normalize(query);
	const lines = description
		.split(regex)
		.map((line, index) => ({
			line,
			/**@type {"text"|"link"}*/ type: index % 2 == 0 ? 'text' : 'link'
		}))
		.map(({ line, /**@type {"text"|"link"}*/ type }) => {
			if (type == 'link') {
				if (line.includes(':')) {
					let [href, newStr] = line.split(':');
					return {
						line: newStr,
						type,
						href
					};
				} else {
					return {
						line,
						type,
						href: line
					};
				}
			} else return { line, type };
		})
		.map(({ line, type }) => {
			const nLine = normalize(line);
			if (query != '' && nLine.includes(nQuery)) {
				let nParts = nLine.split(nQuery);
				let k = 0;
				let parts = nParts.map((p, i) => {
					k += p.length;
					let end = k;
					if (i != 0 && i % 2 != 0) {
						k += nQuery.length;
						end = k + nQuery.length;
					}
					return line.slice(k - p.length, end);
				});
				return parts
					.map((p, i) =>
						i % 2 == 0
							? [
									{ line: p, type },
									{ line: query, type: 'mark' }
							  ]
							: { line: p, type }
					)
					.flat();
			} else return { line, type };
		})
		.flat()
		.filter(({ line }) => line !== '');
	// @ts-ignore
	return lines.length > 0 ? lines : [];
}

# =============================================
# ARCHIVO: ./src/params/category.js
# =============================================

/** @type {import('@sveltejs/kit').ParamMatcher} */
export function match(param) {
	return ["amigues", "calendario", "material", "wiki"].includes(param);
}
# =============================================
# ARCHIVO: ./src/routes/(authed)/+layout.server.js
# =============================================

import { redirect } from '@sveltejs/kit';
export async function load({ locals, url }) {
	if (locals.user_token == undefined || locals.user_token == '') {
		throw redirect(303, `/login?redirectTo=${url.pathname}`);
	} else if (isAdmin(locals.user_token, locals.user.login)) {
		return {
			currentRoute: url.pathname
		};
	} else {
		throw redirect(303, '/')
	}
}
/**
 *
 * @param {string} token
 * @param {string} username
 * @returns {Promise<*>}
 */
function isAdmin(token, username) {
	return ["GorroRojo", "Tallarines333", "VelvetVoid"].includes(username)
	// TODO make it read it from github
	// try {
	// 	await ghGet(`repos/GorroRojo/kinkyvibe/collaborators/${username}}`, token)
	// } catch (e) {
	// 	console.log(e)
	// 	return false
	// }
	// return true
}

# =============================================
# ARCHIVO: ./src/routes/(authed)/+layout.svelte
# =============================================

<script>
	import UserMenu from '$lib/components/UserMenu.svelte';
	import { filteredTags } from '$lib/utils/stores';
	export let data;
	filteredTags.set([]);
</script>

<svelte:head>
	<title>KV Admin</title>
</svelte:head>
<header>
	<a href="/">⬅️ Inicio</a>
	<span>Panel de administradore</span>
	<UserMenu user={data.user} />
</header>

<slot />

<style lang="scss">
	header {
		display: grid;
		grid-template-columns: 4em 1fr 5em;
		max-width: 50rem;
		margin-inline: auto;
		height: 3em;
		align-items: center;
		font-size: var(--step-0);
		justify-content: space-between;
		align-content: center;
	}
	span {
		text-align: center;
	}
</style>

# =============================================
# ARCHIVO: ./src/routes/(authed)/admin/+page.server.js
# =============================================

import { fetchMarkdownPosts } from '$lib/utils';
export async function load() {
	const unlisted_posts = await fetchMarkdownPosts(false, true);
	return {
		unlisted_posts
	};
}


# =============================================
# ARCHIVO: ./src/routes/(authed)/admin/+page.svelte
# =============================================

<script>
	import PostList from '$lib/components/PostList.svelte';
	export let data;
</script>
<div class="content">
	<h2>Publicaciones no listadas</h2>
</div>
<PostList posts={data.unlisted_posts} />

<!-- <textarea value={c}></textarea> -->
<!-- <button on:click={save}>Save</button> -->

# =============================================
# ARCHIVO: ./src/routes/(authed)/edit/[category=category]/[postID]/+page.server.js
# =============================================

import { Buffer } from 'buffer';
import { ghGet, ghPut } from '$lib/external/github.js';

/** @type {import("./$types").PageServerLoad} */
export async function load({ locals, params }) {
	return {
		post: await getFileContent(
			locals.user_token,
			`src/lib/posts/${params.category}/${params.postID}.md`
		)
	};
}

/** @type {import("./$types").Actions} */
export const actions = {
	save: async ({ params, cookies, request }) => {
		const token = cookies.get('userToken') ?? 'TOKEN NOT FOUND';
		const data = await request.formData();
		const fileContent = data.get('content');
		let userName = cookies.get('userName');
		if (userName == "null") userName = cookies.get('userLogin')
		// @ts-ignore
		saveFileContent(token, data.get('path') ?? '', fileContent, data.get('sha'), userName, params.category, params.postID);
		return { save: 'Guardado' };
	},
	load: async ({ cookies, request }) => {
		const token = cookies.get('userToken') || 'TOKEN NOT FOUND';
		const data = await request.formData();
		const fileContent = await getFileContent(
			token,
			'src/lib/posts/' + data.get('category') + '/' + data.get('path') + '.md'
		);
		return { post: fileContent };
	}
};
/**
 *
 * @param {string} token
 * @param {string} path
 * @returns {Promise<*>}
 */
async function getFileContent(token, path) {
	let fileContent = await ghGet('repos/GorroRojo/kinkyvibe/contents/' + path, token);
	let raw = Buffer.from(fileContent.content, fileContent.encoding).toString();
	return { raw, ...fileContent };
}

/**
 * Saves the content of a file to a specified path in a GitHub repository.
 *
 * @param {string} token - The access token for the GitHub repository.
 * @param {string} path - The path to the file in the GitHub repository.
 * @param {string} content - The content to be saved in the file.
 * @param {string} sha - The file's original sha
 * @param {string} userName - The user's name
 * @param {string} category - The category of the post
 * @param {string} postID - The post ID
 * @return {Promise<*>} A promise that resolves with the response from the GitHub API.
 */
async function saveFileContent(token, path, content, sha, userName, category, postID) {
	return await ghPut('repos/GorroRojo/kinkyvibe/contents/' + path, token, content, sha, userName, category, postID);
}

# =============================================
# ARCHIVO: ./src/routes/(authed)/edit/[category=category]/[postID]/+page.svelte
# =============================================

<script>
	import TagsInput from './../../../../../lib/components/TagsInput.svelte';
	export let data;
	export let form;
	import CodeMirror from 'svelte-codemirror-editor';
	import { markdown } from '@codemirror/lang-markdown';
	import { page } from '$app/stores';
	import { parseDocument, visit } from 'yaml';
	import { format } from 'date-fns';
	let postContent = data?.post.raw.split('---').slice(2).join('---');
	const sha = data?.post.sha ?? '';
	const path = data?.post.path ?? '';
	let doc = parseDocument(data?.post.raw.split('---')[1], { strict: false });
	/** @param {string} uncommentKey */
	function uncomment(uncommentKey) {
		let value = undefined;
		let re = new RegExp('\\s*?' + uncommentKey + ': ?(.*)?\\n', 'g');
		let removeComment = (/** @type {string} */ comments) => {
			let r = re.exec(comments || '');
			if (r) {
				value = r[1];
				comments = comments.replaceAll(re, '');
				doc.add(doc.createPair(uncommentKey, value));
			}
			return comments;
		};
		// @ts-ignore
		visit(doc, (_, /**@type{{commentBefore:string}}*/ node, path) => {
			node.commentBefore = removeComment(node?.commentBefore);
		});
		if (value === undefined) {
			doc.comment = removeComment(doc?.comment ?? '');
		}
		return value;
	}
	/** @param {string} commentKey */
	function comment(commentKey) {
		let value = doc.get(commentKey);
		if (value) {
			doc.delete(commentKey);
			doc.comment = (doc.comment ? doc.comment + '\n' : '') + commentKey + ': ' + value + '\n';
		}
	}
	/** @type {(key: string, value: any) => void}*/
	function setProperty(key, value) {
		if (doc.has(key)) {
			if (value == '' && !postPropByKey(key)?.required) {
				comment(key);
			} else {
				doc.set(key, value);
			}
		} else if (value != '') {
			let commentedValue = uncomment(key);
			doc.set(key, value);
		}
		doc = doc;
	}
	/** @param {string} key */
	function postPropByKey(key) {
		return [...postProperties, ...Object.values(typedProperties).flat()].find((p) => p.key == key);
	}
	/**@typedef PostPropInput
	 * @prop {string} label
	 * @prop {string} key
	 * @prop {'checkbox'|'date'|'text'|'textarea'|'email'|'url'|'tel'|'datetime-local'|'select'|'array'} type
	 * @prop {'tag'} [subtype]
	 * @prop {string} [placeholder]
	 * @prop {number} [width=2]
	 * @prop {boolean} [required=false]
	 * @prop {Array<{label:string, value:string, default?:boolean}>} [options]
	 */
	/**@type {Array<PostPropInput>}*/
	const postProperties = [
		{ label: 'Publicado', key: 'published_date', type: 'date', width: 1, required: true },
		{ label: 'Actualizado', key: 'updated_date', type: 'date', width: 1, required: true },
		{
			label: 'Título',
			key: 'title',
			type: 'text',
			width: 2,
			required: true,
			placeholder: 'Mi gran título'
		},
		/** TODO tags */
		// { label: 'Etiquetas', key: 'tags', type: 'array', subtype: 'tag', width: 2 },
		/** TODO autores */
		/** TODO featured */
		{
			label: 'Descripción',
			key: 'summary',
			type: 'textarea',
			width: 2,
			required: true,
			placeholder: 'Sobre tal cosa tal otro y tal acotra.'
		},
		{ label: 'Link', key: 'link', type: 'url', width: 1, placeholder: 'https://gorro.ar' },
		{
			label: 'Texto del link',
			key: 'link_text',
			type: 'text',
			width: 1,
			placeholder: 'Ir al sitio'
		},
		{ label: 'Publicación oculta', key: 'force_unlisted', type: 'checkbox', width: 2 }
	];
	/**@type {Record<'amigues'|'calendario'|'material'|'wiki'|string,Array<PostPropInput>>}*/
	const typedProperties = {
		amigues: [
			{
				label: 'Pronombres',
				key: 'pronoun',
				type: 'text',
				width: 1,
				placeholder: 'https://pronombr.es/elle&el',
				required: true
			},

			{
				label: 'Género',
				key: 'gender_identity',
				type: 'text',
				width: 1,
				placeholder: 'Perrito Travo Interdimensional'
			},
			{ label: 'Mail', key: 'email', type: 'email', width: 1, placeholder: 'gorro.rojo@gmail.com' },
			{ label: 'Teléfono', key: 'tel', type: 'tel', width: 1, placeholder: '+54 11 1234 5678' },
			{
				label: 'Dirección',
				key: 'location',
				type: 'text',
				width: 1,
				placeholder: 'Calle 123, Ciudad'
			},
			{ label: 'Cumpleaños', key: 'bday', type: 'date', width: 1 }
		],
		calendario: [
			{
				label: 'Estado',
				key: 'status',
				type: 'select',
				width: 2,
				options: [
					{ label: 'Anunciado (link oculto)', value: 'anunciado', default: true },
					{ label: 'Abierto a inscripciones', value: 'abierto' },
					{ label: 'Inscripciones agotadas', value: 'agotadas' },
					{ label: 'Cancelado', value: 'cancelado' }
				]
			},
			{ label: 'Comienza', key: 'start', type: 'datetime-local', width: 1, required: true },
			{ label: 'Termina', key: 'end', type: 'datetime-local', width: 1, required: true },
			{
				label: 'Dirección',
				key: 'location',
				type: 'text',
				width: 1,
				placeholder: 'Calle 123, Ciudad'
			},
			{
				label: 'Nombre de locación',
				key: 'location_name',
				type: 'text',
				width: 1,
				placeholder: 'Centro Cultural Carincio Cortillas'
			}
		],
		material: [
			{ label: 'Redireccionar', key: 'redirect', type: 'checkbox', width: 2 },
			{ label: 'Última fecha de acceso', key: 'access_date', type: 'date', width: 1 },
			{
				label: 'Fecha de publicación original',
				key: 'original_published_date',
				type: 'date',
				width: 1
			}
		],
		wiki: []
	};
	setProperty('updated_date', format(new Date(), 'yyyy-MM-dd') + 'Z-03:00');
</script>

<div class="content">
	<a href={'/' + $page.params.category + '/' + $page.params.postID}>Volver a la publicación</a>
</div>
<!-- <pre>{#key doc}{'---\n' + doc.toString() + '---\n' + postContent}{/key}</pre> -->
<!-- <pre>{doc.get('tags').items}</pre> -->
<ul class="proplist">
	{#each [...postProperties, ...typedProperties[$page.params.category]] as postProp}
		<li class={postProp.type} style:--width={postProp.width}>
			<label for={postProp.key + '-input'}>
				{#if postProp.type != 'checkbox'}
					<span>
						{postProp.label}
						{#if postProp.required}
							<span class="required">*</span>
						{/if}
					</span>
				{/if}
				{#if postProp.type == 'textarea'}
					<textarea
						id="{postProp.key}-input"
						required={postProp.required ?? false}
						name={postProp.key}
						on:input={(e) => setProperty(postProp.key, e?.target?.value.replaceAll(/\n/g, ' '))}
						value={doc.get(postProp.key) ?? ''}
						maxlength="250"
						on:keypress={function (e) {
							if (e.key == 'Enter') e.preventDefault();
						}}
					/>
				{:else if postProp.type == 'array'}
					<TagsInput
						inputid="{postProp.key}-input"
						initialTags={doc.get(postProp.key).items.map((t) => t.value)}
						onUpdate={(tags)=>setProperty(postProp.key, tags)}
					/>
				{:else if postProp.type == 'select'}
					<select
						id="{postProp.key}-input"
						name={postProp.key}
						on:change={(e) => setProperty(postProp.key, e?.target?.value)}
						value={doc.get(postProp.key) ?? ''}
					>
						{#each postProp.options as option}
							<option value={option.value}>{option.label}</option>
						{/each}
					</select>
				{:else}
					<input
						id="{postProp.key}-input"
						type={postProp.type}
						placeholder={postProp.placeholder}
						on:input={(e) =>
							setProperty(
								postProp.key,
								postProp.type == 'checkbox'
									? e?.target?.checked
									: postProp.type.startsWith('date')
									? e?.target.value
										? e?.target?.value + `${postProp.type == 'datetime-local' ? '' : 'Z'}-03:00`
										: ''
									: e?.target?.value
							)}
						min={postProp.type == 'datetime-local'
							? postProp.key == 'end'
								? doc.get('start')?.slice(0, -6)
								: undefined
							: postProp.type == 'date'
							? postProp.key == 'updated_date'
								? doc.get('published_date')?.split('Z')[0]
								: undefined
							: undefined}
						value={postProp.type == 'date'
							? doc.get(postProp.key)?.split('Z')?.[0]
							: postProp.type == 'datetime-local'
							? doc.get(postProp.key)?.slice(0, -6)
							: doc.get(postProp.key) ?? ''}
					/>
				{/if}
				{#if postProp.type == 'checkbox'}
					<span>{postProp.label}</span>
				{/if}
			</label>
		</li>
	{/each}
</ul>

<div class="content">
	<div class="col-2s">
		<form method="POST" action="?/save">
			<textarea hidden name="content" value={'---\n' + doc.toString() + '\n---' + postContent} />
			<input type="text" hidden name="sha" value={sha} />
			<input type="text" hidden name="path" value={path} />
			<input type="submit" value="Guardar" />
		</form>
		{#if form?.save}
			<small style="font-size: var(--step--1)">
				{form?.save + ' ' + new Date().toLocaleString('es-AR')}
			</small>
		{/if}
	</div>
	<small style="font-size: var(--step--1)">
		Los cambios tardarán al menos 1m30s en verse después de guardar. Si pasan más de 5 minutos,
		contactar a
		<a href="https://t.me/Gorro_Rojo">@Gorro_Rojo</a>
	</small>
</div>
<CodeMirror
	lineWrapping
	tabSize={4}
	bind:value={postContent}
	lang={markdown()}
	styles={{
		'&': {
			maxHeight: '70rem',
			maxWidth: '70rem',
			'margin-inline': 'auto',
			background: 'white'
		}
	}}
/>

<style>
	form {
		display: inline;
	}
	.proplist {
		display: flex;
		flex-wrap: wrap;
		row-gap: 0.5em;
		margin-inline: auto;
		max-width: 40rem;
		padding-inline: 5px;
	}
	.proplist li {
		list-style: none;
		display: block;
		flex-basis: calc((var(--width, 2) / 2) * 100%);
	}
	.proplist label {
		display: flex;
		flex-direction: column;
	}
	.proplist .checkbox label {
		display: inline;
	}
	.proplist label span {
		color: var(--1);
		margin-bottom: 0.2em;
	}
	.proplist textarea {
		resize: none;
		height: 6em;
	}
	.proplist input,
	.proplist select,
	.proplist textarea,
	.proplist .checkbox {
		font-size: var(--step-0);
		position: relative;
		padding: 0.4em 0.8em;
		margin-bottom: 0.5em;
		accent-color: var(--1);
		transition: 100ms;
	}
	.proplist .checkbox {
		/* width: 100%; */
		opacity: 0.5;
		&:has(:checked) {
			opacity: 1;
		}
	}
	.proplist .textarea textarea,
	.proplist .select select,
	.proplist .text input,
	.proplist .email input,
	.proplist .url input,
	.proplist .tel input,
	.proplist .datetime-local input,
	.proplist .date input {
		border-radius: 1em;
		border: 0;
		outline: 1px solid var(--1-light);

		&:focus {
			outline-width: 3px;
		}
		&:invalid {
			outline-color: red;
			outline-width: 2px;
		}
		&:placeholder-shown {
			opacity: 0.5;
		}
	}
</style>

# =============================================
# ARCHIVO: ./src/routes/(content)/+layout.svelte
# =============================================

<script>
	import LDTag from '$lib/components/LDTag.svelte';
	import {
		ArrowLeft,
		ArrowRight,
		BookOpen,
		Heart,
		CalendarRange,
		ShoppingCart,
		ChevronLeft,
		Globe
	} from 'lucide-svelte';
	import { siInstagram, siTelegram, siKofi } from 'simple-icons';
	import SimpleIcon from '$lib/components/SimpleIcon.svelte';
	import Navbar from '$lib/components/Navbar.svelte';
	import { fade, fly } from 'svelte/transition';
	import Footer from '$lib/components/Footer.svelte';
	import logo from '../logo.png';
	import { filteredTags, currentPostData, togglePositiveTagFilterFn } from '$lib/utils/stores';
	import { page } from '$app/stores';
	import AgeModal from '$lib/components/AgeModal.svelte';
	import UserMenu from '$lib/components/UserMenu.svelte';
	export let data;
	togglePositiveTagFilterFn.update(
		() =>
			function (checked, tag) {
				if (checked) {
					filteredTags.update((fTags) => [...fTags, tag]);
				} else {
					filteredTags.update((fTags) => [
						...fTags.slice(0, fTags.indexOf(tag)),
						...fTags.slice(fTags.indexOf(tag) + 1)
					]);
				}
				$page.url.searchParams.set('tags', $filteredTags.join(','));
				if ($filteredTags.length > 0) {
					window.history.pushState('', '', `?${$page.url.searchParams.toString()}`);
				} else {
					$page.url.searchParams.delete('tags');
					window.history.replaceState('', '', $page.url);
				}
			}
	);
	/**@type {LD.BreadcrumbList & {"@context": string}}*/
	let ldBreadcrumb = {
		'@context': 'https://schema.org',
		'@type': 'BreadcrumbList',
		itemListElement: [
			{
				'@type': 'ListItem',
				position: 1,
				name:
					$currentPostData?.category == 'wiki' ? 'Kinkipedia' : $currentPostData?.category ?? '',
				item: 'https://example.com/books'
			}
		]
	};
</script>

<svelte:head>
	<link rel="icon" href="/favicon-32x32.png" />
	<meta name="theme-color" content="hsl(319, 90%, 60%)" />
	<meta property="og:url" content={$page.url.href} />
</svelte:head>

<AgeModal />

<header>
	<div id="me">
		<ul id="redes">
			<li>
				<a href="https://cafecito.app/kinkyvibe" target="_blank">
					<SimpleIcon icon={siKofi} />
				</a>
			</li>
			<li>
				<a href="https://t.me/BDSMtextos" target="_blank">
					<SimpleIcon icon={siTelegram} />
				</a>
			</li>
			<li>
				<a href="https://www.instagram.com/kinkyvibeargentina/" target="_blank">
					<SimpleIcon icon={siInstagram} />
				</a>
			</li>
			<!-- recursero -->
			<!-- fanzines -->
		</ul>
		<a id="logo" rel="home" href="/">
			<img src={logo} alt="KinkyVibe" />
		</a>
		<div id="user">
			{#if data.user && data.user !== undefined && data.user.login !== ''}
				<UserMenu user={data.user} />
			{:else}
				<a href="/amigues/KinkyVibe">
					Nuestros servicios
					<ArrowRight size="18" />
				</a>
				<!-- <a href="/login?redirectTo={$page.url}">Iniciar sesión</a> -->
			{/if}
		</div>
	</div>
	<div>
		<Navbar
			links={[
				{ icon: BookOpen, name: 'Material', sub: 'Textos y Materiales', href: '/material' },
				{ icon: Heart, name: 'Amigues', sub: 'Emprendimientos y Profesionales', href: '/amigues' },
				{ icon: CalendarRange, name: 'Calendario', sub: 'Talleres y Eventos', href: '/calendario' },
				{
					icon: ShoppingCart,
					name: 'Tienda',
					sub: 'Juguetes e Implementos',
					href: 'https://tienda.kinkyvibe.ar',
					target: '_blank'
				},
				{ icon: Globe, name: 'Kinkipedia', sub: 'Enciclopedia Fetichista', href: '/wiki' }
			]}
		/>
	</div>
</header>
{#if data.currentRoute != '/'}
	<div class="breadcrumbs">
		<a href={'/'}>
			{#if !($currentPostData && $currentPostData.path == $page.url.pathname)}
				<ArrowLeft size="20" style="translate: 0 .4em" />
			{/if}
			Inicio
		</a>

		{#if $currentPostData && $currentPostData.path == $page.url.pathname}
			<LDTag schema={ldBreadcrumb} />
			<ChevronLeft size="20" style="translate: 0 .4em" />
			<a href={'/' + $currentPostData.category}
				>{$currentPostData.category == 'wiki' ? 'Kinkipedia' : $currentPostData.category}</a
			>
		{/if}
	</div>
{/if}
{#key data.currentRoute}
	<main in:fade={{ duration: 300, delay: 300 }}>
		<slot />
	</main>
{/key}

<Footer />

<style>
	#user {
		/* position: absolute */
	}
	/* header {
		display: grid;
        grid-template-columns: 12em 1fr 10em 5em;
		max-width: 50rem;
		margin-inline: auto;
		height: 3em;
		align-items: center;
        justify-content: space-between;
        align-content: center;
	} */

	#logo {
		color: black;
		display: block;
		text-align: center;
		width: 100%;
		max-height: 10rem;
		text-decoration: none;
	}
	.breadcrumbs {
		display: flex;
		width: 100%;
		max-width: 50rem;
		margin: 0 auto 1.4em;
		/* padding-left: 1em; */
		color: var(--2);
		text-decoration: none;
		align-items: baseline;
		gap: 1em;
		justify-content: center;
		margin-top: 1em;
	}
	.breadcrumbs a {
		text-decoration: none;
		text-transform: capitalize;
	}
	#me {
		display: grid;
		grid-template-areas: 'redes logo user';
		grid-template-columns: 1fr 0.3fr 1fr;
		/* height: 10em; */
		justify-content: center;
		align-items: center;
		gap: 1em;
		max-width: 50rem;
		margin-inline: auto;
		margin-top: 0.5em;
	}
	#me > * {
		/* min-width: 0; */
		max-width: 100%;
	}
	#redes {
		grid-area: redes;
		list-style: none;
		padding: 0;
		/* padding-right: 1em; */
		display: flex;
		gap: 0.6em;
		flex-direction: row-reverse;
		justify-content: space-evenly;
		max-width: 20em;
		justify-self: right;
		--color: var(--1);
	}
	:global(svg) {
		width: 24;
		height: 24px;
	}
	#logo img {
		max-width: 10vh;
		min-width: 2em;
	}
	#user {
		grid-area: user;
		justify-self: left;
		font-size: 0.9em;
		display: flex;
		gap: 0.5em;
		align-items: center;
		text-align: center;
		/* color royalblue */
	}
	#user a,
	#redes a {
		--size: 1.5em;
		/* height: var(--size); */
		font-size: 1.2em;
		/* translate: 0 0.1em; */
	}
	#redes a {
		display: grid;
		place-content: center;
		background: transparent;
		outline: 0;
		transition: 100ms;
	}
	#redes a:hover {
		scale: 1.1;
		box-shadow: 0 0 0.4em rgba(1, 1, 1, 0.2);
		background: white;
		outline: 5px solid white;
	}

	#user a {
		color: white;
		text-decoration: none;
		transition: 300ms;
	}
	#user a:hover {
		scale: 1.1;
		box-shadow: 5px 5px 1em rgba(1, 1, 1, 0.2);
		/* background: var(--1); */
		/* filter: brightness(1.3); */
	}
	#user a:active {
		scale: 1.05;
		box-shadow: none;
	}
	#user a {
		padding-inline: 0.6em;
		display: flex;
		align-items: center;
		gap: 0.5em;
		border-radius: 3em;
		/* background: linear-gradient(125.13deg, #ff009f 6%, #4529ab 100%); */
		background: var(--2);
		max-width: 11em;
	}

	#me li a {
		width: var(--size);
		color: hotpink;
		background: transparent;
		border-radius: 3em;
	}
	#logo {
		grid-area: logo;
	}
	@media (min-width: 1380px) {
		header {
			display: flex;
			justify-content: stretch;
			padding-inline: 2em;
		}
		header > * {
			flex: 1 1;
			width: 100%;
		}
		#me {
			margin-inline: 0;
			grid-template-areas: 'redes logo user';
			grid-template-columns: 10em auto auto;
		}
		.breadcrumbs {
			margin-block: 0 1.5em;
		}
	}
	/* @media (max-width: 580px) {
		#me {
			grid-template-areas: 'logo user redes';
			grid-template-columns: 0.3fr auto 1fr;
			justify-content: center;
			justify-items: center;
			padding-inline: 1em;
		}
		#redes {
			justify-self: unset;
			justify-content: center;
		}
		#user {
			justify-self: unset;
		}
	} */
	@media (max-width: 500px) {
		#me {
			grid-template-areas: 'logo user';
			grid-template-columns: 0.3fr auto;
			flex-wrap: wrap;
			max-width: 100%;
		}
		#redes {
			display: none;
		}
	}
	@media (max-width: 330px) {
		#me {
			grid-template-areas: 'logo';
			grid-template-columns: 1fr;
		}
		#user {
			display: none;
		}
	}
</style>

# =============================================
# ARCHIVO: ./src/routes/(content)/+page.svelte
# =============================================

<script>
	import CardRow from '$lib/components/CardRow.svelte';
	import Carrousel from '$lib/components/Carrousel.svelte';
	import LDTag from '$lib/components/LDTag.svelte';
	import PostList from '$lib/components/PostList.svelte';
	import { page } from '$app/stores';
	export let data;
	let { allPosts } = data;

	const title = 'KinkyVibe.ar';
	const summary = 'Divulgación disidente, producción de eventos y talleres, gestión comunitaria y editorial. Información y encuentros cuir LGTBQIA+ kinky y de BDSM.';
	const canonical = 'https://kinkyvibe.ar';
	/**@type {LD.Schema}*/
	const websiteSchema = {
		'@context': 'https://schema.org',
		'@type': 'Organization',
		'@id': canonical + '#organization',
		url: canonical,
		name: title,
		description: summary,
		sameAs: ['https://twitter.com/kinkyvibearg'],
		logo: 'https://KinkyVibe.ar/favicon-32x32.png'
	};
	import kinkyProfilePic from '../logo.png';
</script>

<svelte:head>
	<title>KinkyVibe.ar</title>
	<link rel="icon" href="/favicon-32x32.png" />
	<link rel="canonical" href={canonical} />
	<meta name="theme-color" content="hsl(319, 90%, 60%)" />

	<meta property="og:url" content="/" />

	<meta property="og:title" content={title} />
	<meta name="twitter:title" content={title} />

	<meta name="description" content={summary} />
	<meta name="twitter:description" content={summary} />
	<meta property="og:description" content={summary} />

	<!-- <meta property="og:image" content={data.featured + ''} /> -->
	<!-- <meta name="twitter:image" content={data.featured + ''} /> -->

	<!-- <meta name="twitter:site" content="@kinkyvibearg" /> -->
	<!-- <meta name="twitter:card" content="summary_large_image" /> -->
	<!-- <meta property="og:type" content="article" /> -->

	<!-- <meta property="article:published_time" content={data.published_date?.toString()} /> -->
	<!-- <meta property="article:modified_time" content={data.updated_date?.toString()} /> -->
	<!-- <meta property="article:author" content={data.authors?.join(', ')} /> -->
	<!-- <meta property="article:section" content="" /> -->
	<!-- <meta property="article:tag" content={data.tags?.join(', ')} /> -->
</svelte:head>

<LDTag schema={websiteSchema} />
<div class="profile-header h-card p-contact hidden">
	<a rel="me" href="https://web.brid.gy/r/https://kinkyvibe.ar/">fed bridgy</a>
	<a class="u-url u-uid" href="https://kinkyvibe.ar/">https://kinkyvibe.ar/</a>
	<img class="profile-pic u-photo" src={kinkyProfilePic} alt="" />
	<h1 class="profile-name p-name">KinkyVibe</h1>
	<a
		target="_blank"
		class="u-pronouns"
		href={'https://pronombr.es/elles,les,les,unes,elles,les,unos,les,es,co,'}
	>
		elles
	</a>
	<p class="p-note">
		Un proyecto de divulgación y acompañamiento disidente. Contamos con una tienda erótica y de
		cuidados, pro-sexo y kinky y trabajamos priorizando la educación sexual y los cuidados éticos
		comunitarios
	</p>
</div>
<main>
	{#if $page.url.searchParams.has('carrousel')}
		<Carrousel
			posts={allPosts.filter(
				(/** @type {{ meta: AnyPostData; }} */ p) =>
					p.meta.category == 'calendario' && new Date(p.meta.start).getTime() > Date.now()
			)}
		/>
	{/if}
	<div class="cardrow">
		<CardRow
			index="0"
			id="calendario"
			title="Talleres y eventos"
			items={allPosts
				.filter(
					(/** @type {{ meta: AnyPostData; }} */ p) =>
						p.meta.category == 'calendario' && new Date(p.meta.start).getTime() > Date.now()
				)
				.sort((a, b) => (a.meta.start > b.meta.start ? 1 : -1))
				.slice(0, 9)}
			--color-1="var(--2-dark)"
			--color-2="var(--1)"
			href="/calendario"
		/>
	</div>
	<div class="cardrow">
		<CardRow
			index="0"
			id="informacion"
			title="Artículos, links y descargables"
			items={allPosts
				.filter(
					(/** @type {{ meta: { category: string; }; }} */ p) => p.meta.category == 'material'
				)
				.slice(0, 9)}
			--color-1="var(--1)"
			--color-2="var(--2-dark)"
			href="/material"
		/>
	</div>
	<div class="cardrow">
		<CardRow
			index="1"
			id="amigues"
			title="Profesionales y emprendimientos"
			items={allPosts
				.filter((/** @type {{ meta: { category: string; }; }} */ p) => p.meta.category == 'amigues')
				.slice(0, 9)}
			--color-1="var(--2-dark)"
			--color-2="var(--1)"
			href="/amigues"
		/>
	</div>
	<div id="lista" />
	<PostList posts={allPosts} />
</main>

<style>
	.hidden {
		display: none !important;
	}
	#lista {
		display: none;
	}
	main {
		/* width: 100%; */
		/* max-width: 50rem; */
		margin: auto;
		display: grid;
		gap: 3rem;
		padding-top: 3rem;
	}
	.cardrow {
		width: 100%;
		max-width: 50rem;
		margin-inline: auto;
	}
	main > * {
		min-width: 0;
		min-height: 0;
	}
</style>

# =============================================
# ARCHIVO: ./src/routes/(content)/amigues/+page.svelte
# =============================================

<script>
	//@ts-nocheck
	import { ArrowRight, Globe } from 'lucide-svelte';
	import InlineTag from '$lib/components/InlineTag.svelte';
	import Tag from '$lib/components/Tag.svelte';
	export let data;
	import PostList from '$lib/components/PostList.svelte';
	import MiniMarkup from '$lib/components/MiniMarkup.svelte';
	import { filteredTags, tagManager, togglePositiveTagFilterFn } from '$lib/utils/stores.js';
	import { flip } from 'svelte/animate';
	import { fade } from 'svelte/transition';
	import { page } from '$app/stores';
	let pinned = ['DemonWeb', 'TallarinesConTuco', 'Gorro_Rojo', 'KinkyVibe','AUCH'];
	let amiguesPosts = data.allPosts
		.filter((p) => p.meta.layout == 'amigues')
		.sort((a, b) => {
			if (pinned.includes(a.meta.postID)) {
				if (pinned.includes(b.meta.postID)) {
					return pinned.indexOf(a.meta.postID) - pinned.indexOf(b.meta.postID);
				} else {
					return -1;
				}
			} else return 0;
		});

	const style = 'display:inline;width:.9em;translate:0 .6em;';
</script>

<svelte:head>
	<title>KinkyVibe.ar - Emprendimientos y profesionales</title>
</svelte:head>
<div class="glosario">
	<p>
		¡Bienvenide! Acá vas a encontrar profesionales que ofrecen <InlineTag tag="sesiones" /> BDSM, que
		dan <InlineTag tag="clases" /> o profesionales de la salud mental que ofrecen espacios de <InlineTag
			tag="terapia"
		/>. También podrás encontrar <InlineTag tag="artistas" internalTag="arte" /> y <InlineTag
			tag="emprendimientos"
			internalTag="emprendimiento"
		/>.
	</p>
	<dl>
		{#each $filteredTags
			.map($tagManager.get)
			.filter((t) => t.parsedDescription) as termino (termino.id)}
			{@const name = termino.visible_name ?? termino.id}
			<div animate:flip in:fade>
				<div>
					<button on:click={() => $togglePositiveTagFilterFn(false, termino.id)}>x</button>
					<dt>
						{termino.icon ?? ''}{name.charAt(0).toUpperCase() + name.slice(1)}
						{#if data.wiki.find((w) => w.meta.wiki == termino.id)}
							<a href="/wiki/{termino.id}" class="gotowiki">
								<span>
									<Globe {style} />
									Es más complejo
									<ArrowRight {style} />
								</span>
							</a>
						{/if}
					</dt>
					<dd>
						{#each termino.parsedDescription as d}
							{#if d.type == 'link'}
								<Tag
									tag={d.line}
									onInput={(evt, tag) => $togglePositiveTagFilterFn(evt.target?.checked, d.line)}
									isCheckbox
									checked={$page.url.searchParams.has('tags') &&
										$page.url.searchParams.get('tags')?.split(',').includes(d.line)}
									--off-background="color-mix(in srgb, var(--1-light) 10%, transparent)"
									--font-size="1em"
									--padding="0.1em 0.2em"
									--border-radius=".3em"
									noBorder
								/>
							{:else}
								{d.line}
							{/if}
						{/each}

						{#if termino.related}
							<small>
								Ver también:
								{#each termino.related as tag, i}
									<Tag
										{tag}
										onInput={(evt, _) => $togglePositiveTagFilterFn(evt.target?.checked, tag)}
										isCheckbox
										checked={$page.url.searchParams.has('tags') &&
											$page.url.searchParams.get('tags')?.split(',').includes(tag)}
										--off-background="color-mix(in srgb, var(--1-light) 10%, transparent)"
										--font-size="1em"
										--padding="0.1em 0.2em"
										--border-radius=".3em"
										noBorder
									/>
									{i < termino.related.length - 1 ? ', ' : ''}
								{/each}
								.
							</small>
						{/if}
					</dd>
				</div>
			</div>
		{/each}
	</dl>
</div>

<PostList posts={amiguesPosts} />

<style lang="scss">
	.glosario {
		max-width: 60rem;
		margin-inline: auto;
		--color: blue;
		background: color-mix(in srgb, var(--color) 2%, white);
		padding: 1em 2em;
		outline: 2px solid var(--color);
		border-radius: 1em;
		color: color-mix(in srgb, var(--color) 50%, black);
		margin-bottom: 2em;
		line-height: 1.5;
		p {
			font-size: var(--step-0);
		}
		button {
			position: absolute;
			left: 0em;
			padding: 0.2em;
			font-size: var(--step-0);
			cursor: pointer;
			border: 0;
			outline: 0;
			background: transparent;
			opacity: 0.3;
			top: 0;
			line-height: 1.4;
			transition: 100ms;
		}
		button:hover {
			opacity: 0.7;
		}
		dl {
			width: 100%;
			margin-inline: auto;
			font-size: var(--step-0);
			position: relative;
		}
		dl > div {
			position: relative;
			margin-top: 1em;
			display: grid;
			grid-template-columns: 1fr;
			transition: 100ms;
			gap: 0.8em;
		}
		dt {
			font-weight: bold;
			color: var(--color);
			margin-left: 1em;
		}
		dd small:last-of-type {
			display: inline-block;
			margin-left: 0.3em;
			opacity: 0.8;
			text-align: right;
		}
		.gotowiki {
			/* --color: var(--2); */
			color: var(--color);
			border: 1px solid color-mix(in srgb, var(--color) 60%, transparent);
			background: color-mix(in srgb, var(--color) 10%, transparent);
			border-radius: 1em;
			padding: 0.3em;
			/* place-content: center; */
			text-align: center;
			text-decoration: none;
			font-size: calc(0.85 * var(--step--1));
			line-height: 1;
			position: relative;
			left: 0;
			transition: 100ms;
			margin-left: 0.5em;
			bottom: 0.1em;
			opacity: 0.8;
			&:hover {
				left: 0.3em;
			}
		}
	}
</style>

# =============================================
# ARCHIVO: ./src/routes/(content)/amigues/[profile]/+page.js
# =============================================

import { fetchPost } from '$lib/utils';

/** @type {import("./$types").PageLoad} */
export async function load({ params }) {
	return await fetchPost('amigues', params.profile);
}

# =============================================
# ARCHIVO: ./src/routes/(content)/amigues/[profile]/+page.svelte
# =============================================

<script>
	import LDTag from '$lib/components/LDTag.svelte';
	import Tags from '$lib/components/Tags.svelte';
	import PostList from '$lib/components/PostList.svelte';
	import { currentPostData } from '$lib/utils/stores.js';
	import { page } from '$app/stores';
	import { processContent } from '$lib/utils';
	export let data;
	currentPostData.set({ category: data.meta.category, path: $page.url.pathname });
	/**@type {(s:string|number|Date)=>(string)}*/
	let toISO = (s) => {
		try {
			return new Date(s).toISOString();
		} catch (e) {
			return s + '';
		}
	};
	let relatedPosts = data.allPosts.filter(
		(p) =>
			data.meta.authors?.some(
				(/**@type string */ a) => p.meta.authors.includes(a) && p.meta.title !== data.meta.title
			) ||
			(data.meta.wiki && p.meta.tags.includes(data.meta.wiki)) ||
			(data.meta.category == 'wiki' && p.meta.tags.includes(data.meta.postID)) ||
			(data.meta.category == 'amigues' &&
				p.meta.authors.includes(data.meta.postID) &&
				p.meta.postID != data.meta.postID)
	);
</script>

<LDTag
	schema={{
		'@context': 'https://schema.org',
		'@type': 'NewsArticle',
		headline: data.meta.title,
		image: [data.meta.featured + ''],
		datePublished: toISO(data.meta.published_date ?? ''),
		dateModified: toISO(data.meta.updated_date ?? data.meta.published_date ?? ''),
		author: data.meta.authors?.map((a) => ({
			'@type': 'Person',
			name: a,
			url: 'https://kinkyvibe.ar/' + a
		}))
	}}
/>
<svelte:head>
	<title
		>{data.meta.title}
		{data.meta.pronoun && (data.meta.pronoun + '').split('/').pop() != 'evitar'
			? `| ${
					data.meta.pronoun.startsWith('https')
						? (data.meta.pronoun + '').split('/').pop()?.split(',')[0].replaceAll('&', '/')
						: data.meta.pronoun
			  }`
			: ''}
	</title>
	<link rel="icon" href="/favicon-32x32.png" />
	<meta name="theme-color" content="hsl(319, 90%, 60%)" />

	<meta property="og:url" content={$page.url.href} />

	<meta property="og:title" content={data.meta.title} />
	<meta name="twitter:title" content={data.meta.title} />

	<meta name="description" content={data.meta.summary} />
	<meta name="twitter:description" content={data.meta.summary} />
	<meta property="og:description" content={data.meta.summary} />

	<meta property="og:image" content={data.meta.featured + ''} />
	<meta name="twitter:image" content={data.meta.featured + ''} />

	<meta name="twitter:site" content="@kinkyvibearg" />
	<meta name="twitter:card" content="summary_large_image" />
	<meta property="og:type" content="article" />

	<meta property="article:published_time" content={data.meta.published_date?.toString()} />
	<meta property="article:modified_time" content={data.meta.updated_date?.toString()} />
	<meta property="article:author" content={data.meta.authors?.join(', ')} />
	<!-- <meta property="article:section" content="" /> -->
	<meta property="article:tag" content={data.meta.tags?.join(', ')} />
</svelte:head>
<a href={$page.url.href} hidden aria-hidden class="u-url">Link</a>
<article class="h-entry h-resume">
	<div class="profile-header h-card p-contact">
		<img src={data.meta.featured + ''} class="profile-pic u-photo" alt="" />
		<h1 id="title" class="profile-name p-name">
			{data.meta.title}
			{#if data.meta.pronoun && (data.meta.pronoun + '').split('/').pop() != 'evitar'}
				{#if (data.meta.pronoun + '').startsWith('https')}
					<a target="_blank" class="u-pronouns" href={data.meta.pronoun + ''}>
						{@html (data.meta.pronoun + '')
							.split('/')
							.pop()
							?.split(',')[0]
							.replaceAll('&', '&nbsp;/&nbsp;')}
					</a>
				{:else}
					<span class="u-pronouns">{data.meta.pronoun}</span>
				{/if}
			{/if}
		</h1>
	</div>
	{#if data.meta.authors && (data.meta.authors.length > 1 || (data.meta.authors.length == 1 && data.meta.authors[0] !== data.meta.postID))}
		{@const authors = data.meta.authors}
		<address>
			{#await data.authorsProfiles}
				{authors.slice(0, authors.length - 1).join(', ') + ' & ' + authors[authors.length - 1]}
			{:then authorsProfiles}
				{#each authors as author, i}
					{@const profile = authorsProfiles?.find(
						(/** @type {ProcessedPost} */ a) => a.meta.postID == author
					)}
					{#if i == authors.length - 1 && i > 0}
						&nbsp;&
					{:else if i > 0},
					{/if}
					{#if profile}
						<a rel="author" class="p-author u-url" href={profile.path}>{author}</a>
					{:else}
						<span class="p-author">{author}</span>
					{/if}
				{/each}
			{/await}
		</address>
	{/if}
	{#if data.meta.tags}
		<div id="tags">
			<Tags tags={data.meta.tags} />
		</div>
	{/if}
	{#if data.meta.summary}
		<div class="content">
			<p class="p-summary">
				{data.meta.summary}
			</p>
		</div>
	{/if}
	<div class="content" use:processContent>
		<svelte:component this={data.content} />
		<a href={data.meta.link} target="_blank" class="cta"
			>{data.meta.link_text ?? 'Ir a su página'}</a
		>
	</div>
</article>

{#if relatedPosts.length > 0}
	{@const relatedAuthors = [...new Set([data.meta.postID, ...data.meta.authors])]}
	<div class="content">
		<h3>
			Más cosas de
			{relatedAuthors.length == 1
				? relatedAuthors[0]
				: [relatedAuthors.slice(0, -1).join(', '), relatedAuthors.slice(-1)[0]].join(' o ')}
		</h3>
	</div>
	<PostList posts={relatedPosts} />
{/if}

<style lang="scss">
	#tags {
		margin-inline: auto;
		max-width: 70rem;
		width: 100%;
		margin-top: 2em;
		justify-content: center;
	}
	.u-pronouns {
		font-size: 0.5em;
		opacity: 0.7;
		text-decoration: none;
	}
	.profile-header {
		display: grid;
		grid-template-columns: 4em 1fr;
		gap: 1em;
		align-items: center;
		font-size: var(--step-3);
		justify-content: center;
		justify-items: start;
		width: max-content;
		margin-inline: auto;
		max-width: 100%;
	}
	.profile-pic {
		display: block;
		border-radius: 9999em;
		object-fit: cover;
		max-height: 4em;
		width: auto;
		justify-self: right;
		aspect-ratio: 1;
		translate: 0 -0.2em;
	}
	.profile-name {
		justify-self: left;
		text-align: left;
		max-width: 100%;
	}

	@media (max-width: 630px) {
		.profile-header {
			grid-auto-flow: row;
		}
	}
</style>

# =============================================
# ARCHIVO: ./src/routes/(content)/calendario.ics/+server.js
# =============================================

import { fetchMarkdownPosts } from '$lib/utils';
import * as ics from 'ics';

/**
 * Converts a string to an array representing the date and time.
 *
 * @param {string} s - The string to convert.
 * @return {import('ics').DateArray} An array representing the date and time with the following format: [year, month, day, hours, minutes].
 */
function stringToDateArray(s) {
	let d = new Date(s);
	return [d.getFullYear(), d.getMonth() + 1, d.getDate(), d.getHours(), d.getMinutes()];
}
/** @type {import('./$types').RequestHandler} */
export async function GET() {
	/**@type ics.EventAttributes[] */
	let events = [];
	const allPosts = await fetchMarkdownPosts();
	const eventPosts = allPosts.filter((p) => p.meta.category == 'calendario');
	for (let post of eventPosts) {
		if (post.meta.status == 'cancelado') continue
		const organizer = post.meta.tags.includes('KinkyVibe') ? 'KinkyVibe' : post.meta.authors[0];
		const postPath = 'https://kinkyvibe.ar' + post.path;
		/**@type ics.EventAttributes */
		let event = {
			start: stringToDateArray(post.meta.start),
			end: stringToDateArray(post.meta.end ?? post.meta.start + post.meta.duration),
			title: post.meta.title,
			url: postPath,
			description: postPath + ' \n' + post.meta.summary,
			htmlContent: `<!DOCTYPE html><html><body><p><a href="${postPath}">${postPath}</a></p><p>${post.meta.summary}</p></body></html>`,
			location: post.meta.location ?? postPath,
			calName: 'KinkyVibe',
			organizer: {
				name: organizer,
				email:
					allPosts.find((p) => p.meta.postID == organizer)?.meta?.email ??
					'kinkyvibe@gmail.com'
			},
			// @ts-ignore
			status:
				// @ts-ignore
				{
					abierto: 'CONFIRMED',
					cancelado: 'CANCELLED',
					anunciado: 'TENTATIVE',
					agotadas: 'CONFIRMED'
				}[post.meta.status] ?? 'CONFIRMED' //TODO añadir email
		};
		events.push(event);
	}
	return new Response(ics.createEvents(events).value, {
		headers: { 'Content-Type': 'text/calendar' }
	});
}

# =============================================
# ARCHIVO: ./src/routes/(content)/calendario/+page.svelte
# =============================================

<script>
	import 'add-to-calendar-button';
	import Calendar from '$lib/components/Calendar.svelte';
	import PostList from '$lib/components/PostList.svelte';
	import { addDays, format, isSameMonth, isPast, addMonths, addHours } from 'date-fns';
	import { view_date } from '$lib/utils/stores.js';
	import CalendarHeader from '$lib/components/CalendarHeader.svelte';
	import CardRow from '$lib/components/CardRow.svelte';
	export let data;
	let calendarioPosts = data.allPosts.filter((p) => p.meta.layout == 'calendario');
	/** @type {Record<string, Array<ProcessedPost & {i: number}>>} */
	let days = calendarioPosts.reduce((dates, post, i) => {
		let start_date = format(addDays(new Date(post.meta.start), 0), 'yyyy-MM-dd');
		// @ts-ignore
		if (dates[start_date]) {
			// @ts-ignore
			dates[start_date].push({ i, ...post });
		} else {
			// @ts-ignore
			dates[start_date] = [{ i, ...post }];
		}
		return dates;
	}, {});
	let skip_month_flag = true;

	Object.entries(days).forEach(([date, posts]) => {
		// if all the posts this month are inthe past, set view_date to next month
		if (isSameMonth(addHours(new Date(date), 3), $view_date) && !isPast(new Date(date))) {
			skip_month_flag = false;
		}
	});
	if (skip_month_flag) $view_date = addMonths(new Date(), 1);
</script>

<svelte:head>
	<title>KinkyVibe.ar - Calendario</title>
</svelte:head>

<div class="cardrow">
	<CardRow
		items={calendarioPosts
			.filter((p) => !isPast(new Date(p.meta.start)))
			.sort((a, b) => (a.meta.start > b.meta.start ? 1 : -1))}
		--color-1="transparent"
		setId={false}
	/>
</div>

<div id="container">
	<div id="calendar">
		<CalendarHeader />
		<Calendar let:date let:today let:past>
			{@const events = days?.[date]}
			{@const featuredEvent =
				events?.filter((e) => e.meta.tags.includes('KinkyVibe'))?.[0] ??
				events?.filter((e) => e.meta.featured)?.[0]}
			{@const background = featuredEvent?.meta?.featured}
			<button
				class:today
				class:past
				disabled={!events}
				style={background ? `--event-image: url("${background}");` : ''}
				style:--evt-color={featuredEvent?.meta?.tags?.includes('KinkyVibe')
					? 'var(--1)'
					: 'var(--2)'}
			>
				<div class="date" class:today>
					{addDays(new Date(date), 1).toLocaleDateString('es-AR', { day: 'numeric' })}
				</div>
				{#if events}
					<div class="dot" />
					{#each events.sort( (a, b) => (new Date(a.meta.start).getTime() > new Date(b.meta.start).getTime() ? 1 : -1) ) as event}
						{@const start = new Date(event.meta.start)}
						{@const minutes = format(start, 'mm')}
						<a
							href={'#' + event.path}
							class="bar"
							class:dim={event.meta.status == 'cancelado'}
							style:--evt-color={event?.meta?.tags?.includes('KinkyVibe') ? 'var(--1)' : 'var(--2)'}
						>
							<span>
								{event.meta.title ?? ' '}
								&sdot;
								<strong
									>{format(start, 'h')}{minutes == '00' ? '' : ':' + minutes}{format(
										start,
										'aaa'
									)}</strong
								>
							</span>
						</a>
					{/each}
				{/if}
			</button>
		</Calendar>
	</div>
	<div id="postlist">
		<PostList
			filter={{ prop: 'visible', value: true }}
			posts={calendarioPosts
				.map((p) => ({
					meta: {
						...p.meta,
						published_date: p.meta.start
					},
					visible: isSameMonth(new Date(p.meta.start), $view_date),
					path: p.path
				}))
				.sort((a, b) => (a.meta.start > b.meta.start ? 1 : -1))}
		/>
		<p class="subscribe">
			También podés
			<a
				href="https://calendar.google.com/calendar/r?cid=webcal%3A%2F%2Fkinkyvibe.ar%2Fcalendario.ics"
				target="_blank"
			>
				suscribirte a este calendario en google
			</a>
			para nunca perderte de nada!
		</p>
	</div>
</div>

<style lang="scss">
	.subscribe {
		font-size: var(--step-1);
		text-align: center;
		background: var(--1-dark);
		color: white;
		border-radius: 1em;
		padding: 1em 1.5em;
		/* max-width: max-content; */
		margin: 2em auto;
		a {
			background: var(--2);
			border: 1px solid var(--4);
			color: white;
			--font: 'Lato', sans-serif;
			text-decoration: none;
			padding: .3em;
			border-radius: .3em;
			&:hover {
				border-color: white;
				color: white;
				box-shadow: 0 0 1em var(--4-light);
			}
		}
	}
	.cardrow {
		max-width: 1200px;
		margin-inline: auto;
	}
	strong {
		color: unset;
	}
	#calendar {
		max-width: 50rem;
		margin-inline: auto;
		height: 40em;
		margin-bottom: 3em;
		padding-bottom: 3em;
		width: 100%;
		min-height: 0;
		min-width: 0;
	}
	button.past {
		opacity: 0.2 !important;
	}
	button.today {
		outline: 3px solid var(--1);
		opacity: 1;
		.date {
			scale: 1.2;
		}
	}
	button {
		opacity: 0.7;
		display: flex;
		padding: 0;
		position: relative;
		width: 100%;
		height: 100%;
		aspect-ratio: 1/1;
		min-height: 0;
		scale: 0.9;
		flex-direction: column;
		justify-content: start;
		align-items: stretch;
		gap: 0.2em;
		background-color: white;
		border: 0;
		border-radius: 0.1rem 0.1rem 1rem 1rem;
		transition: all 0.1s ease-in;
		.dot {
			display: none;
			min-height: 0;
		}
		.bar {
			width: 100%;
			height: auto;
			min-height: 0;
			z-index: 1;
			outline: 3px solid var(--evt-color);
			outline-offset: -2px;
			transition: 200ms ease-in;

			font-size: 1.3em;
			overflow: hidden;
			color: white;
			text-align: left;
			text-overflow: ellipsis;
			text-transform: capitalize;
			text-decoration: none !important;
			white-space: nowrap;
			background: var(--evt-color);
			transition: 100ms;
		}
		.dim {
			opacity: 0.5;
			pointer-events: none;
		}

		.date {
			display: grid;
			place-content: center;
			font-size: 2em;
			color: rgba(1, 1, 1, 0.5);
			position: absolute;
			top: 0;
			right: 0;
			left: 0;
			bottom: 0;
		}
	}

	button:has(.dot) {
		cursor: pointer;
		opacity: 1;
		&:hover {
			gap: 0.5em;
			.bar {
				height: 100%;
				white-space: normal;
			}
		}
		.date {
			display: none;
		}
		--post-color: var(--evt-color);
		background: var(
			--event-image,
			linear-gradient(
				to bottom right,
				color-mix(in srgb, var(--post-color, var(--2)) 70%, white) 0%,
				var(--post-color, var(--2)) 50%,
				color-mix(in srgb, var(--post-color, var(--2)) 70%, black) 100%
			)
		);
		background-position: center center;
		background-repeat: repeat;
		background-size: cover;
	}
	@media (min-width: 1200px) {
		#container {
			display: grid;
			grid-template-areas: 'postlist calendar';
			grid-template-columns: 1fr 1fr;
			margin-inline: 1em 3em;
			gap: 2em;
			position: sticky;
			top: 0;
		}
		#calendar {
			grid-area: calendar;
			min-width: 0;
			height: 90vh;
			position: sticky;
			top: 0;
		}
		#postlist {
			grid-area: postlist;
			min-width: 0;
		}
	}
</style>

# =============================================
# ARCHIVO: ./src/routes/(content)/calendario/[event]/+page.js
# =============================================

import { fetchPost } from '$lib/utils';

/** @type {import("./$types").PageLoad} */
export async function load({ params }) {
	return await fetchPost('calendario', params.event);
}

# =============================================
# ARCHIVO: ./src/routes/(content)/calendario/[event]/+page.svelte
# =============================================

<script>
	import LDTag from '$lib/components/LDTag.svelte';
	import Tags from '$lib/components/Tags.svelte';
	import PostList from '$lib/components/PostList.svelte';
	import 'add-to-calendar-button';
	import { format } from 'date-fns';
	import { currentPostData } from '$lib/utils/stores.js';
	import { page } from '$app/stores';
	import { processContent } from '$lib/utils';
	export let data;
	currentPostData.set({ category: data.meta.category, path: $page.url.pathname });
	/**@type {(s:string|number|Date)=>(string)}*/
	let toISO = (s) => {
		try {
			return new Date(s).toISOString();
		} catch (e) {
			return s + '';
		}
	};
	let relatedPosts = data.allPosts.filter(
		(p) =>
			data.meta.authors?.some(
				(/**@type string */ a) => p.meta.authors.includes(a) && p.meta.title !== data.meta.title
			) ||
			(data.meta.wiki && p.meta.tags.includes(data.meta.wiki)) ||
			(data.meta.category == 'wiki' && p.meta.tags.includes(data.meta.postID)) ||
			(data.meta.category == 'amigues' && p.meta.authors.includes(data.meta.postID) && p.meta.postID != data.meta.postID)
	)
</script>

<LDTag
	schema={/**@type LD.Event & {"@context":"https://schema.org"}*/ {
		'@context': 'https://schema.org',
		'@type': 'Event',
		name: data.meta.title,
		startDate: toISO(data.meta.start ?? ''),
		endDate: toISO(data.meta.end ?? (data.meta.start ?? '') + (data.meta.duration ?? '')),
		eventAttendanceMode: data.meta.location
			? 'https://schema.org/OnlineEventAttendanceMode'
			: 'https://schema.org/OfflineEventAttendanceMode',
		eventStatus:
			data.meta.status == 'cancelado'
				? 'https://schema.org/EventCancelled'
				: 'https://schema.org/EventScheduled',
		location: data.meta.location
			? {
					'@type': 'Place',
					name: data.meta.location_name ?? data.meta.title,
					address: { '@type': 'PostalAddress', name: data.meta.location }
			  }
			: { '@type': 'VirtualLocation', url: data.meta.link },
		image: [data.meta.featured + ''],
		description: data.meta.summary,
		organizer: {
			'@type': data.meta.tags?.includes('KinkyVibe') ? 'Organization' : 'Person',
			name: data.meta.tags?.includes('KinkyVibe')
				? 'KinkyVibe'
				: data.meta.authors?.[0] ?? 'KinkyVibe',
			url:
				'https://kinkyvibe.ar/' +
				(data.meta.tags?.includes('KinkyVibe')
					? 'KinkyVibe'
					: data.meta.authors?.[0] ?? 'KinkyVibe')
		}
		//   "offers": {
		//     "@type": "Offer",
		//     "url": "https://www.example.com/event_offer/12345_201803180430",
		//     "price": "30",
		//     "priceCurrency": "USD",
		//     "availability": "https://schema.org/InStock",
		//     "validFrom": "2024-05-21T12:00"
		//   },
		//   "performer": {
		//     "@type": "PerformingGroup",
		//     "name": "Kira and Morrison"
		//   },
	}}
/>
<svelte:head>
	<title>{data.meta.title} - KinkyVibe.ar</title>
	<link rel="icon" href="/favicon-32x32.png" />

	<meta name="theme-color" content="hsl(319, 90%, 60%)" />

	<meta property="og:url" content={$page.url.href} />

	<meta property="og:title" content={data.meta.title} />
	<meta name="twitter:title" content={data.meta.title} />

	<meta name="description" content={data.meta.summary} />
	<meta name="twitter:description" content={data.meta.summary} />
	<meta property="og:description" content={data.meta.summary} />

	<meta property="og:image" content={data.meta.featured + ''} />
	<meta name="twitter:image" content={data.meta.featured + ''} />

	<meta name="twitter:site" content="@kinkyvibearg" />
	<meta name="twitter:card" content="summary_large_image" />
	<meta property="og:type" content="article" />

	<meta property="article:published_time" content={data.meta.published_date?.toString()} />
	<meta property="article:modified_time" content={data.meta.updated_date?.toString()} />
	<meta property="article:author" content={data.meta.authors?.join(', ')} />
	<!-- <meta property="article:section" content="" /> -->
	<meta property="article:tag" content={data.meta.tags?.join(', ')} />
</svelte:head>
<a href={$page.url.href} hidden aria-hidden class="u-url">Link</a>
<article class="h-entry h-event">
	<h1 id="title p-name">{data.meta.title}</h1>
	
	{#if data.meta.authors && (data.meta.authors.length > 1 || (data.meta.authors.length == 1 && data.meta.authors[0] !== data.meta.postID))}
		{@const authors = data.meta.authors}
		<address>
			{#await data.authorsProfiles}
				{authors.slice(0, authors.length - 1).join(', ') + ' & ' + authors[authors.length - 1]}
			{:then authorsProfiles}
				{#each authors as author, i}
					{@const profile = authorsProfiles?.find(
						(/** @type {ProcessedPost} */ a) => a.meta.postID == author
					)}
					{#if i == authors.length - 1 && i > 0}
						&nbsp;&
					{:else if i > 0},
					{/if}
					{#if profile}
						<a rel="author" class="p-author u-url" href={profile.path}>{author}</a>
					{:else}
						<span class="p-author">{author}</span>
					{/if}
				{/each}
			{/await}
		</address>
	{/if}

	{#if data.meta.status == 'cancelado'}
	<h1 id="title p-name"><u>CANCELADO</u></h1>
	{:else}
	<div class="event-header">
		{#if data.meta.featured}<img src={data.meta.featured + ''} alt="poster" />{/if}
		<p class="event-times">
			<small>desde</small><time class="dt-start" datetime={data.meta.start}
				>{new Date(data.meta.start).toLocaleString('es-AR', {
					dateStyle: 'long',
					timeStyle: 'short'
				})}hs</time
			>
			<small>hasta</small><time
				class="dt-end"
				datetime={data.meta.end ?? data.meta.start + data.meta.duration}
				>{new Date(data.meta.end ?? data.meta.start + data.meta.duration).toLocaleString('es-AR', {
					dateStyle: 'long',
					timeStyle: 'short'
				})}hs</time
			>
			<small>en</small>
			<span class="p-location">
				{data.meta.location ?? 'Online'}
			</span>
		</p>
		<div class="event-atcb">
			{#if data.meta.link}
				<div class="event-link-wrapper">
					<a href={data.meta.link}>{data.meta.link_text ?? 'Inscripción'}</a>
				</div>
			{/if}
			<add-to-calendar-button
				style={`
					--btn-background: var(--1);
					--btn-border: var(--1);
					--btn-text: white;
					--btn-shadow: none;
					--btn-background-hover: var(--1-light);
					--btn-border-hover: white;
					--btn-text-hover: white;
					--btn-shadow-hover: 0 0 1em var(--1-light);
					--font: 'Lato', sans-serif;
					`}
				trigger="click"
				name={data.meta.title}
				description={data.meta.summary}
				startDate={format(new Date(data.meta.start), 'yyyy-MM-dd')}
				startTime={format(new Date(data.meta.start), 'HH:mm')}
				endDate={format(
					new Date(data.meta.end ?? data.meta.start + data.meta.duration),
					'yyyy-MM-dd'
				)}
				status={{
					abierto: 'CONFIRMED',
					cancelado: 'CANCELLED',
					anunciado: 'TENTATIVE',
					agotadas: 'CONFIRMED'
				}[data.meta.status] ?? 'CONFIRMED'}
				endTime={format(new Date(data.meta.end ?? data.meta.start + data.meta.duration), 'HH:mm')}
				timeZone="America/Buenos_Aires"
				options="'iCal','Apple','Outlook.com','Google','MicrosoftTeams','Microsoft365','Yahoo'"
				language="es"
				iCalFileName="Sample Event"
				listStyle="overlay"
				label="Agregar a mi calendario"
				buttonStyle="3d"
				organizer="Mel|kinkyvibe@gmail.com"
				size="8"
			/>
		</div>
	</div>
	{/if}
	{#if data.meta.tags}
		<div id="tags">
			<Tags tags={data.meta.tags} />
		</div>
	{/if}
	<div class="content" use:processContent>
		<svelte:component this={data.content} />
		{#if data.meta.link && data.meta.link_text}
			<a href={data.meta.link} target="_blank" class="cta">{data.meta.link_text}</a>
		{/if}
	</div>
	{#if data.meta.tags.includes('KinkyVibe')}
		<div id="cafecito">
			Este material fue proporcionado por <a rel="author" href="/amigues/KinkyVibe">nosotres</a> ✨.
			Si te resultó valioso,
			<a href="https://cafecito.app/kinkyvibe" target="_blank"
				>considerá apoyarnos con algún cafecito</a
			>. 🤗
		</div>
	{/if}
</article>

<hr />

{#if data.meta.authors.length > 0}
	{#await data.authorsProfiles then authorsData}
		{#each authorsData ?? [] as { path, meta: author }}
			<a class="author-callout" rel="author" href={path}>
				<img
					class="author-image"
					src={(author.logo ?? author.photo ?? author.featured) + ''}
					alt=""
				/>
				<span class="author-title">{author.title}</span>
				<span class="author-summary">{author.summary}</span>
			</a>
		{/each}
	{/await}
{/if}

{#if relatedPosts.length > 0}
	<div class="content">
		<h3>
			Más cosas de
			{data.meta.authors.length == 1
				? data.meta.authors[0]
				: [data.meta.authors.slice(0, -1).join(', '), data.meta.authors.slice(-1)[0]].join(' o ')}
		</h3>
	</div>
	<PostList posts={relatedPosts} />
{/if}

<style lang="scss">
	#cafecito {
		max-width: 50rem;
		margin: 2em auto;
		width: 100%;
		padding: 1em;
		color: white;
		border-radius: 0.3em;
	}
	#cafecito {
		margin-top: 1em;
		font-size: var(--step-1);
		background: var(--2-light);
		a {
			--color: var(--4-light);
		}
	}
	#tags {
		margin-inline: auto;
		max-width: 70rem;
		width: 100%;
		margin-top: 2em;
		justify-content: center;
	}
	.author-callout {
		text-decoration: none;
		font-style: italic;
		font-size: 1.5em;
		padding: 0.4rem;
		border-radius: 999em;
		background: color-mix(in srgb, var(--2) 10%, transparent);
		outline: 2px solid var(--2);
		color: var(--2);
		display: grid;
		grid-template-areas: 'img title' 'img summary';
		grid-template-columns: 7rem 1fr;
		align-items: center;
		gap: 0.6rem;
		max-width: 50rem;
		margin: 1em auto;
		& > * {
			min-height: 0;
			min-width: 0;
		}
		.author-image {
			/* height: 1.5em; */
			border-radius: 999em;
			/* display: inline-block; */
			grid-area: img;
			max-height: 100%;
			max-width: 100%;
		}
		.author-title {
			grid-area: title;
			font-size: 1.5em;
			text-decoration: underline var(--1);
			color: black;
			line-height: 1;
		}
		.author-summary {
			grid-area: summary;
			padding-right: 1em;
		}
	}

	@media (max-width: 500px) {
		.author-callout {
			grid-template-areas: 'img title' 'summary summary';
			border-radius: 2.6em;
			.author-image {
				z-index: 1;
			}
			.author-title {
				padding-right: 0.5em;
			}
			.author-summary {
				padding: 2em;
				padding-top: 0;
			}
		}
	}
	/* ------------------------------------- */
	.event-header {
		background: var(--2-dark);
		color: white;

		--radius: 1em;
		border-radius: var(--radius);
		/* overflow: hidden; */
		display: grid;
		grid-template-areas: 'title title' 'pic time' 'pic location' 'button button';
		grid-template-columns: auto 4fr;
		column-gap: 0.3em;
		font-size: var(--step-1);
		margin-inline: auto;
		margin-top: 1.4em;
		max-width: 40rem;
		outline: 3px solid var(--2-dark);
		/* outline: 2px dotted var(--2); */
		& > * {
			min-width: 0;
		}

		img {
			max-width: 100%;
			max-height: 100%;
			height: 10em;
			min-width: 0;
			min-height: 0;
			grid-area: pic;
			border-top-left-radius: var(--radius);
		}
		/* h1 {
			grid-area: title;
		} */
		small {
			opacity: 0.7;
		}
		.event-times {
			grid-area: time;
			display: flex;
			flex-direction: column;
			margin-block: 0;
			padding-top: 0.2em;
		}
		.event-atcb {
			align-self: center;
			justify-self: center;
			grid-area: button;

			display: flex;
			flex-direction: row;
			justify-content: center;
			background: white;
			width: 100%;
			flex-wrap: wrap;
			.event-link-wrapper {
				--base-font-size-l: 18px;
				--base-font-size-m: 18px;
				--base-font-size-s: 18px;
				display: block;
				padding: 5px;
				position: relative;
				font-size: var(--base-font-size-m);
			}
			a {
				align-items: center;
				background-color: var(--1);
				border: 1px solid var(--1);
				border-radius: 6px;
				display: flex;
				font-weight: bold;
				justify-content: center;
				line-height: 1.5em;
				max-width: 350px;
				min-width: 10em;
				padding: 0.65em 1em;
				position: relative;
				touch-action: manipulation;
				user-select: none;
				-webkit-user-select: none;
				width: 100%;
				z-index: 1;
				&:hover {
					background: var(--1-light);
					color: unset;
					text-decoration: unset;
					box-shadow: 0 0 0.5em var(--1-light);
				}
			}
		}
	}
	@media (max-width: 500px) {
		.event-header {
			grid-template-areas: 'title' 'time' 'location' 'button';
			column-gap: 0;
			.event-times {
				padding-left: 0.5em;
				padding-bottom: 0.5em;
			}
			img {
				display: none;
			}
		}
	}
</style>

# =============================================
# ARCHIVO: ./src/routes/(content)/material/+page.svelte
# =============================================

<script>
	//@ts-nocheck
	export let data;
	import MiniMarkup from '$lib/components/MiniMarkup.svelte';
	import InlineTag from '$lib/components/InlineTag.svelte';
	import PostList from '$lib/components/PostList.svelte';
	import Tag from '$lib/components/Tag.svelte';
	import { filteredTags, tagManager, togglePositiveTagFilterFn } from '$lib/utils/stores';
	import { ArrowRight, Globe } from 'lucide-svelte';
	import { page } from '$app/stores';
	import { flip } from 'svelte/animate';
	import { fade } from 'svelte/transition';

	const style = 'display:inline;width:.9em;translate:0 .6em;';
</script>

<svelte:head>
	<title>KinkyVibe.ar - Artículos, links y descargables</title>
</svelte:head>
<div class="glosario">
	<p>
		¡Bienvenide! Si estás empezando, podés filtrar acá el material <InlineTag tag="inicial" /> sobre
		<InlineTag tag="BDSM" />
		podés buscar según qué <InlineTag tag="práctica" /> te interesa (por ej. <InlineTag
			tag="cuerdas"
		/>, <InlineTag tag="electro" /> play o <InlineTag tag="impacto" />), qué idioma preferís (<InlineTag
			tag="inglés"
		/> o <InlineTag tag="español" />) o en qué formato (<InlineTag tag="descargable" /> o <InlineTag
			tag="online"
		/>).
	</p>
	<dl>
		{#each $filteredTags.map($tagManager.get).filter((t) => t.parsedDescription) as termino (termino.id)}
			{@const name = termino.visible_name ?? termino.id}
			<div animate:flip in:fade>
				<div>
					<button on:click={() => $togglePositiveTagFilterFn(false, termino.id)}>x</button>
					<dt>
						{termino.icon ?? ''}{name.charAt(0).toUpperCase() + name.slice(1)}
						{#if data.wiki.find((w) => w.meta.wiki == termino.id)}
							<a href="/wiki/{termino.id}" class="gotowiki">
								<span>
									<Globe {style} />
									Es más complejo
									<ArrowRight {style} />
								</span>
							</a>
						{/if}
					</dt>
					<dd>
						{#each termino.parsedDescription as d}
							{#if d.type == 'link'}
								<Tag
									tag={d.line}
									onInput={(evt, tag) => $togglePositiveTagFilterFn(evt.target?.checked, d.line)}
									isCheckbox
									checked={$page.url.searchParams.has('tags') &&
										$page.url.searchParams.get('tags')?.split(',').includes(d.line)}
									--off-background="color-mix(in srgb, var(--1-light) 10%, transparent)"
									--font-size="1em"
									--padding="0.1em 0.2em"
									--border-radius=".3em"
									noBorder
								/>
							{:else}
								{d.line}
							{/if}
						{/each}

						{#if termino.related}
							<small>
								Ver también:
								{#each termino.related as tag, i}
									<Tag
										{tag}
										onInput={(evt, _) => $togglePositiveTagFilterFn(evt.target?.checked, tag)}
										isCheckbox
										checked={$page.url.searchParams.has('tags') &&
											$page.url.searchParams.get('tags')?.split(',').includes(tag)}
										--off-background="color-mix(in srgb, var(--1-light) 10%, transparent)"
										--font-size="1em"
										--padding="0.1em 0.2em"
										--border-radius=".3em"
										noBorder
									/>
									{i < termino.related.length - 1 ? ', ' : ''}
								{/each}
								.
							</small>
						{/if}
					</dd>
				</div>
			</div>
		{/each}
	</dl>
</div>

<PostList posts={data.allPosts.filter((p) => p.meta.layout == 'material')} />

<style lang="scss">
	.glosario {
		max-width: 60rem;
		margin-inline: auto;
		--color: blue;
		background: color-mix(in srgb, var(--color) 2%, white);
		padding: 1em 2em;
		outline: 2px solid var(--color);
		border-radius: 1em;
		color: color-mix(in srgb, var(--color) 50%, black);
		margin-bottom: 2em;
		line-height: 1.5;
		p {
			font-size: var(--step-0);
		}
		button {
			position: absolute;
			left: 0em;
			padding: 0.2em;
			font-size: var(--step-0);
			cursor: pointer;
			border: 0;
			outline: 0;
			background: transparent;
			opacity: 0.3;
			top: 0;
			line-height: 1.4;
			transition: 100ms;
		}
		button:hover {
			opacity: 0.7;
		}
		dl {
			width: 100%;
			margin-inline: auto;
			font-size: var(--step-0);
			position: relative;
		}
		dl > div {
			position: relative;
			margin-top: 1em;
			display: grid;
			grid-template-columns: 1fr;
			transition: 100ms;
			gap: 0.8em;
		}
		dt {
			font-weight: bold;
			color: var(--color);
			margin-left: 1em;
		}
		dd small:last-of-type {
			display: inline-block;
			margin-left: 0.3em;
			opacity: 0.8;
			text-align: right;
		}
		.gotowiki {
			/* --color: var(--2); */
			color: var(--color);
			border: 1px solid color-mix(in srgb, var(--color) 60%, transparent);
			background: color-mix(in srgb, var(--color) 10%, transparent);
			border-radius: 1em;
			padding: 0.3em;
			/* place-content: center; */
			text-align: center;
			text-decoration: none;
			font-size: calc(0.85 * var(--step--1));
			line-height: 1;
			position: relative;
			left: 0;
			transition: 100ms;
			margin-left: 0.5em;
			bottom: 0.1em;
			opacity: 0.8;
			&:hover {
				left: 0.3em;
			}
		}
	}
</style>

# =============================================
# ARCHIVO: ./src/routes/(content)/material/[post]/+page.js
# =============================================

import { fetchPost } from '$lib/utils';
import { redirect } from '@sveltejs/kit';

/** @type {import("./$types").PageLoad} */
export async function load({ params }) {
	let post = await fetchPost('material', params.post);
	if (post.meta?.redirect) {
		throw redirect(307, post.meta.link);
	}
	return post;
}

# =============================================
# ARCHIVO: ./src/routes/(content)/material/[post]/+page.svelte
# =============================================

<script>
	import LDTag from '$lib/components/LDTag.svelte';
	import Tags from '$lib/components/Tags.svelte';
	import PostList from '$lib/components/PostList.svelte';
	import { currentPostData } from '$lib/utils/stores.js';
	import { page } from '$app/stores';
	import { processContent } from '$lib/utils';
	export let data;
	currentPostData.set({ category: data.meta.category, path: $page.url.pathname });
	/**@type {(s:string|number|Date)=>(string)}*/
	let toISO = (s) => {
		try {
			return new Date(s).toISOString();
		} catch (e) {
			return s + '';
		}
	};
	let relatedPosts = data.allPosts.filter(
		(p) =>
			data.meta.authors?.some(
				(/**@type string */ a) => p.meta.authors.includes(a) && p.meta.title !== data.meta.title
			) ||
			(data.meta.wiki && p.meta.tags.includes(data.meta.wiki)) ||
			(data.meta.category == 'wiki' && p.meta.tags.includes(data.meta.postID)) ||
			(data.meta.category == 'amigues' && p.meta.authors.includes(data.meta.postID) && p.meta.postID != data.meta.postID)
	)
</script>

<LDTag
	schema={{
		'@context': 'https://schema.org',
		'@type': 'NewsArticle',
		headline: data.meta.title,
		image: [data.meta.featured + ''],
		datePublished: toISO(data.meta.published_date ?? ''),
		dateModified: toISO(data.meta.updated_date ?? data.meta.published_date ?? ''),
		author: data.meta.authors?.map((a) => ({
			'@type': 'Person',
			name: a,
			url: 'https://kinkyvibe.ar/' + a
		}))
	}}
/>
<svelte:head>
	<title>{data.meta.title} - KinkyVibe.ar</title>
	<link rel="icon" href="/favicon-32x32.png" />
	<meta name="theme-color" content="hsl(319, 90%, 60%)" />

	<meta property="og:url" content={$page.url.href} />

	<meta property="og:title" content={data.meta.title} />
	<meta name="twitter:title" content={data.meta.title} />

	<meta name="description" content={data.meta.summary} />
	<meta name="twitter:description" content={data.meta.summary} />
	<meta property="og:description" content={data.meta.summary} />

	<meta property="og:image" content={data.meta.featured + ''} />
	<meta name="twitter:image" content={data.meta.featured + ''} />

	<meta name="twitter:site" content="@kinkyvibearg" />
	<meta name="twitter:card" content="summary_large_image" />
	<meta property="og:type" content="article" />

	<meta property="article:published_time" content={data.meta.published_date?.toString()} />
	<meta property="article:modified_time" content={data.meta.updated_date?.toString()} />
	<meta property="article:author" content={data.meta.authors?.join(', ')} />
	<!-- <meta property="article:section" content="" /> -->
	<meta property="article:tag" content={data.meta.tags?.join(', ')} />
</svelte:head>
<article class="h-entry">
	<a href={$page.url.href} hidden aria-hidden class="u-url">Link</a>
	<h1 id="title p-name">{data.meta.title}</h1>
	{#if data.meta.authors && data.meta.authors.length > 0}
		{@const authors = data.meta.authors}
		<address>
			{#await data.authorsProfiles}
				{authors.slice(0, authors.length - 1).join(', ') + ' & ' + authors[authors.length - 1]}
			{:then authorsProfiles}
				{#each authors as author, i}
					{@const profile = authorsProfiles?.find(
						(/** @type {ProcessedPost} */ a) => a.meta.postID == author
					)}
					{#if i == authors.length - 1 && i > 0}
						&nbsp;&
					{:else if i > 0},
					{/if}
					{#if profile}
						<a rel="author" class="p-author u-url" href={profile.path}>{author}</a>
					{:else}
						<span class="p-author">{author}</span>
					{/if}
				{/each}
			{/await}
			&ThickSpace;-&ThickSpace;
			<time datetime={data.meta.published_date?.toString()} class="dt-published">
				{new Date(data.meta.published_date?.toString() ?? '').toLocaleDateString('es-AR', {
					dateStyle: 'long'
				})}
			</time>
		</address>
	{/if}
	{#if data.meta.tags}
		<div id="tags">
			<Tags tags={data.meta.tags} />
		</div>
	{/if}
	{#if data.meta.summary}
		<div class="content">
			<p class="p-summary">
				{data.meta.summary}
			</p>
		</div>
	{/if}
	{#if data.meta.original_published_date}
		<div id="via" class="h-cite">
			Fecha de publicación original:
			<span class="dt-published">
				{new Date(data.meta.original_published_date?.toString() ?? '').toLocaleDateString('es-AR', {
					dateStyle: 'long'
				})}
			</span><br />
			{#if data.meta.link}
				<a href={data.meta.link} target="_blank" class="u-url">Link al original</a>
			{/if}
		</div>
	{/if}
	<div class="content" use:processContent>
		<svelte:component this={data.content} />
	</div>
	{#if data.meta.tags?.includes('KinkyVibe')}
		<div id="cafecito">
			Este material fue proporcionado por <a rel="author" href="/amigues/KinkyVibe">nosotres</a> ✨.
			Si te resultó valioso,
			<a href="https://cafecito.app/kinkyvibe" target="_blank"
				>considerá apoyarnos con algún cafecito</a
			>. 🤗
		</div>
	{/if}
</article>

<hr />

{#if data.meta.authors.length > 0}
	{#await data.authorsProfiles then authorsData}
		{#each authorsData ?? [] as { path, meta: author }}
			<a class="author-callout" rel="author" href={path}>
				<img
					class="author-image"
					src={(author.logo ?? author.photo ?? author.featured) + ''}
					alt=""
				/>
				<span class="author-title">{author.title}</span>
				<span class="author-summary">{author.summary}</span>
			</a>
		{/each}
	{/await}
{/if}

{#if relatedPosts.length > 0}
	<div class="content">
		<h3>
			Más cosas de
			{data.meta.authors.length == 1
				? data.meta.authors[0]
				: [data.meta.authors.slice(0, -1).join(', '), data.meta.authors.slice(-1)[0]].join(' o ')}
		</h3>
	</div>
	<PostList posts={relatedPosts} />
{/if}

<style lang="scss">
	#cafecito,
	#via {
		max-width: 50rem;
		margin: 2em auto;
		width: 100%;
		padding: 1em;
		color: white;
		border-radius: 0.3em;
	}
	#via {
		background: var(--2-light);
		font-size: var(--step-0);
		a {
			--color: var(--4-light);
		}
	}
	#cafecito {
		margin-top: 1em;
		font-size: var(--step-1);
		background: var(--2-light);
		a {
			--color: var(--4-light);
		}
	}
	#tags {
		margin-inline: auto;
		max-width: 70rem;
		width: 100%;
		margin-top: 2em;
		justify-content: center;
	}
	.author-callout {
		text-decoration: none;
		font-style: italic;
		font-size: 1.5em;
		padding: 0.4rem;
		border-radius: 999em;
		background: color-mix(in srgb, var(--2) 10%, transparent);
		outline: 2px solid var(--2);
		color: var(--2);
		display: grid;
		grid-template-areas: 'img title' 'img summary';
		grid-template-columns: 7rem 1fr;
		align-items: center;
		gap: 0.6rem;
		max-width: 50rem;
		margin: 1em auto;
		& > * {
			min-height: 0;
			min-width: 0;
		}
		.author-image {
			/* height: 1.5em; */
			border-radius: 999em;
			/* display: inline-block; */
			grid-area: img;
			max-height: 100%;
			max-width: 100%;
		}
		.author-title {
			grid-area: title;
			font-size: 1.5em;
			text-decoration: underline var(--1);
			color: black;
			line-height: 1;
		}
		.author-summary {
			grid-area: summary;
			padding-right: 1em;
		}
	}

	@media (max-width: 500px) {
		.author-callout {
			grid-template-areas: 'img title' 'summary summary';
			border-radius: 2.6em;
			.author-image {
				z-index: 1;
			}
			.author-title {
				padding-right: 0.5em;
			}
			.author-summary {
				padding: 2em;
				padding-top: 0;
			}
		}
	}
</style>

# =============================================
# ARCHIVO: ./src/routes/(content)/sitemap.xml/+server.js
# =============================================

import { fetchMarkdownPosts } from '$lib/utils';
const siteURL = 'https://kinkyvibe.ar';
// TODO add wiki entries to sitemap
/**
 *
 * @param {string|Date|undefined} d
 * @returns
 */
function date(d) {
	try {
		return new Date(d + '');
	} catch (e) {
		return new Date();
	}
}

/** @type {import('./$types').RequestHandler} */
export const GET = async () => {
	const allPosts = await fetchMarkdownPosts();
	const sortedPosts = allPosts.sort(
		(a, b) => date(b.meta.published_date).getTime() - date(a.meta.published_date).getTime()
	);
	const pages = ['/', '/material', '/calendario', '/amigues', '/wiki', '/todo'];
	const body = render(pages, sortedPosts);
	const options = {
		headers: {
			'Cache-Control': 'max-age=0, s-maxage=3600',
			'Content-Type': 'application/xml'
		}
	};

	return new Response(body, options);
};

/**
 *
 * @param {string[]} pages
 * @param {ProcessedPost[]} posts
 * @returns
 */
const render = (pages, posts) =>
	`<?xml version="1.0" encoding="UTF-8" ?>
<urlset
      xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.sitemaps.org/schemas/sitemap/0.9 http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd">
<url>
    <loc>${siteURL}</loc>
    <priority>1</priority>
    <lastmod>${new Date().toISOString()}</lastmod>
</url>
${pages.map(
	(p) =>
		`<url>
    <loc>${siteURL}${p}</loc>
    <priority>0.8</priority>
    <lastmod>${new Date().toISOString()}</lastmod>
</url>`
)}
${posts
	.map(
		(post) =>
			`<url>
    <loc>${siteURL}${post.path}</loc>
    <lastmod>${date(post.meta.updated_date ?? post.meta.published_date ?? '').toISOString()}</lastmod>
    <priority>0.6</priority>
</url>`
	)
	.join('')}
</urlset>
`;

# =============================================
# ARCHIVO: ./src/routes/(content)/todo/+page.svelte
# =============================================

<script>
	//@ts-nocheck
	import Tag from '$lib/components/Tag.svelte';
	import MiniMarkup from '$lib/components/MiniMarkup.svelte';
	import { Globe, ArrowRight } from 'lucide-svelte';
	import { flip } from 'svelte/animate';
	import { fade } from 'svelte/transition';
	import { filteredTags, tagManager, togglePositiveTagFilterFn } from '$lib/utils/stores';
	export let data;
	import PostList from '$lib/components/PostList.svelte';
	import InlineTag from '$lib/components/InlineTag.svelte';
	import { page } from '$app/stores';
	const style = 'display:inline;width:.9em;translate:0 .6em;';
</script>

<svelte:head>
	<title>KinkyVibe.ar</title>
</svelte:head>
<div class="glosario">
	<p>
		Acá vas a poder ver todo el contenido del sitio en un mismo lugar, tanto cosas del <InlineTag tag="calendario" />, como <InlineTag tag="material" /> y <InlineTag tag="amigues" />. Entonces si te interesa, por ejemplo, el <InlineTag tag="shibari" /> vas a poder ver tanto <InlineTag tag="libros" internalTag="libro" /> y <InlineTag tag="talleres" internalTag="taller" /> como les profesionales que dan <InlineTag tag="clases" /> u ofrecen <InlineTag tag="sesiones" />.
	</p>
	<dl>
		{#each $filteredTags.map($tagManager.get).filter(i=>i.parsedDescription) as termino (termino.id)}
			{@const name = termino.visible_name ?? termino.id}
			<div animate:flip in:fade>
				<div>
					<button on:click={() => $togglePositiveTagFilterFn(false, termino.id)}>x</button>
					<dt>
						{termino.icon ?? ''}{name.charAt(0).toUpperCase() + name.slice(1)}
						{#if data.wiki.find((w) => w.meta.wiki == termino.id)}
							<a href="/wiki/{termino.id}" class="gotowiki">
								<span>
									<Globe {style} />
									Es más complejo
									<ArrowRight {style} />
								</span>
							</a>
						{/if}
					</dt>
					<dd>
						{#each termino.parsedDescription as d}
							{#if d.type == 'link'}
								<Tag
									tag={d.line}
									onInput={(evt, tag) => $togglePositiveTagFilterFn(evt.target?.checked, d.line)}
									isCheckbox
									checked={$page.url.searchParams.has('tags') &&
										$page.url.searchParams.get('tags')?.split(',').includes(d.line)}
									--off-background="color-mix(in srgb, var(--1-light) 10%, transparent)"
									--font-size="1em"
									--padding="0.1em 0.2em"
									--border-radius=".3em"
									noBorder
								/>
							{:else}
								{d.line}
							{/if}
						{/each}

						{#if termino.related}
							<small>
								Ver también:
								{#each termino.related as tag, i}
									<Tag
										{tag}
										onInput={(evt, _) => $togglePositiveTagFilterFn(evt.target?.checked, tag)}
										isCheckbox
										checked={$page.url.searchParams.has('tags') &&
											$page.url.searchParams.get('tags')?.split(',').includes(tag)}
										--off-background="color-mix(in srgb, var(--1-light) 10%, transparent)"
										--font-size="1em"
										--padding="0.1em 0.2em"
										--border-radius=".3em"
										noBorder
									/>
									{i < termino.related.length - 1 ? ', ' : ''}
								{/each}
								.
							</small>
						{/if}
					</dd>
				</div>
			</div>
		{/each}
	</dl>
</div>
<PostList posts={data.allPosts} />

	<style lang="scss">
	.glosario {
		max-width: 60rem;
		margin-inline: auto;
		--color: blue;
		background: color-mix(in srgb, var(--color) 2%, white);
		padding: 1em 2em;
		outline: 2px solid var(--color);
		border-radius: 1em;
		color: color-mix(in srgb, var(--color) 50%, black);
		margin-bottom: 2em;
		line-height: 1.5;
		p {
			font-size: var(--step-0);
		}
		button {
			position: absolute;
			left: 0em;
			padding: 0.2em;
			font-size: var(--step-0);
			cursor: pointer;
			border: 0;
			outline: 0;
			background: transparent;
			opacity: 0.3;
			top: 0;
			line-height: 1.4;
			transition: 100ms;
		}
		button:hover {
			opacity: 0.7;
		}
		dl {
			width: 100%;
			margin-inline: auto;
			font-size: var(--step-0);
			position: relative;
		}
		dl > div {
			position: relative;
			margin-top: 1em;
			display: grid;
			grid-template-columns: 1fr;
			transition: 100ms;
			gap: 0.8em;
		}
		dt {
			font-weight: bold;
			color: var(--color);
			margin-left: 1em;
		}
		dd small:last-of-type {
			display: inline-block;
			margin-left: 0.3em;
			opacity: 0.8;
			text-align: right;
		}
		.gotowiki {
			/* --color: var(--2); */
			color: var(--color);
			border: 1px solid color-mix(in srgb, var(--color) 60%, transparent);
			background: color-mix(in srgb, var(--color) 10%, transparent);
			border-radius: 1em;
			padding: 0.3em;
			/* place-content: center; */
			text-align: center;
			text-decoration: none;
			font-size: calc(0.85 * var(--step--1));
			line-height: 1;
			position: relative;
			left: 0;
			transition: 100ms;
			margin-left: 0.5em;
			bottom: 0.1em;
			opacity: 0.8;
			&:hover {
				left: 0.3em;
			}
		}
	}
</style>

# =============================================
# ARCHIVO: ./src/routes/(content)/wiki/+page.svelte
# =============================================

<script>
	import GlosarioTree from '$lib/components/GlosarioTree.svelte';
	import { wikiTagManager, tagManager, query } from '$lib/utils/stores';
	import { page } from '$app/stores';
	import { Search, Construction } from 'lucide-svelte';
	import tagsFactory from '$lib/utils/tags';

	query.set('');

	/**
	 * @param {string | undefined} a
	 * @param {string} q
	 */
	function includesNormalized(a, q) {
		if (a === undefined) {
			return false;
		}
		let normalize = (/** @type {string} */ s) =>
			s
				.toLowerCase()
				.replaceAll('á', 'a')
				.replaceAll('é', 'e')
				.replaceAll('í', 'i')
				.replaceAll('ó', 'o')
				.replaceAll('ú', 'u');
		return normalize(a).includes(normalize(q));
	}
	query.subscribe((newQuery) => {
		if (newQuery == undefined || newQuery.trim() == '') {
			wikiTagManager.update(() => tagsFactory());
			// $page.url.searchParams.delete('q');
		} else {
			// $page.url.searchParams.set('q', newQuery);
			wikiTagManager.update((wtm) => {
				/**@type {TagID[]}*/
				let del = [];
				let temp = tagsFactory();
				/**@type TagID[]*/
				let include = [];
				temp.tagsData().forEach((t) => {
					// console.log(t, newQuery);
					if (
						!includesNormalized(t.id, newQuery) &&
						!includesNormalized(t.visible_name, newQuery) &&
						!includesNormalized(t.description, newQuery) &&
						!includesNormalized(t.aka?.join(' '), newQuery) &&
						!includesNormalized(t.related?.join(' '), newQuery)
					) {
						// console.log('i.n. ', includesNormalized(t.id, newQuery), t.id, newQuery);
						// console.log('deleting', t.id);
						del.push(t.id);
					} else {
						include.push(...t.getAllParents());
					}
				});
				if (del.length > 0) {
					// console.log(temp.entries().length);
					del.forEach((t) => (!include.includes(t) ? temp.delete(t) : null));
					// console.log(temp.entries().length);
					return temp;
				} else return wtm;
			});
		}
	});
	const style = `
	font-size: var(--step-1);
	position:absolute;
	left: .6em;
	translate: 0 .5em;
	color: var(--1);
	z-index: 1;
	`;
	const wip_style = `
	font-size: var(--step-1);
	translate: 0 .1em;
	color: white;
	z-index: 1;
	`;
</script>

<svelte:head>
	<title>Kinkipedia - Enciclopedia Fetichista</title>
</svelte:head>
<article class="content">
	<h1>Kinkipedia</h1>
	<p class="callout" style:--callout-color="var(--1)">
		El BDSM no es inherentemente abusivo, pero sí puede usarse para ejercer violencia. Si estás en
		una situación de violencia podés contactarte con nosotres o consultar <a
			target="_blank"
			href="https://recursero.info/violencia-sexual/">el recursero</a
		>.
	</p>

	<dl>
		<div class="searchbox">
			<Search {style} />
			<input class="searchbox" type="search" bind:value={$query} />
		</div>
		{#key $wikiTagManager}
			<GlosarioTree />
		{/key}
	</dl>
	<p
		class="callout"
		style:--callout-color="var(--4)"
		style:--callout-secondary="white"
		style:color="var(--1)"
	>
		Esta kinkipedia está escrita, editada y organizada con sudor y posicionamiento político por <a
			href="/amigues/DemonWeb">@DemonWeb <small class="p-pronoun">él</small></a
		> <a href="/amigues/Gorro_Rojo">@Gorro_Rojo <small class="p-pronoun">eso/elle</small></a> y <a href="/amigues/KinkyBunny">@KinkyBunny <small class="p-pronoun">ellx</small></a>.
	</p>
</article>

<style lang="scss">
	.callout {
		--callout-color: var(--1);
		--callout-secondary: var(--2);
		font-size: var(--step-0);
		background: var(--callout-color);
		color: white;
		padding: 0.5em 0.76em;
		border-radius: 1rem;

		a {
			text-decoration: underline var(--callout-secondary);
			&:hover {
				color: var(--callout-secondary);
			}
		}
	}
	article {
		max-width: 50rem;
		margin: auto;
		font-size: var(--step-1);
		h1 {
			text-align: left;
		}
	}
	.searchbox {
		width: 100%;
		position: relative;
		/* z-index: -1; */
		/* pointer-events: none; */
	}
	.searchbox input {
		position: relative;
		width: 100%;
		border-radius: 10em;
		font-size: var(--step-1);
		padding: 0.4em 0.8em;
		padding-left: 2em;
		margin-bottom: 1em;
		border: 0;
		outline: 1px solid var(--1-light);

		transition: 100ms;
		&:focus {
			outline-width: 3px;
		}
	}
</style>

# =============================================
# ARCHIVO: ./src/routes/(content)/wiki/[term]/+page.js
# =============================================

import { fetchPost } from '$lib/utils/index.js';
import tagsFactory from '$lib/utils/tags';
export const prerender = 'auto';
/** @type {import("./$types").PageLoad} */
export async function load({ params }) {
	let post;
	let tagManager = tagsFactory();
	try {
		post = await fetchPost('wiki', params.term);
	} catch (e) {
		post = { tag: tagManager.get(params.term) };
	}
	return {
		...post
	};
}

# =============================================
# ARCHIVO: ./src/routes/(content)/wiki/[term]/+page.svelte
# =============================================

<script>
	import GlosarioItem from '$lib/components/GlosarioItem.svelte';
	import PostList from '$lib/components/PostList.svelte';
	import { tagManager, currentPostData } from '$lib/utils/stores.js';
	import { page } from '$app/stores';
	import { ChevronLeft, ChevronRight } from 'lucide-svelte';
	import MiniMarkup from '$lib/components/MiniMarkup.svelte';
	export let data;
	currentPostData.set({ category: 'wiki', path: $page.url.pathname });

	let haswiki = (/**@type string*/ n) => true || data.wiki?.some((e) => e.meta.wiki == n);
	/**@type {(termino:string, groups?: Group[], parents?: {name:string, disabled?: boolean}[])=>{name:string, disabled?: boolean}[][]}*/
	function getAscendance(termino) {
		/**@type {{name:string, disabled?: boolean}[][]}*/
		let branches = [];
		let tagParents = $tagManager.get(termino)?.parents?.filter((p) => p != 'root') ?? [];
		for (let p of tagParents) {
			let subbranch = [];
			let grandparents = getAscendance(p);
			if (grandparents.length > 0) {
				for (let g of grandparents) {
					subbranch.push([...g, { name: p, disabled: !haswiki(p) }]);
				}
			} else {
				subbranch.push([{ name: p, disabled: !haswiki(p) }]);
			}
			branches.push(...subbranch);
		}
		return branches.filter((branch) => branch.some((i) => !i.disabled));
	}

	/**@type {(termino:string, groups?: Group[], parents?: {name:string,disabled?:boolean}[])=>{name:string,disabled?:boolean}[][]}*/
	function getDescendance(termino) {
		/**@type {{name:string, disabled?: boolean}[][]}*/
		let branches = [];
		let tagChildren = $tagManager.get(termino)?.children ?? [];
		for (let c of tagChildren) {
			let grandchildren = getDescendance(c);
			if (grandchildren.length > 0) {
				for (let g of grandchildren) {
					branches.push([{ name: c, disabled: !haswiki(c) }, ...g]);
				}
			} else {
				branches.push([{ name: c, disabled: !haswiki(c) }]);
			}
		}
		return branches.filter((branch) => branch.some((i) => !i.disabled));
	}
	const guessedTitle = decodeURI($page.url.pathname.slice(6)).replaceAll('-', ' ');
	const ascendance = getAscendance(data?.meta?.wiki ?? guessedTitle ?? 'BDSM');
	const descendance = getDescendance(data?.meta?.wiki ?? guessedTitle ?? 'inglés');
	// const descendance = [[{ name: 'Shibari' }], [{ name: 'Momificación' }]];

	const style = `
	scale: .8;
	translate: 0 .5em;
	color: var(--1);
	`;

	const relatedPosts = data.allPosts.filter((p) => {
		if (p.meta.tags.includes(data?.meta?.wiki ?? data?.tag?.id ?? '')) return true;
		let children = $tagManager.get(data?.meta?.wiki ?? '')?.getAllChildren() ?? [];
		for (const c of children) {
			if (p.meta.tags.includes(c)) return true;
		}
		return false;
	});
</script>

<svelte:head>
	<title>{data?.meta?.title ?? data.tag?.visible_name} - KinkyVibe.ar</title>

	<meta property="og:title" content={data?.meta?.title} />
	<meta name="twitter:title" content={data?.meta?.title} />

	<meta name="description" content={data?.meta?.summary} />
	<meta name="twitter:description" content={data?.meta?.summary} />
	<meta property="og:description" content={data?.meta?.summary} />

	<meta property="og:image" content={data?.meta?.featured + ''} />
	<meta name="twitter:image" content={data?.meta?.featured + ''} />

	<meta name="twitter:site" content="@kinkyvibearg" />
	<meta name="twitter:card" content="summary_large_image" />
	<meta property="og:type" content="article" />

	<!-- <meta property="article:section" content="" /> -->
</svelte:head>

<article class="h-entry wiki" id="title">
	<div class="content">
		<GlosarioItem item={data?.tag?.id ?? data?.meta?.wiki} single title />
		{#if data.content}
			<svelte:component this={data.content} />
		{/if}
	</div>
	<hr />
	<div class="lineage">
		<div class="ascendance">
			{#each ascendance as line}
				<div>
					{#each line as { name, disabled = false }}
						<span class="line">
							{#if disabled}
							<ChevronLeft {style} /><span class="familiar-name">{name}</span>
						{:else}
							<ChevronLeft {style} /><a
								class="familiar-name"
								href={'/wiki/' + name.replaceAll(' ', '-')}>{name}</a
							>
						{/if}
						</span>
					{/each}
				</div>
			{/each}
		</div>
		<div class="descendance">
			{#each descendance as line}
				<div>
					{#each line as { name, disabled = false }}
						<span class="line">
							{#if disabled}
								<span class="familiar-name">{name}</span>
								<ChevronRight {style} />
							{:else}
								<a class="familiar-name" href={'/wiki/' + name.replaceAll(' ', '-')}>{name}</a>
								<ChevronRight {style} />
							{/if}
						</span>
					{/each}
				</div>
			{/each}
		</div>
	</div>
</article>
{#if relatedPosts.length > 0}
	<PostList posts={relatedPosts}>
		<hr />
		<h2>Materiales, amigues y eventos relevantes</h2>
	</PostList>
{/if}

<style>
	h2 {
		text-align: center;
		width: 100%;
		font-size: var(--step-3);
	}

	.lineage {
		max-width: 45rem;
		width: 100%;
		margin-inline: auto;
		display: flex;
		justify-content: space-between;
		margin-top: 1em;
	}
	.ascendance,
	.descendance {
		display: flex;
		flex-wrap: wrap;
		gap: 0.5em;
		flex-direction: column;
	}
	.ascendance div > *,
	.descendance div > * {
		position: relative;
	}
	.lineage a {
		background: white;
		padding: .2em .5em;
		border-radius: var(--round);
		text-decoration: none;
	}
	.ascendance div,
	.descendance div {
		display: flex;
		gap: 0.5em;
	}
</style>

# =============================================
# ARCHIVO: ./src/routes/+layout.server.js
# =============================================

import { fetchMarkdownPosts } from '$lib/utils';
/** @type {import("./$types").LayoutServerLoad} */
export const load = async ({ url, locals }) => {
	let allPosts = await fetchMarkdownPosts();
	let wiki = await fetchMarkdownPosts(true);
	// let allPosts = await (await fetch('/api/posts')).json()
	// let wiki = await (await fetch('/api/wiki')).json();
	return {
		currentRoute: url.pathname,
		allPosts,
		wiki,
		user: locals.user
	};
};

# =============================================
# ARCHIVO: ./src/routes/+layout.svelte
# =============================================

<script>
	import '$lib/styles/style.scss';
	import {
		filteredTags,
		togglePositiveTagFilterFn
	} from '$lib/utils/stores';
	import { page } from '$app/stores';
	// onMount(() => {
	filteredTags.set([]);
	// });
	togglePositiveTagFilterFn.update(
		() =>
			function (checked, tag) {
				if (checked) {
					filteredTags.update((fTags) => [...fTags, tag]);
				} else {
					filteredTags.update((fTags) => [
						...fTags.slice(0, fTags.indexOf(tag)),
						...fTags.slice(fTags.indexOf(tag) + 1)
					]);
				}
				$page.url.searchParams.set('tags', $filteredTags.join(','));
				if ($filteredTags.length > 0) {
					window.history.pushState('', '', `?${$page.url.searchParams.toString()}`);
				} else {
					$page.url.searchParams.delete('tags');
					window.history.replaceState('', '', $page.url);
				}
			}
	);
</script>

<svelte:head>
	<link rel="icon" href="/favicon-32x32.png" />
	<meta name="theme-color" content="hsl(319, 90%, 60%)" />
	<meta property="og:url" content={$page.url.href} />
</svelte:head>

<slot></slot>
# =============================================
# ARCHIVO: ./src/routes/.well-known/[param]/+server.js
# =============================================

import { redirect } from "@sveltejs/kit";

/** @type {import("./$types").RequestHandler} */
export function GET({ url }) {
    url.host = "fed.brid.gy"
    throw redirect(303, url);
}
# =============================================
# ARCHIVO: ./src/routes/api/+server.js
# =============================================

import { json } from '@sveltejs/kit';
import { fetchMarkdownPosts } from '$lib/utils';
export async function GET() {
	/**@type ProcessedPost[] */
	return json(await fetchMarkdownPosts());
}

# =============================================
# ARCHIVO: ./src/routes/api/posts/+server.js
# =============================================

import { json } from '@sveltejs/kit';
import { fetchMarkdownPosts } from '$lib/utils';
export const prerender = true;

/** @type {import("../$types").RequestHandler} */
export async function GET() {
	/**@type ProcessedPost[] */
	return json(await fetchMarkdownPosts());
}

# =============================================
# ARCHIVO: ./src/routes/api/wiki/+server.js
# =============================================

import { json } from '@sveltejs/kit';
import { fetchMarkdownPosts } from '$lib/utils';
export const prerender = true;

/** @type {import("../$types").RequestHandler} */
export async function GET() {
	/**@type ProcessedPost[] */
	return json(await fetchMarkdownPosts(true));
}

# =============================================
# ARCHIVO: ./src/routes/auch/+page.server.js
# =============================================

import { redirect } from '@sveltejs/kit';

export async function load() {
	throw redirect(307, 'https://t.me/+IK9FeXw-gtxlNTFh');
}

# =============================================
# ARCHIVO: ./src/routes/callback/+server.js
# =============================================

import { env } from '$env/dynamic/private';
import { redirect } from '@sveltejs/kit';
const clientId = env.GITHUB_CLIENT_ID;
const secret = env.GITHUB_CLIENT_SECRET;
const tokenURL = 'https://github.com/login/oauth/access_token';
export async function GET(request) {
	const code = request.url.searchParams.get('code') ?? '';
	const token = await getToken(code);
	request.locals.user_token = token;
	request.cookies.set('prevToken', request.cookies.get('userToken') ?? '', { path: '/' });
	request.cookies.set('userToken', token, { path: '/' });
	throw redirect(302, '/');
}

/**
 *
 *
 * @param {string} code
 * @return {string}
 */
function getToken(code) {
	// @ts-ignore
	return fetch(tokenURL, {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json',
			Accept: 'application/json'
		},
		body: JSON.stringify({
			client_id: clientId,
			client_secret: secret,
			code: code
		})
	})
		.then((r) => r.json())
		.then((r) => {
			if (r.error) {
				throw new Error(
					'Error from GitHub API: \n' + r.error + '\n' + r.error_description + '\n' + r.error_uri
				);
			} else {
				return r.access_token;
			}
		})
		.catch((err) => {
			throw new Error('Error at getToken: ' + err);
		});
}


// let i = {
// 	login: 'GorroRojo',
// 	id: 4594048,
// 	node_id: 'MDQ6VXNlcjQ1OTQwNDg=',
// 	avatar_url: 'https://avatars.githubusercontent.com/u/4594048?v=4',
// 	gravatar_id: '',
// 	url: 'https://api.github.com/users/GorroRojo',
// 	html_url: 'https://github.com/GorroRojo',
// 	organizations_url: 'https://api.github.com/users/GorroRojo/orgs',
// 	repos_url: 'https://api.github.com/users/GorroRojo/repos',
// 	type: 'User',
// 	name: 'Gorro_Rojo',
// 	company: null,
// 	blog: 'https://gorro.ar',
// 	email: 'gorro.rojo@gmail.com',
// };

# =============================================
# ARCHIVO: ./src/routes/login/+page.server.js
# =============================================

import { env } from '$env/dynamic/private';
import { redirect } from '@sveltejs/kit';
const target = 'https://github.com/login/oauth/authorize';
const clientId = env.GITHUB_CLIENT_ID;
/** @type {import("./$types").Actions} */
export const actions = {
	default: async ({request}) => {
		const sessionId = '1234';
		const data = await request.formData()
		const redirectTo = data.get('redirectTo') ?? '/';
		throw redirect(
			302,
			`${target}?client_id=${clientId}&state=${sessionId}&scope=repo&redirectTo=${redirectTo}`
		);
		// 	throw redirect(303, url.searchParams.get('redirectTo') ?? '/');
	}
};

# =============================================
# ARCHIVO: ./src/routes/login/+page.svelte
# =============================================

<script>
	import {page} from "$app/stores"
</script>
<main>
	<a href="/">⬅️ volver a la página</a>

	<form method="POST">
		<input type="submit" value="Iniciar sesión con GitHub"/>
		<input hidden type="text" name="redirectTo" value={$page.url.searchParams.get('redirectTo') ?? '/'} />
	</form>
</main>
<style>
	form {
		display: block;
		margin: auto auto;

	}
	main {
		display: grid;
		place-content: center;
		gap: 1em;
		height: 100vmin;
	}
</style>

# =============================================
# ARCHIVO: ./src/routes/logout/+server.js
# =============================================

import { redirect } from '@sveltejs/kit';

export async function GET(request) {
	// @ts-ignore
	request.locals.user_token = '';
	request.cookies.set('prevToken', request.cookies.get('userToken') ?? '', { path: '/' });
	request.cookies.set('userToken', '', { path: '/' });
	throw redirect(302, request.url.searchParams.get('redirectTo') ?? '/admin');
}

# =============================================
# ARCHIVO: ./src/routes/rss/+server.js
# =============================================

import { fetchMarkdownPosts } from '$lib/utils';
const siteURL = 'https://kinkyvibe.ar';
const siteTitle = 'KinkyVibe';
const siteDescription = 'Your site description here';

export const prerender = true;

export const GET = async () => {
	const allPosts = await fetchMarkdownPosts();
	const sortedPosts = allPosts.sort((a, b) => new Date(b.date) - new Date(a.date));

	const body = render(sortedPosts);
	const options = {
		headers: {
			'Cache-Control': 'max-age=0, s-maxage=3600',
			'Content-Type': 'application/xml'
		}
	};

	return new Response(body, options);
};

const render = (posts) => `<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>${siteTitle}</title>
<description>${siteDescription}</description>
<link>${siteURL}</link>
<atom:link href="${siteURL}/rss.xml" rel="self" type="application/rss+xml"/>
${posts
	.map(
		(post) => `<item>
<guid isPermaLink="true">${siteURL}${post.path}</guid>
<title>${post.meta.title}</title>
<link>${siteURL}${post.path}</link>
<description>${post.meta.title}</description>
<pubDate>${new Date(post.meta.published_date).toUTCString()}</pubDate>
</item>`
	)
	.join('')}
</channel>
</rss>
`;

# =============================================
# ARCHIVO: ./static/robots.txt
# =============================================

User-agent: *
Disallow: /_template
Disallow: /_tags
Disallow: /_glossary
# =============================================
# ARCHIVO: ./static/site.webmanifest
# =============================================

{
	"name": "KinkyVibe.ar",
	"short_name": "KinkyVibe.ar",
	"icons": [
		{ "src": "/android-chrome-192x192.png", "sizes": "192x192", "type": "image/png" },
		{ "src": "/android-chrome-512x512.png", "sizes": "512x512", "type": "image/png" }
	],
	"theme_color": "#ff48c4",
	"background_color": "#eee",
	"display": "standalone",
	"scope": "/",
	"start_url": "/"
}

# =============================================
# ARCHIVO: ./svelte.config.js
# =============================================

import { preprocessMeltUI, sequence } from '@melt-ui/pp';
import adapter from '@sveltejs/adapter-cloudflare';
import sveltePreprocess from 'svelte-preprocess';
import { mdsvex } from 'mdsvex';
import rehypeSlug from 'rehype-slug';
import autoprefixer from 'autoprefixer';
import toc from '@jsdevtools/rehype-toc';
import customRehype from './src/lib/utils/customRehype.js';
/** @type {import('@sveltejs/kit').Config}*/
const config = {
	kit: {
		alias: {
			$lib: '/src/lib/'
		},
		adapter: adapter()
	},
	extensions: ['.svelte', '.md', '.svx'],
	preprocess: sequence([
		sveltePreprocess({
			postcss: {
				plugins: [autoprefixer]
			}
		}),
		mdsvex({
			extensions: ['.md', '.svx'],
			smartypants: {
				quotes: true,
				ellipses: true,
				dashes: 'oldschool'
			},
			// remarkPlugins: [remarkGfm],
			rehypePlugins: [rehypeSlug, customRehype, toc]
		}),
		preprocessMeltUI()
	])
};
export default config;

# =============================================
# ARCHIVO: ./tests/test.js
# =============================================

import { expect, test } from '@playwright/test';

test('index page has expected h1', async ({ page }) => {
	await page.goto('/');
	await expect(page.getByRole('heading', { name: 'Welcome to SvelteKit' })).toBeVisible();
});

# =============================================
# ARCHIVO: ./vite.config.js
# =============================================

import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vitest/config';

export default defineConfig({
	plugins: [sveltekit()],
	test: {
		include: ['src/**/*.{test,spec}.{js,ts}']
	},
	optimizeDeps: {
		exclude: ["codemirror", "@codemirror/lang-markdown"]
	}
});

# =============================================
# ARCHIVO: ./wrangler.toml
# =============================================

compatibility_date = "2023_04_14"
compatibility_flags = [ "nodejs_compat" ]